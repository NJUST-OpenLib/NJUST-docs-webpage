{"/abc/":{"data":{"":"\r已设置免打扰，24小时内不再显示\r提示标题\r这里是通知的内容，可以写任意 Markdown 格式的文本。\r查看详情\r本日关闭"},"title":"NJUST OPENLAB"},"/about/":{"data":{"":"","njust-课程攻略共享计划#NJUST 课程攻略共享计划":"","历史#历史":"","参与#参与":"","愿景#愿景":"","鸣谢#鸣谢":"\rNJUST 课程攻略共享计划\r本项目由 NJUST OpenLab 负责维护。\nNJUST OpenLab 是 NJUST.WIKI（理工维基）基金会下属的团队。（虽然目前只有一个人）。\n特别说明：本站并非南京理工大学的官方网站，所提供的内容仅供参考。\n愿景\r消除信息不对等，追求更有意义的评价体系。 分享课程资料、学习方法，最大程度减少学习弯路。 历史\rHITSZ 自动化课程攻略共享计划于 2022 年 6 月由 lmh12138 创建，2023 年 11 月开始由 HITSZ OpenAuto 维护。\n参与\r如果你有可供分享的资料，欢迎创建 Pull Request 为对应课程的仓库增加新内容；如果对仓库中的内容有疑问或建议，可以通过创建 Issue 的方式提出。\n具体方式可以阅读我们的 参与指南。\n鸣谢\r本站大量使用 哈工大（深圳）自动化课程攻略共享计划的源代码。\nHITSZ OpenAuto是该项目的维护者，他们极为慷慨地将所有内容开源，同时提供了简洁明了、易于理解的文档。\n毫不夸张地讲，若没有 HOA 的贡献，便不会有本站的诞生。在此，我们向 HITSZ OpenAuto 致以诚挚的感谢。\n同时，NJUST 课程攻略共享计划的建设离不开这些项目提供的灵感：\nHITSZ 自动化课程攻略共享计划\n浙江大学相关项目（可能是最有影响力的课程开源项目计划）\n哈尔滨工业大学（深圳）计算机专业课程攻略\nHITSZ 自动化课程攻略共享计划\n由衷感谢每一位 南京理工大学课程攻略共享计划 的贡献者：\n目前仅记录在 GitHub 组织下参与的同学，但是我们同样感谢曾经通过邮件/ OpenAuto 仓库参与的同学！"},"title":"关于"},"/blog/":{"data":{"":"\rRSS 订阅 "},"title":"博客"},"/blog/access-github/":{"data":{"":"","1-introduction#1. Introduction":"","2-软件和网站#2. 软件和网站？":"","3-通过修改-hosts-文件访问-github#3. 通过修改 hosts 文件访问 GitHub":"","4-总结#4. 总结":"\r已经会魔法的 / 能够稳定访问 GitHub 的朋友，这篇文章对你来说帮助不大，本文面向刚开始接触 GitHub 的新朋友。\n本人不精通计算机网络知识，用语难免不严谨。本文只是分享一些自己的经验，如果有错误，欢迎指正。\n1. Introduction\r无论你是先从 GitHub 上的 OpenAuto 找到了这里，还是先从这里知道了 OpenAuto，并且想要进一步使用里面的资源，你都需要能够稳定地访问 GitHub。\nHITSZ OpenAuto 的资源基于 GitHub 托管，导致许多人问我们的第一个问题就是：\n为什么 GitHub 进不去啊？\n许多人在没有科学上网的情况下，访问 GitHub 会遇到各种各样的困难，比如：\nGitHub 网页打不开 偶然能访问 GitHub 上的仓库，但里面的文件无法下载 GitHub 仓库无法克隆 从本地推送到 GitHub 仓库失败，例如经典的报错 Failed to connect to github.com port 443: Timed out 解决这些问题的办法很多，一种是使用魔法，有魔法你就成功了 90%。 但不是所有人都能获取到好用的代理，本文也没办法教你😶，抱歉。\n但是，有一个好消息，那就是如果只是为了访问 GitHub，那么在不使用自建魔法的前提下难度并不高。\n2. 软件和网站？\r有许多免费的软件可以直接帮助我们访问 GitHub，这里只介绍一个我曾经用过的。\nWatt Toolkit：原名 Steam++，一个开源跨平台的多功能 Steam 工具箱，并且可以加速 GitHub 的访问。 目前已支持 Windows、macOS、Linux 和 Android，属于开箱即用的软件。 如果只需要下载本组织中的文件，可以使用本站提供的代理服务：\nGitHub 文件加速 3. 通过修改 hosts 文件访问 GitHub\r上面所述的使用软件，本质上还是使用别人帮我们设置好的代理上网，速度有时并不理想； 而使用镜像站点下载文件，前提是知道 GitHub 上文件的地址；为了获取地址，你通常还是直接访问 GitHub。最重要的是，这些工具随时可能失效。\n所以本文的核心内容不是分享软件和网站，而是教大家如何通过自己的操作连接 GitHub。\n3.1 基础知识\r先介绍几个常用的命令。 这些命令是在终端（Windows cmd / Powershell，Linux Bash）下运行的指令。\nping：测试网络连接是否正常，例如 ping github.com。这个命令在 Windows 和 Linux 下都可以使用。 ipconfig：（仅限在 Windows 下）查看本机的 IP 地址。 ifconfig：（仅限在 Linux 下）查看本机的 IP 地址。需要安装 net-tools。 3.2 获取 GitHub 的 IP 地址\r方法 1：手动查询\r首先保证使用 3.1 中的 ping 命令能够成功连接到 GitHub。 如果你的 ping 返回的是 Request timed out，那么说明你所处的网络环境有问题，这个不是本文能够解决的，因此不深入讨论。\n下一步，查询 GitHub 的 IP 地址。 提供 IP 查询的网站很多，这里给大家介绍 IP Address。\n进入网站，选择其中的 IP Address Lookup 功能（或直接点击这个链接：https://www.ipaddress.com/ip-lookup）。\n在搜索框中输入 github.com，点击 Lookup 就可以在结果中看到 GitHub 的 IP 地址了。\n我们查询这 4 个网站的 IP 地址，把它们记下来：\ngithub.com api.github.com github.global.ssl.fastly.net codeload.Github.com 这 4 个网站足够我们访问 GitHub、推送/拉取 GitHub 仓库、使用 GitHub 的 API（包括 GitHub Copilot）了。\n方法 2：别人已经帮你查好了\r手动查询 IP 地址的方法虽然不复杂，但是重复多次后会觉得麻烦。 好在你并不是唯一一个这么认为的人。\n访问 若风/github-hosts 这个 Gitee 仓库（Gitee 是国内的代码托管平台，不用担心连不上），README.md 已经列出了 GitHub 相关的多个 IP 地址。\n这些地址每天会多次自动更新。把它们一口气全部复制下来，下一步会用到。\n3.3 修改 hosts 文件\rhosts 文件是一个没有扩展名的文本文件，用于将 IP 地址映射到域名。\nWindows 中，hosts 文件位于 C:\\Windows\\System32\\drivers\\etc 目录下。\nLinux 中，hosts 文件位于 /etc 目录下。\n需要注意，无论是 Windows 还是 Linux，修改 hosts 文件都需要管理员权限。\n3.3.1 Windows\r如果使用记事本直接编辑 hosts 文件，系统会提示无法保存，因为没有管理员权限。 解决的办法有两个。\n把原有的 hosts 文件复制一份到系统目录外，编辑后再复制回去。 复制回去时只需临时提供管理员权限即可成功。 这个方法比较保险，相当于给 hosts 文件做了一个备份。\n打开管理员终端，输入命令 notepad C:\\Windows\\System32\\drivers\\etc\\hosts，这样就可以直接在记事本中编辑 hosts 文件了。\n在 hosts 文件的最下方，按如下格式添加在步骤 3.2 查询到的 IP 地址：\n# GitHub 140.82.113.3 github.com 140.82.113.5 api.github.com 146.75.77.194 github.global.ssl.fastly.net 140.82.114.9 codeload.Github.com\r（把上面的 IP 地址换成你查询到的地址）\n3.3.2 Linux\rLinux 下修改 hosts 文件的方法和 Windows 下类似，只是需要使用 sudo 命令。 不熟悉 vim 的朋友可以使用 nano 编辑器。\nsudo nano /etc/hosts\r然后在 hosts 文件的最下方按照同样的格式添加内容。\n3.4 测试\r修改完 hosts 文件后，我们就可以尝试访问 GitHub 了。\n4. 总结\r本文为大家介绍了一种通过修改 hosts 文件访问 GitHub 的方法。 这种方法不依赖任何需要本地安装的工具，因此不限设备、任何时间都可以使用。\n但是这种方法还是存在两个缺点：\n网站的 IP 地址是不固定的，因此 hosts 文件需要时常更新。如果某一天你发现你又连接不上 GitHub 了，那么就需要重新查询一下 GitHub 的 IP 地址了。 纯手工操作，每次更新会比较麻烦。 如果你不是活跃在 GitHub 上的开发者，只是偶尔需要获取 GitHub 上的资源，那么这种方法已经足够了。\n😉"},"title":"新人指南：不使用第三方工具访问 GitHub"},"/blog/auto-survival-guide/embedded/":{"data":{"":"","一gpio通用输入输出口#一、GPIO（通用输入输出口）":"","三uart串口#三、UART（串口）":"","二tim定时器#二、TIM（定时器）":"","四can一种总线#四、CAN（一种总线）":"负一、Windows 下环境配置\rhttps://www.bilibili.com/video/BV1214y1j7Vw\n零、绪论\rhttps://www.bilibili.com/video/BV1VT411N7dK\n一、GPIO（通用输入输出口）\r1.1 建立一个工程\rhttps://www.bilibili.com/video/BV1814y177UB\n1.2 GPIO 的基本功能\rhttps://www.bilibili.com/video/BV1rd4y1172K\n1.3 中断与 EXTI\rhttps://www.bilibili.com/video/BV1t84y1z7QU\n二、TIM（定时器）\r2.1 基础定时器\rhttps://www.bilibili.com/video/BV1Ee4y1e7tn\n2.2 通用定时器与 PWM\rhttps://www.bilibili.com/video/BV1fG411L7XH\n三、UART（串口）\r3.1 串口基础\rhttps://www.bilibili.com/video/BV1JW4y1E7Ep\n3.2 DMA 与空闲中断\rhttps://www.bilibili.com/video/BV198411e7F8\n四、CAN（一种总线）\r4.1 CAN 总线基础\rhttps://www.bilibili.com/video/BV1GP411A78u\n4.2 过滤器\rhttps://www.bilibili.com/video/BV1kD4y1t78S\n持续更新中……","负一windows-下环境配置#负一、Windows 下环境配置":"","零绪论#零、绪论":""},"title":"嵌入式软件培训教程"},"/blog/auto-survival-guide/imu/bmi088/index.zh/":{"data":{"":"","一cubemx-配置#一、CubeMX 配置":"","二代码编写#二、代码编写":"\r这里以博世传感器公司产出的 BMI088 型号的 IMU 为例，其里面有 3 轴高精度加速度计和 3 轴高精度陀螺仪，其他的特性不再介绍\nBMI088 的数据手册附在文件夹里面，可以自行阅读\n同时这里的 IMU 是安装在大疆公司出产的 RoboMaster 开发板 C 型，单片机芯片是 STM32F407IGH6，其外围电路已经设计好，只需要读取 IMU 数据即可。\n本篇不会介绍 SPI、I2C 等嵌入式通信协议，需要有一定嵌入式开发基础的同学来看（可以去看底层中介绍的 STM32 开发视频）\n文末附代码\n零、数据手册分析\r我们打开这款陀螺仪的手册，可以看到，手册的第一章讲述了 BMI088 的硬件特性，需要多少伏的电压、电流之类的，这一章只有在我们拿到 IMU 芯片，想把它设计装在自己的电路板上面的时候才会考虑到，其他时候这些硬件特性不是我们需要考虑的范围，也不是本篇要介绍的内容。\n第二章讲述了 BMI088 的内部结构，抓一些重点，BMI088 里面，在加速度计的部分有一个温度传感器可以读取；同时加速度计和陀螺仪均有中断口，可以高速输出数据；加速度计和陀螺仪共用一个输出总线，可以选择 SPI 总线或者 I2C 总线；陀螺仪部分有一个控制单元；\n第三章开始，讲述了怎样快速开始，告诉我们 IMU 是通过监测 PS 引脚的电平来决定采用 SPI 还是 I2C 通信协议，同时告诉了我们一个重要的信息，BMI088 的加速度计上电的时候默认是 I2C 通信方式，直到它监测到了 SPI 的片选 IO 口电平上升变化，同时加速度计默认是挂起模式，即不更新加速度或者温度等数据，但内部的 ID 号之类的是可以读取的，所以我们初始化的时候，要先将加速度计的片选 IO 口电平拉起，之后将加速度计的模式从挂起模式设置为正常模式。同时给出了一种快速的初始化过程，先上电，等 1ms，然后往 ACC_PWR_CTRL 寄存器写入 4，之后等待 50ms\n第四章开始，介绍了各个寄存器代表的意义和设置数值对应的结果，这一部分是读取的时候需要参考的，这里不再详细介绍\n第五章开始，列出了 BMI088 的加速度计和陀螺仪的寄存器表，这也是读取的时候需要参考的部分，这里不过多讲解\n第六章开始，讲述了如何使用 SPI 或者 I2C 与 BMI088 进行数据通信，这一章比较重要，是我们读取的基础\n第七章是 BMI088 的引脚图\n第八章是 BMI088 的设计参考图，以及需要参考的电路设计参数\n第九章是免责声明\n一、CubeMX 配置\r由于这里是使用 RoboMaster 开发板 C 型（以下简称“C 板”），我们需要看用户手册确定 C 板上面的 IMU 是怎么设计的\n可以看到，在芯片中，BMI088 的 PS 引脚是被接到了 GND 上面，也就是说，C 板上面的 BMI088 默认使用 SPI 通信方式进行通信，同时使用的是 C 板的 SPI1 总线。现在我们需要确定 Cube 中 SPI 配置的几个参数，就是下面这几个（这个图是我配置好的图，可以直接抄）\n首先是 Mode，没有特别说明的话，都选择全双工 SPI 通信，就是图上这个 Full-Duplex Master\n然后是 Hardware NSS Signal，这个是硬件片选的意思，我们这里采用软件写 CS 电平的方式，因为加速度计和陀螺仪共用一条 SPI 总线，我们需要通过片选来确定此时读取哪个模块，所以这个地方选择 Disable\n下方的 Frame Format，没有特别说明都选择 Motorola 格式\n再下方的 Data Size，没有特别说明都选择 8Bits\n然后是 First Bit，也就是大小端的问题，关于大小端是什么可以自行百度，这里不再赘述。同样查询数据手册发现\n这里的值的第一位是 bit7，也就是 MSB 端，所以可以断定我们的 First Bit 是 MSB first\n然后就到了时钟配置的预分频系数 Prescaler 这里，这里注意到是要跟你 C 板的时钟配置相关联的，放出我的 C 板时钟配置\n其中，C 板（F406 芯片）的 SPI1 总线是挂载在 APB1 时钟上的，也就是说这个时候 SPI1 的初始时钟是 84MHz，我们再来看数据手册中关于 SPI 的时钟要求\n可以发现，BMI088 的 SPI 时钟要求最大通信频率为 10MHz，所以我们默认的 Prescaler=2 的是肯定不能用的，因为\nSPI时钟频率 = APB1时钟频率 / 预分频系数\n所以在 APB1 时钟频率为 84MHz 的情况下，我们需要起码预分频系数要大于 8，所以我选择了 Prescaler=16\n下一个是 CPOL 和 CPHA，这两个一般是同时配置的，关于这两个参数代表的含义这里也不再赘述，可以自行百度。我们继续查询数据手册：\n手册上写的很清楚了，BMI088 的 SPI 通信支持‘00’和‘11’两种模式，在 Cube 里面，CPOL=0 和 CPOL=Low 是一个意思，CPHA=0 和 CPHA=1 edge 也是一个意思，所以我们可以同时选择’CPOL=Low,CPHA=1 edge’或者‘CPOL=High,CPHA=2 edge’，效果是一样的\n至于再下面的两个参数，CRC 和 NSS，按照默认就好了，即不需要 CRC 和软件片选\n配置完了这些参数，还需要注意一点，就是 C 板上面 SPI 的端口有可能和 Cube 上面默认生成的端口不一致，我们需要额外确认一下\n先观察 C 板的 SPI 端口，打开 C 板原理图：\n首先负责片选的 CS 口是不会被默认添加的，我们需要手动添加。观察得到，加速度计的 CS 口是 PA4，陀螺仪的片选口是 PB0，添加这两个 GPIO 口。同时观察 BMI088 数据手册得到，片选口拉低电平有效，所以把这两个 GPIO 口的电平选择默认高电平\n其次观察 SPI 的部分，检查 SPI1_MOSI 端口是否是 PA7，SPI1_CLK 端口是否是 PB3，SP1_MISO 端口是否是 PB4，正确的配置如下\n到此，我们的 SPI 部分就配置好了，用 CubeMX 生成代码即可\n二、代码编写\r代码编写的第一部分，先写一些比较基础的宏定义和变量类型，便于以后用\nSPI 端口定义：\n#define BMI088_SPI hspi1 #define BMI088_ACC_GPIOx GPIOA #define BMI088_ACC_GPIOp GPIO_PIN_4 #define BMI088_GYRO_GPIOx GPIOB #define BMI088_GYRO_GPIOp GPIO_PIN_0\rBMI088 用到的数据结构体定义\ntypedef struct acc_raw_data_t { float x; float y; float z; } acc_raw_data_t; typedef struct gyro_raw_data_t { float roll; float pitch; float yaw; } gyro_raw_data_t; typedef struct acc_data_t { acc_raw_data_t acc_raw_data; float sensor_time; float temperature; bool enable_self_test; } acc_data_t; typedef struct gyro_data_t { gyro_raw_data_t gyro_raw_data; bool enable_self_test; } gyro_data_t; typedef enum bmi088_error_e { NO_ERROR = 0, ACC_CHIP_ID_ERR = 0x01, ACC_DATA_ERR = 0x02, GYRO_CHIP_ID_ERR = 0x04, GYRO_DATA_ERR = 0x08, } bmi088_error_e; typedef struct bmi088_data_t { acc_data_t acc_data; bmi088_error_e bmi088_error; } bmi088_data_t;\rBMI088 的寄存器表\n/*-----加速度计寄存器表-----*/ #define ACC_CHIP_ID_ADDR 0x00 #define ACC_CHIP_ID_VAL 0x1E #define ACC_ERR_REG_ADDR 0x02 #define ACC_STATUS_ADDR 0x03 #define ACC_X_LSB_ADDR 0x12 #define ACC_X_MSB_ADDR 0x13 #define ACC_Y_LSB_ADDR 0x14 #define ACC_Y_MSB_ADDR 0x15 #define ACC_Z_LSB_ADDR 0x16 #define ACC_Z_MSB_ADDR 0x17 #define ACC_XYZ_LEN 6 #define SENSORTIME_0_ADDR 0x18 #define SENSORTIME_0_UNIT (39.0625f / 1000000.0f) #define SENSORTIME_1_ADDR 0x19 #define SENSORTIME_1_UNIT (10.0 / 1000.0f) #define SENSORTIME_2_ADDR 0x1A #define SENSORTIME_2_UNIT (2.56f) #define SENSORTIME_LEN 3 #define ACC_INT_STAT_1_ADDR 0x1D #define TEMP_MSB_ADDR 0x22 #define TEMP_LSB_ADDR 0x23 #define TEMP_LEN 2 #define TEMP_UNIT 0.125f #define TEMP_BIAS 23.0f #define ACC_CONF_ADDR 0x40 #define ACC_CONF_RESERVED 0x01 #define ACC_CONF_BWP_OSR4 0x00 #define ACC_CONF_BWP_OSR2 0x01 #define ACC_CONF_BWP_NORM 0x02 #define ACC_CONF_ODR_12_5_Hz 0x05 #define ACC_CONF_ODR_25_Hz 0x06 #define ACC_CONF_ODR_50_Hz 0x07 #define ACC_CONF_ODR_100_Hz 0x08 #define ACC_CONF_ODR_200_Hz 0x09 #define ACC_CONF_ODR_400_Hz 0x0A #define ACC_CONF_ODR_800_Hz 0x0B #define ACC_CONF_ODR_1600_Hz 0x0C #define ACC_RANGE_ADDR 0x41 #define ACC_RANGE_3G 0x00 #define ACC_RANGE_6G 0x01 #define ACC_RANGE_12G 0x02 #define ACC_RANGE_24G 0x03 #define INT1_IO_CTRL_ADDR 0x53 #define INT2_IO_CTRL_ADDR 0x54 #define INT_MAP_DATA_ADDR 0x58 #define ACC_SELF_TEST_ADDR 0x6D #define ACC_SELF_TEST_OFF 0x00 #define ACC_SELF_TEST_POS 0x0D #define ACC_SELF_TEST_NEG 0x09 #define ACC_PWR_CONF_ADDR 0x7C #define ACC_PWR_CONF_SUS 0x03 #define ACC_PWR_CONF_ACT 0x00 #define ACC_PWR_CTRL_ADDR 0x7D #define ACC_PWR_CTRL_ON 0x04 #define ACC_PWR_CTRL_OFF 0x00 #define ACC_SOFTRESET_ADDR 0x7E #define ACC_SOFTRESET_VAL 0xB6 /*-----陀螺仪寄存器表-----*/ #define GYRO_CHIP_ID_ADDR 0x00 #define GYRO_CHIP_ID_VAL 0x0F #define GYRO_RATE_X_LSB_ADDR 0x02 #define GYRO_RATE_X_MSB_ADDR 0x03 #define GYRO_RATE_Y_LSB_ADDR 0x04 #define GYRO_RATE_Y_MSB_ADDR 0x05 #define GYRO_RATE_Z_LSB_ADDR 0x06 #define GYRO_RATE_Z_MSB_ADDR 0x07 #define GYRO_XYZ_LEN 6 #define GYRO_INT_STAT_1_ADDR 0x0A #define GYRO_RANGE_ADDR 0x0F #define GYRO_RANGE_2000_DEG_S 0x00 #define GYRO_RANGE_1000_DEG_S 0x01 #define GYRO_RANGE_500_DEG_S 0x02 #define GYRO_RANGE_250_DEG_S 0x03 #define GYRO_RANGE_125_DEG_S 0x04 #define GYRO_BANDWIDTH_ADDR 0x10 #define GYRO_ODR_2000Hz_BANDWIDTH_532Hz 0x00 #define GYRO_ODR_2000Hz_BANDWIDTH_230Hz 0x01 #define GYRO_ODR_1000Hz_BANDWIDTH_116Hz 0x02 #define GYRO_ODR_400Hz_BANDWIDTH_47Hz 0x03 #define GYRO_ODR_200Hz_BANDWIDTH_23Hz 0x04 #define GYRO_ODR_100Hz_BANDWIDTH_12Hz 0x05 #define GYRO_ODR_200Hz_BANDWIDTH_64Hz 0x06 #define GYRO_ODR_100Hz_BANDWIDTH_32Hz 0x07 #define GYRO_LPM1_ADDR 0x11 #define GYRO_LPM1_NOR 0x00 #define GYRO_LPM1_SUS 0x80 #define GYRO_LPM1_DEEP_SUS 0x20 #define GYRO_SOFTRESET_ADDR 0x14 #define GYRO_SOFTRESET_VAL 0xB6 #define GYRO_INT_CTRL_ADDR 0x15 #define GYRO_INT3_INT4_IO_CONF_ADDR 0x16 #define GYRO_INT3_INT4_IO_MAP_ADDR 0x18 #define GYRO_SELF_TEST_ADDR 0x3C #define GYRO_SELF_TEST_ON 0x01\r然后观察 BMI088 数据手册中的陀螺仪通信部分\n得知，想要往陀螺仪中写入数据，需要先片选陀螺仪，第一个发送字节的 bit0 为 0，bit1-7 为地址，然后第二个发送字节为值\n所以我们可以得到以下代码\nvoid WriteDataToGyro(uint8_t addr, uint8_t data) { HAL_GPIO_WritePin(BMI088_GYRO_GPIOx, BMI088_GYRO_GPIOp, GPIO_PIN_RESET); uint8_t pTxData = (addr \u0026 BMI088_SPI_WRITE_CODE); HAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX) ; pTxData = data; HAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX) ; HAL_Delay(1); HAL_GPIO_WritePin(BMI088_GYRO_GPIOx, BMI088_GYRO_GPIOp, GPIO_PIN_SET); }\r同时，如果想要读取陀螺仪的数据，如果是单个数据的话，就需要第一个发送字节为的 bit0 为 1，bit1-7 为地址，第二个字节就是我们读取的数据。如果是读取多个数据的话，可以使用 burst-read 模式，即发送一次地址，然后连续读取即可，地址会自动自增。所以我们又可以得到以下代码\nvoid ReadSingleDataFromGyro(uint8_t addr, uint8_t *data) { HAL_GPIO_WritePin(BMI088_GYRO_GPIOx, BMI088_GYRO_GPIOp, GPIO_PIN_RESET); uint8_t pTxData = (addr | BMI088_SPI_READ_CODE); HAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX) ; HAL_SPI_Receive(\u0026BMI088_SPI, data, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_RX) ; HAL_GPIO_WritePin(BMI088_GYRO_GPIOx, BMI088_GYRO_GPIOp, GPIO_PIN_SET); } void ReadMultiDataFromGyro(uint8_t addr, uint8_t len, uint8_t *data) { HAL_GPIO_WritePin(BMI088_GYRO_GPIOx, BMI088_GYRO_GPIOp, GPIO_PIN_RESET); uint8_t pTxData = (addr | BMI088_SPI_READ_CODE); uint8_t pRxData; HAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX) ; for (int i = 0; i \u003c len; i++) { HAL_SPI_Receive(\u0026BMI088_SPI, \u0026pRxData, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_RX) ; data[i] = pRxData; } HAL_GPIO_WritePin(BMI088_GYRO_GPIOx, BMI088_GYRO_GPIOp, GPIO_PIN_SET); }\r这样陀螺仪数据的基础读写函数就写完了\n之后我们观察 BMI088 数据手册中的加速度计通信部分\n得知，加速度计的写部分跟陀螺仪没区别，但是加速度计的读的部分，其第二个字节是混乱的数据，所以需要用户读取两次才能得到正确的加速度计数据，综合得到以下代码\nvoid WriteDataToAcc(uint8_t addr, uint8_t data) { HAL_GPIO_WritePin(BMI088_ACC_GPIOx, BMI088_ACC_GPIOp, GPIO_PIN_RESET); uint8_t pTxData = (addr \u0026 BMI088_SPI_WRITE_CODE); HAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX) ; pTxData = data; HAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX) ; HAL_Delay(1); HAL_GPIO_WritePin(BMI088_ACC_GPIOx, BMI088_ACC_GPIOp, GPIO_PIN_SET); } void ReadSingleDataFromAcc(uint8_t addr, uint8_t *data) { HAL_GPIO_WritePin(BMI088_ACC_GPIOx, BMI088_ACC_GPIOp, GPIO_PIN_RESET); uint8_t pTxData = (addr | BMI088_SPI_READ_CODE); HAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX) ; HAL_SPI_Receive(\u0026BMI088_SPI, data, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_RX) ; HAL_SPI_Receive(\u0026BMI088_SPI, data, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_RX) ; HAL_GPIO_WritePin(BMI088_ACC_GPIOx, BMI088_ACC_GPIOp, GPIO_PIN_SET); } void ReadMultiDataFromAcc(uint8_t addr, uint8_t len, uint8_t *data) { HAL_GPIO_WritePin(BMI088_ACC_GPIOx, BMI088_ACC_GPIOp, GPIO_PIN_RESET); uint8_t pTxData = (addr | BMI088_SPI_READ_CODE); uint8_t pRxData; HAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX) ; HAL_SPI_Receive(\u0026BMI088_SPI, \u0026pRxData, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_RX) ; for (int i = 0; i \u003c len; i++) { HAL_SPI_Receive(\u0026BMI088_SPI, \u0026pRxData, 1, 1000); while (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_RX) ; data[i] = pRxData; } HAL_GPIO_WritePin(BMI088_ACC_GPIOx, BMI088_ACC_GPIOp, GPIO_PIN_SET); }\r这样子我们的基础读写函数就写好了\n剩下的就是一些完善性的功能了，没有什么难度，赋上代码和效果图\nbmi088.c\n/**\r* @Author : Minghang Li\r* @Date : 2022-11-25 22:54\r* @LastEditTime : 2022-11-28 16:32\r* @Note :\r* @Copyright(c) : Minghang Li Copyright\r*/\r#include \"bmi088.h\"\r#include \u003cmath.h\u003e\r#include \"bmi088reg.h\"\r#include \"gpio.h\"\r#include \"spi.h\"\rbmi088_error_e BMI088_INIT(void) {\rbmi088_error_e error = NO_ERROR;\rBMI088_CONF_INIT();\rerror |= VerifyAccChipID();\rerror |= VerifyGyroChipID();\rif (1) { // 将来改成变量控制自检\rerror |= VerifyAccSelfTest();\r}\rif (1) { // 将来改成变量控制自检\rerror |= VerifyGyroSelfTest();\r}\rreturn error;\r}\rvoid WriteDataToAcc(uint8_t addr, uint8_t data) {\rHAL_GPIO_WritePin(BMI088_ACC_GPIOx, BMI088_ACC_GPIOp, GPIO_PIN_RESET);\ruint8_t pTxData = (addr \u0026 BMI088_SPI_WRITE_CODE);\rHAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX)\r;\rpTxData = data;\rHAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX)\r;\rHAL_Delay(1);\rHAL_GPIO_WritePin(BMI088_ACC_GPIOx, BMI088_ACC_GPIOp, GPIO_PIN_SET);\r}\rvoid WriteDataToGyro(uint8_t addr, uint8_t data) {\rHAL_GPIO_WritePin(BMI088_GYRO_GPIOx, BMI088_GYRO_GPIOp, GPIO_PIN_RESET);\ruint8_t pTxData = (addr \u0026 BMI088_SPI_WRITE_CODE);\rHAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX)\r;\rpTxData = data;\rHAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX)\r;\rHAL_Delay(1);\rHAL_GPIO_WritePin(BMI088_GYRO_GPIOx, BMI088_GYRO_GPIOp, GPIO_PIN_SET);\r}\rvoid ReadSingleDataFromAcc(uint8_t addr, uint8_t *data) {\rHAL_GPIO_WritePin(BMI088_ACC_GPIOx, BMI088_ACC_GPIOp, GPIO_PIN_RESET);\ruint8_t pTxData = (addr | BMI088_SPI_READ_CODE);\rHAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX)\r;\rHAL_SPI_Receive(\u0026BMI088_SPI, data, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_RX)\r;\rHAL_SPI_Receive(\u0026BMI088_SPI, data, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_RX)\r;\rHAL_GPIO_WritePin(BMI088_ACC_GPIOx, BMI088_ACC_GPIOp, GPIO_PIN_SET);\r}\rvoid ReadSingleDataFromGyro(uint8_t addr, uint8_t *data) {\rHAL_GPIO_WritePin(BMI088_GYRO_GPIOx, BMI088_GYRO_GPIOp, GPIO_PIN_RESET);\ruint8_t pTxData = (addr | BMI088_SPI_READ_CODE);\rHAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX)\r;\rHAL_SPI_Receive(\u0026BMI088_SPI, data, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_RX)\r;\rHAL_GPIO_WritePin(BMI088_GYRO_GPIOx, BMI088_GYRO_GPIOp, GPIO_PIN_SET);\r}\rvoid ReadMultiDataFromAcc(uint8_t addr, uint8_t len, uint8_t *data) {\rHAL_GPIO_WritePin(BMI088_ACC_GPIOx, BMI088_ACC_GPIOp, GPIO_PIN_RESET);\ruint8_t pTxData = (addr | BMI088_SPI_READ_CODE);\ruint8_t pRxData;\rHAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX)\r;\rHAL_SPI_Receive(\u0026BMI088_SPI, \u0026pRxData, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_RX)\r;\rfor (int i = 0; i \u003c len; i++) {\rHAL_SPI_Receive(\u0026BMI088_SPI, \u0026pRxData, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_RX)\r;\rdata[i] = pRxData;\r}\rHAL_GPIO_WritePin(BMI088_ACC_GPIOx, BMI088_ACC_GPIOp, GPIO_PIN_SET);\r}\rvoid ReadMultiDataFromGyro(uint8_t addr, uint8_t len, uint8_t *data) {\rHAL_GPIO_WritePin(BMI088_GYRO_GPIOx, BMI088_GYRO_GPIOp, GPIO_PIN_RESET);\ruint8_t pTxData = (addr | BMI088_SPI_READ_CODE);\ruint8_t pRxData;\rHAL_SPI_Transmit(\u0026BMI088_SPI, \u0026pTxData, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_TX)\r;\rfor (int i = 0; i \u003c len; i++) {\rHAL_SPI_Receive(\u0026BMI088_SPI, \u0026pRxData, 1, 1000);\rwhile (HAL_SPI_GetState(\u0026BMI088_SPI) == HAL_SPI_STATE_BUSY_RX)\r;\rdata[i] = pRxData;\r}\rHAL_GPIO_WritePin(BMI088_GYRO_GPIOx, BMI088_GYRO_GPIOp, GPIO_PIN_SET);\r}\rvoid BMI088_CONF_INIT(void) {\r// 加速度计初始化\r// 先软重启，清空所有寄存器\rWriteDataToAcc(ACC_SOFTRESET_ADDR, ACC_SOFTRESET_VAL);\rHAL_Delay(50);\r// 打开加速度计电源\rWriteDataToAcc(ACC_PWR_CTRL_ADDR, ACC_PWR_CTRL_ON);\r// 加速度计变成正常模式\rWriteDataToAcc(ACC_PWR_CONF_ADDR, ACC_PWR_CONF_ACT);\r// 陀螺仪初始化\r// 先软重启，清空所有寄存器\rWriteDataToGyro(GYRO_SOFTRESET_ADDR, GYRO_SOFTRESET_VAL);\rHAL_Delay(50);\r// 陀螺仪变成正常模式\rWriteDataToGyro(GYRO_LPM1_ADDR, GYRO_LPM1_NOR);\r// 加速度计配置写入\r// 写入范围，+-3g的测量范围\rWriteDataToAcc(ACC_RANGE_ADDR, ACC_RANGE_3G);\r// 写入配置，正常带宽，1600hz输出频率\rWriteDataToAcc(ACC_CONF_ADDR,\r(ACC_CONF_RESERVED \u003c\u003c 7) | (ACC_CONF_BWP_NORM \u003c\u003c 6) | (ACC_CONF_ODR_1600_Hz));\r// 陀螺仪配置写入\r// 写入范围，+-500°/s的测量范围\rWriteDataToGyro(GYRO_RANGE_ADDR, GYRO_RANGE_500_DEG_S);\r// 写入带宽，2000Hz输出频率，532Hz滤波器带宽\rWriteDataToGyro(GYRO_BANDWIDTH_ADDR, GYRO_ODR_2000Hz_BANDWIDTH_532Hz);\r}\rbmi088_error_e VerifyAccChipID(void) {\ruint8_t chip_id;\rReadSingleDataFromAcc(ACC_CHIP_ID_ADDR, \u0026chip_id);\rif (chip_id != ACC_CHIP_ID_VAL) {\rreturn ACC_CHIP_ID_ERR;\r}\rreturn NO_ERROR;\r}\rbmi088_error_e VerifyGyroChipID(void) {\ruint8_t chip_id;\rReadSingleDataFromGyro(GYRO_CHIP_ID_ADDR, \u0026chip_id);\rif (chip_id != GYRO_CHIP_ID_VAL) {\rreturn GYRO_CHIP_ID_ERR;\r}\rreturn NO_ERROR;\r}\rbmi088_error_e VerifyAccSelfTest(void) {\racc_raw_data_t pos_data, neg_data;\rWriteDataToAcc(ACC_RANGE_ADDR, ACC_RANGE_24G);\rWriteDataToAcc(ACC_CONF_ADDR, 0xA7);\rHAL_Delay(10);\rWriteDataToAcc(ACC_SELF_TEST_ADDR, ACC_SELF_TEST_POS);\rHAL_Delay(100);\rReadAccData(\u0026pos_data);\rWriteDataToAcc(ACC_SELF_TEST_ADDR, ACC_SELF_TEST_NEG);\rHAL_Delay(100);\rReadAccData(\u0026neg_data);\rWriteDataToAcc(ACC_SELF_TEST_ADDR, ACC_SELF_TEST_OFF);\rHAL_Delay(100);\rif ((fabs(pos_data.x - neg_data.x) \u003e 0.1f) || (fabs(pos_data.y - neg_data.y) \u003e 0.1f) || (fabs(pos_data.z - neg_data.z) \u003e 0.1f)) {\rreturn ACC_DATA_ERR;\r}\rWriteDataToAcc(ACC_SOFTRESET_ADDR, ACC_SOFTRESET_VAL);\rWriteDataToAcc(ACC_PWR_CTRL_ADDR, ACC_PWR_CTRL_ON);\rWriteDataToAcc(ACC_PWR_CONF_ADDR, ACC_PWR_CONF_ACT);\rWriteDataToAcc(ACC_CONF_ADDR,\r(ACC_CONF_RESERVED \u003c\u003c 7) | (ACC_CONF_BWP_NORM \u003c\u003c 6) | (ACC_CONF_ODR_1600_Hz));\rWriteDataToAcc(ACC_RANGE_ADDR, ACC_RANGE_3G);\rreturn NO_ERROR;\r}\rbmi088_error_e VerifyGyroSelfTest(void) {\rWriteDataToGyro(GYRO_SELF_TEST_ADDR, GYRO_SELF_TEST_ON);\ruint8_t bist_rdy = 0x00, bist_fail;\rwhile (bist_rdy == 0) {\rReadSingleDataFromGyro(GYRO_SELF_TEST_ADDR, \u0026bist_rdy);\rbist_rdy = (bist_rdy \u0026 0x02) \u003e\u003e 1;\r}\rReadSingleDataFromGyro(GYRO_SELF_TEST_ADDR, \u0026bist_fail);\rbist_fail = (bist_fail \u0026 0x04) \u003e\u003e 2;\rif (bist_fail == 0) {\rreturn NO_ERROR;\r} else {\rreturn GYRO_DATA_ERR;\r}\r}\rvoid ReadAccData(acc_raw_data_t *data) {\ruint8_t buf[ACC_XYZ_LEN], range;\rint16_t acc[3];\rReadSingleDataFromAcc(ACC_RANGE_ADDR, \u0026range);\rReadMultiDataFromAcc(ACC_X_LSB_ADDR, ACC_XYZ_LEN, buf);\racc[0] = ((int16_t)buf[1] \u003c\u003c 8) + (int16_t)buf[0];\racc[1] = ((int16_t)buf[3] \u003c\u003c 8) + (int16_t)buf[2];\racc[2] = ((int16_t)buf[5] \u003c\u003c 8) + (int16_t)buf[4];\rdata-\u003ex = (float)acc[0] * BMI088_ACCEL_3G_SEN;\rdata-\u003ey = (float)acc[1] * BMI088_ACCEL_3G_SEN;\rdata-\u003ez = (float)acc[2] * BMI088_ACCEL_3G_SEN;\r}\rvoid ReadGyroData(gyro_raw_data_t *data) {\ruint8_t buf[GYRO_XYZ_LEN], range;\rint16_t gyro[3];\rfloat unit;\rReadSingleDataFromGyro(GYRO_RANGE_ADDR, \u0026range);\rswitch (range) {\rcase 0x00:\runit = 16.384;\rbreak;\rcase 0x01:\runit = 32.768;\rbreak;\rcase 0x02:\runit = 65.536;\rbreak;\rcase 0x03:\runit = 131.072;\rbreak;\rcase 0x04:\runit = 262.144;\rbreak;\rdefault:\runit = 16.384;\rbreak;\r}\rReadMultiDataFromGyro(GYRO_RATE_X_LSB_ADDR, GYRO_XYZ_LEN, buf);\rgyro[0] = ((int16_t)buf[1] \u003c\u003c 8) + (int16_t)buf[0];\rgyro[1] = ((int16_t)buf[3] \u003c\u003c 8) + (int16_t)buf[2];\rgyro[2] = ((int16_t)buf[5] \u003c\u003c 8) + (int16_t)buf[4];\rdata-\u003eroll = (float)gyro[0] / unit * DEG2SEC;\rdata-\u003epitch = (float)gyro[1] / unit * DEG2SEC;\rdata-\u003eyaw = (float)gyro[2] / unit * DEG2SEC;\r}\rvoid ReadAccSensorTime(float *time) {\ruint8_t buf[SENSORTIME_LEN];\rReadMultiDataFromAcc(SENSORTIME_0_ADDR, SENSORTIME_LEN, buf);\r*time = buf[0] * SENSORTIME_0_UNIT + buf[1] * SENSORTIME_1_UNIT + buf[2] * SENSORTIME_2_UNIT;\r}\rvoid ReadAccTemperature(float *temp) {\ruint8_t buf[TEMP_LEN];\rReadMultiDataFromAcc(TEMP_MSB_ADDR, TEMP_LEN, buf);\ruint16_t temp_uint11 = (buf[0] \u003c\u003c 3) + (buf[1] \u003e\u003e 5);\rint16_t temp_int11;\rif (temp_uint11 \u003e 1023) {\rtemp_int11 = (int16_t)temp_uint11 - 2048;\r} else {\rtemp_int11 = (int16_t)temp_uint11;\r}\r*temp = temp_int11 * TEMP_UNIT + TEMP_BIAS;\r}\rbmi088.h\n/**\r* @Author : Minghang Li\r* @Date : 2022-11-25 22:54\r* @LastEditTime : 2022-11-28 16:09\r* @Note :\r* @Copyright(c) : Minghang Li Copyright\r*/\r#pragma once\r#include \u003cstdbool.h\u003e\r#include \u003cstdint.h\u003e\r#include \"bmi088reg.h\"\r#define BMI088_SPI hspi1\r#define BMI088_ACC_GPIOx GPIOA\r#define BMI088_ACC_GPIOp GPIO_PIN_4\r#define BMI088_GYRO_GPIOx GPIOB\r#define BMI088_GYRO_GPIOp GPIO_PIN_0\rtypedef struct acc_raw_data_t {\rfloat x;\rfloat y;\rfloat z;\r} acc_raw_data_t;\rtypedef struct gyro_raw_data_t {\rfloat roll;\rfloat pitch;\rfloat yaw;\r} gyro_raw_data_t;\rtypedef struct acc_data_t {\racc_raw_data_t acc_raw_data;\rfloat sensor_time;\rfloat temperature;\rbool enable_self_test;\r} acc_data_t;\rtypedef struct gyro_data_t {\rgyro_raw_data_t gyro_raw_data;\rbool enable_self_test;\r} gyro_data_t;\rtypedef enum bmi088_error_e {\rNO_ERROR = 0,\rACC_CHIP_ID_ERR = 0x01,\rACC_DATA_ERR = 0x02,\rGYRO_CHIP_ID_ERR = 0x04,\rGYRO_DATA_ERR = 0x08,\r} bmi088_error_e;\rtypedef struct bmi088_data_t {\racc_data_t acc_data;\rbmi088_error_e bmi088_error;\r} bmi088_data_t;\r// 基础函数\rvoid WriteDataToAcc(uint8_t addr, uint8_t data);\rvoid WriteDataToGyro(uint8_t addr, uint8_t data);\rvoid ReadSingleDataFromAcc(uint8_t addr, uint8_t *data);\rvoid ReadSingleDataFromGyro(uint8_t addr, uint8_t *data);\rvoid ReadMultiDataFromAcc(uint8_t addr, uint8_t len, uint8_t *data);\rvoid ReadMultiDataFromGyro(uint8_t addr, uint8_t len, uint8_t *data);\r// 初始化函数\rbmi088_error_e BMI088_INIT(void);\rvoid BMI088_CONF_INIT(void);\r// 功能函数\rvoid ReadAccData(acc_raw_data_t *data);\rvoid ReadGyroData(gyro_raw_data_t *data);\rvoid ReadAccSensorTime(float *time);\rvoid ReadAccTemperature(float *temp);\r// 校验函数\rbmi088_error_e VerifyAccChipID(void);\rbmi088_error_e VerifyGyroChipID(void);\rbmi088_error_e VerifyAccSelfTest(void);\rbmi088_error_e VerifyGyroSelfTest(void);\rbmi088reg.h\n/**\r* @Author : Minghang Li\r* @Date : 2022-11-25 23:01\r* @LastEditTime : 2022-11-28 16:32\r* @Note :\r* @Copyright(c) : Minghang Li Copyright\r*/\r#pragma once\r#define BMI088_ACCEL_3G_SEN 0.0008974358974f\r#define DEG2SEC 0.0174532925f\r#define SEC2DEG 57.295779578f\r#define PI 3.14159265f\r/*-----bmi088的spi读取协议部分-----*/\r#define BMI088_SPI_WRITE_CODE 0x7F\r#define BMI088_SPI_READ_CODE 0x80\r/*-----加速度计寄存器表-----*/\r#define ACC_CHIP_ID_ADDR 0x00\r#define ACC_CHIP_ID_VAL 0x1E\r#define ACC_ERR_REG_ADDR 0x02\r#define ACC_STATUS_ADDR 0x03\r#define ACC_X_LSB_ADDR 0x12\r#define ACC_X_MSB_ADDR 0x13\r#define ACC_Y_LSB_ADDR 0x14\r#define ACC_Y_MSB_ADDR 0x15\r#define ACC_Z_LSB_ADDR 0x16\r#define ACC_Z_MSB_ADDR 0x17\r#define ACC_XYZ_LEN 6\r#define SENSORTIME_0_ADDR 0x18\r#define SENSORTIME_0_UNIT (39.0625f / 1000000.0f)\r#define SENSORTIME_1_ADDR 0x19\r#define SENSORTIME_1_UNIT (10.0 / 1000.0f)\r#define SENSORTIME_2_ADDR 0x1A\r#define SENSORTIME_2_UNIT (2.56f)\r#define SENSORTIME_LEN 3\r#define ACC_INT_STAT_1_ADDR 0x1D\r#define TEMP_MSB_ADDR 0x22\r#define TEMP_LSB_ADDR 0x23\r#define TEMP_LEN 2\r#define TEMP_UNIT 0.125f\r#define TEMP_BIAS 23.0f\r#define ACC_CONF_ADDR 0x40\r#define ACC_CONF_RESERVED 0x01\r#define ACC_CONF_BWP_OSR4 0x00\r#define ACC_CONF_BWP_OSR2 0x01\r#define ACC_CONF_BWP_NORM 0x02\r#define ACC_CONF_ODR_12_5_Hz 0x05\r#define ACC_CONF_ODR_25_Hz 0x06\r#define ACC_CONF_ODR_50_Hz 0x07\r#define ACC_CONF_ODR_100_Hz 0x08\r#define ACC_CONF_ODR_200_Hz 0x09\r#define ACC_CONF_ODR_400_Hz 0x0A\r#define ACC_CONF_ODR_800_Hz 0x0B\r#define ACC_CONF_ODR_1600_Hz 0x0C\r#define ACC_RANGE_ADDR 0x41\r#define ACC_RANGE_3G 0x00\r#define ACC_RANGE_6G 0x01\r#define ACC_RANGE_12G 0x02\r#define ACC_RANGE_24G 0x03\r#define INT1_IO_CTRL_ADDR 0x53\r#define INT2_IO_CTRL_ADDR 0x54\r#define INT_MAP_DATA_ADDR 0x58\r#define ACC_SELF_TEST_ADDR 0x6D\r#define ACC_SELF_TEST_OFF 0x00\r#define ACC_SELF_TEST_POS 0x0D\r#define ACC_SELF_TEST_NEG 0x09\r#define ACC_PWR_CONF_ADDR 0x7C\r#define ACC_PWR_CONF_SUS 0x03\r#define ACC_PWR_CONF_ACT 0x00\r#define ACC_PWR_CTRL_ADDR 0x7D\r#define ACC_PWR_CTRL_ON 0x04\r#define ACC_PWR_CTRL_OFF 0x00\r#define ACC_SOFTRESET_ADDR 0x7E\r#define ACC_SOFTRESET_VAL 0xB6\r/*-----陀螺仪寄存器表-----*/\r#define GYRO_CHIP_ID_ADDR 0x00\r#define GYRO_CHIP_ID_VAL 0x0F\r#define GYRO_RATE_X_LSB_ADDR 0x02\r#define GYRO_RATE_X_MSB_ADDR 0x03\r#define GYRO_RATE_Y_LSB_ADDR 0x04\r#define GYRO_RATE_Y_MSB_ADDR 0x05\r#define GYRO_RATE_Z_LSB_ADDR 0x06\r#define GYRO_RATE_Z_MSB_ADDR 0x07\r#define GYRO_XYZ_LEN 6\r#define GYRO_INT_STAT_1_ADDR 0x0A\r#define GYRO_RANGE_ADDR 0x0F\r#define GYRO_RANGE_2000_DEG_S 0x00\r#define GYRO_RANGE_1000_DEG_S 0x01\r#define GYRO_RANGE_500_DEG_S 0x02\r#define GYRO_RANGE_250_DEG_S 0x03\r#define GYRO_RANGE_125_DEG_S 0x04\r#define GYRO_BANDWIDTH_ADDR 0x10\r#define GYRO_ODR_2000Hz_BANDWIDTH_532Hz 0x00\r#define GYRO_ODR_2000Hz_BANDWIDTH_230Hz 0x01\r#define GYRO_ODR_1000Hz_BANDWIDTH_116Hz 0x02\r#define GYRO_ODR_400Hz_BANDWIDTH_47Hz 0x03\r#define GYRO_ODR_200Hz_BANDWIDTH_23Hz 0x04\r#define GYRO_ODR_100Hz_BANDWIDTH_12Hz 0x05\r#define GYRO_ODR_200Hz_BANDWIDTH_64Hz 0x06\r#define GYRO_ODR_100Hz_BANDWIDTH_32Hz 0x07\r#define GYRO_LPM1_ADDR 0x11\r#define GYRO_LPM1_NOR 0x00\r#define GYRO_LPM1_SUS 0x80\r#define GYRO_LPM1_DEEP_SUS 0x20\r#define GYRO_SOFTRESET_ADDR 0x14\r#define GYRO_SOFTRESET_VAL 0xB6\r#define GYRO_INT_CTRL_ADDR 0x15\r#define GYRO_INT3_INT4_IO_CONF_ADDR 0x16\r#define GYRO_INT3_INT4_IO_MAP_ADDR 0x18\r#define GYRO_SELF_TEST_ADDR 0x3C\r#define GYRO_SELF_TEST_ON 0x01\r效果如下\nPrevious\rNext    \r/ [pdf]\rView the PDF file here.","零数据手册分析#零、数据手册分析":""},"title":"IMU 数据读取--以 BMI088 为例"},"/blog/auto-survival-guide/imu/ist8310/":{"data":{"":"","一cubemx-配置#一、CubeMX 配置":"","二数据读取#二、数据读取":"\r这里以 iSentek 公司产出的 IST8310 型号的磁力计为例，尺寸为 3.0 3.0 1.0mm，支持快速 I2C 通信，可达 400kHz，14 位磁场数据，测量范围可达 1600uT(x,y-axis) 和 2500uT(z-axis)，最高 200Hz 输出频率\nIST8310 的数据手册附在文件夹里面，可以自行阅读\n同时这里的磁力计是安装在大疆公司出产的 RoboMaster 开发板 C 型，单片机芯片是 STM32F407IGH6，其外围电路已经设计好，只需要读取磁力计数据即可。\n本篇不会介绍 SPI、I2C 等嵌入式通信协议，需要有一定嵌入式开发基础的同学来看（可以去看底层中介绍的 STM32 开发视频）\n文末附代码\n零、数据手册分析\r第一章讲了 IST8310 的特性，I2C 通信，最高支持 400kHz 通信速率，14 位或者 16 位自适应数据输出等特性\n第二章讲了内部结构\n第三章讲了电气特性\n第四章讲了如何联系他们\n然后数据手册就没了。。。在大疆的开发手册中找到了寄存器的手册，如下：\n一、CubeMX 配置\r点开 I2C 配置选项，下图是配好的：\n观察 IST8310 的数据手册，发现其支持最大 400kHz 的 I2C 通信速率，也就是快速 I2C 模式，所以第一行 I2C Speed Mode 我们选 Fast Mode\n同时不要忘记了在 C 板中 I2C3 的两个 IO 口分别是 PA8 和 PC9（一般来说都是这两个）\n之后观察大疆和 IST8310 的数据手册，发现控制 IST8310 重启的是 PG6 的 GPIO 口，低电平为重启，所以我们将其设置为高电平上拉输出模式\n因为我们读取 IST8310 的程序运行在 1kHz 的 freertos 线程中，无需使用中断方式，所以我们不配置中断口\n二、数据读取\r总代码附在文末，这里放一些核心函数\nIST8310 初始化：\nvoid IST8310_INIT(ist8310_data_t* ist8310_data) { memset(ist8310_data, 0, sizeof(ist8310_data_t)); ist8310_data-\u003emeg_error = IST8310_NO_ERROR; // 把磁力计重启 HAL_GPIO_WritePin(IST8310_GPIOx, IST8310_GPIOp, GPIO_PIN_RESET); HAL_Delay(50); HAL_GPIO_WritePin(IST8310_GPIOx, IST8310_GPIOp, GPIO_PIN_SET); HAL_Delay(50); // 基础配置 // 不使能中断，直接读取 WriteSingleDataFromIST8310(IST8310_CNTL2_ADDR, IST8310_STAT2_NONE_ALL); // 平均采样四次 WriteSingleDataFromIST8310(IST8310_AVGCNTL_ADDR, IST8310_AVGCNTL_FOURTH); // 200Hz的输出频率 WriteSingleDataFromIST8310(IST8310_CNTL1_ADDR, IST8310_CNTL1_CONTINUE); ist8310_data-\u003emeg_error |= VerifyMegId(\u0026ist8310_data-\u003echip_id); }\r读取单个数据：\nuint8_t ReadSingleDataFromIST8310(uint8_t addr) { uint8_t data; HAL_I2C_Mem_Read(\u0026IST8310_I2C, (IST8310_I2C_ADDR \u003c\u003c 1), addr, I2C_MEMADD_SIZE_8BIT, \u0026data, 1, 10); return data; }\r读取多个数据：\nvoid ReadMultiDataFromIST8310(uint8_t addr, uint8_t* data, uint8_t len) { HAL_I2C_Mem_Read(\u0026IST8310_I2C, (IST8310_I2C_ADDR \u003c\u003c 1), addr, I2C_MEMADD_SIZE_8BIT, data, len, 10); }\r写入单个数据：\nvoid WriteSingleDataFromIST8310(uint8_t addr, uint8_t data) { HAL_I2C_Mem_Write(\u0026IST8310_I2C, (IST8310_I2C_ADDR \u003c\u003c 1), addr, I2C_MEMADD_SIZE_8BIT, \u0026data, 1, 10); }\r写入多个数据：\nvoid WriteMultiDataFromIST8310(uint8_t addr, uint8_t* data, uint8_t len) { HAL_I2C_Mem_Write(\u0026IST8310_I2C, (IST8310_I2C_ADDR \u003c\u003c 1), addr, I2C_MEMADD_SIZE_8BIT, data, len, 10); }\r这里会发现一个比较有意思的事情，就是这里的地址都左移了一位，是因为根据 I2C 协议，[7:0]的一个字节的数据，前七位是地址，后一位是代表读或者写的位，这样子就需要把地址左移\n读取磁力计数据：\nvoid ReadIST8310Data(ist8310_raw_data_t* meg_data) { uint8_t buf[6]; int16_t temp_ist8310_data = 0; ReadMultiDataFromIST8310(IST8310_DATA_XL_ADDR, buf, 6); temp_ist8310_data = (int16_t)((buf[1] \u003c\u003c 8) | buf[0]); meg_data-\u003ex = MAG_SEN * temp_ist8310_data; temp_ist8310_data = (int16_t)((buf[3] \u003c\u003c 8) | buf[2]); meg_data-\u003ey = MAG_SEN * temp_ist8310_data; temp_ist8310_data = (int16_t)((buf[5] \u003c\u003c 8) | buf[4]); meg_data-\u003ez = MAG_SEN * temp_ist8310_data; }\r这里乘了一个系数 MAG_SEN，它的值是 0.3，是将读取到的数据转化为单位为 uT 的磁场值\n下面就是源码，把IST8310_INIT()函数放在程序开始的地方，然后剩下的读取函数放在不断执行的线程里，就可以得到磁力计数据了\nist8310.c\n/** * @Author : Minghang Li * @Date : 2022-12-03 14:29 * @LastEditTime : 2022-12-03 16:52 * @Note : * @Copyright(c) : Minghang Li Copyright */ #include \"ist8310.h\" #include \u003cstring.h\u003e #include \"i2c.h\" #include \"ist8310reg.h\" void IST8310_INIT(ist8310_data_t* ist8310_data) { memset(ist8310_data, 0, sizeof(ist8310_data_t)); ist8310_data-\u003emeg_error = IST8310_NO_ERROR; // 把磁力计重启 HAL_GPIO_WritePin(IST8310_GPIOx, IST8310_GPIOp, GPIO_PIN_RESET); HAL_Delay(50); HAL_GPIO_WritePin(IST8310_GPIOx, IST8310_GPIOp, GPIO_PIN_SET); HAL_Delay(50); // 基础配置 // 不使能中断，直接读取 WriteSingleDataFromIST8310(IST8310_CNTL2_ADDR, IST8310_STAT2_NONE_ALL); // 平均采样四次 WriteSingleDataFromIST8310(IST8310_AVGCNTL_ADDR, IST8310_AVGCNTL_FOURTH); // 200Hz的输出频率 WriteSingleDataFromIST8310(IST8310_CNTL1_ADDR, IST8310_CNTL1_CONTINUE); ist8310_data-\u003emeg_error |= VerifyMegId(\u0026ist8310_data-\u003echip_id); } uint8_t ReadSingleDataFromIST8310(uint8_t addr) { uint8_t data; HAL_I2C_Mem_Read(\u0026IST8310_I2C, (IST8310_I2C_ADDR \u003c\u003c 1), addr, I2C_MEMADD_SIZE_8BIT, \u0026data, 1, 10); return data; } void WriteSingleDataFromIST8310(uint8_t addr, uint8_t data) { HAL_I2C_Mem_Write(\u0026IST8310_I2C, (IST8310_I2C_ADDR \u003c\u003c 1), addr, I2C_MEMADD_SIZE_8BIT, \u0026data, 1, 10); } void ReadMultiDataFromIST8310(uint8_t addr, uint8_t* data, uint8_t len) { HAL_I2C_Mem_Read(\u0026IST8310_I2C, (IST8310_I2C_ADDR \u003c\u003c 1), addr, I2C_MEMADD_SIZE_8BIT, data, len, 10); } void WriteMultiDataFromIST8310(uint8_t addr, uint8_t* data, uint8_t len) { HAL_I2C_Mem_Write(\u0026IST8310_I2C, (IST8310_I2C_ADDR \u003c\u003c 1), addr, I2C_MEMADD_SIZE_8BIT, data, len, 10); } void ReadIST8310Data(ist8310_raw_data_t* meg_data) { uint8_t buf[6]; int16_t temp_ist8310_data = 0; ReadMultiDataFromIST8310(IST8310_DATA_XL_ADDR, buf, 6); temp_ist8310_data = (int16_t)((buf[1] \u003c\u003c 8) | buf[0]); meg_data-\u003ex = MAG_SEN * temp_ist8310_data; temp_ist8310_data = (int16_t)((buf[3] \u003c\u003c 8) | buf[2]); meg_data-\u003ey = MAG_SEN * temp_ist8310_data; temp_ist8310_data = (int16_t)((buf[5] \u003c\u003c 8) | buf[4]); meg_data-\u003ez = MAG_SEN * temp_ist8310_data; } ist8310_error_e VerifyMegId(uint8_t* id) { *id = ReadSingleDataFromIST8310(IST8310_CHIP_ID_ADDR); if (*id != IST8310_CHIP_ID_VAL) { return MEG_ID_ERROR; } else { return IST8310_NO_ERROR; } }\rist8310.h\n/**\r* @Author : Minghang Li\r* @Date : 2022-12-03 14:29\r* @LastEditTime : 2022-12-03 16:49\r* @Note :\r* @Copyright(c) : Minghang Li Copyright\r*/\r#pragma once\r#include \u003cstdint.h\u003e\rtypedef struct ist8310_raw_data_t {\rfloat x;\rfloat y;\rfloat z;\r} ist8310_raw_data_t;\rtypedef enum ist8310_error_e {\rIST8310_NO_ERROR = 0x00,\rMEG_ID_ERROR = 0x01,\r} ist8310_error_e;\rtypedef struct ist8310_data_t {\ruint8_t chip_id;\rist8310_raw_data_t meg_data;\rist8310_error_e meg_error;\r} ist8310_data_t;\r/*-----整形向uT转换-----*/\r#define MAG_SEN 0.3f\r/*-----I2C接口定义-----*/\r#define IST8310_I2C_ADDR 0x0E\r#define IST8310_I2C hi2c3\r/*-----GPIO口定义-----*/\r#define IST8310_GPIOx GPIOG\r#define IST8310_GPIOp GPIO_PIN_6\rvoid IST8310_INIT(ist8310_data_t* ist8310_data);\r// 基础读取函数\ruint8_t ReadSingleDataFromIST8310(uint8_t addr);\rvoid WriteSingleDataFromIST8310(uint8_t addr, uint8_t data);\rvoid ReadMultiDataFromIST8310(uint8_t addr, uint8_t* data, uint8_t len);\rvoid WriteMultiDataFromIST8310(uint8_t addr, uint8_t* data, uint8_t len);\r// 功能函数\rvoid ReadIST8310Data(ist8310_raw_data_t* meg_data);\r// 校验函数\rist8310_error_e VerifyMegId(uint8_t* id);\rist8310reg.h\n/**\r* @Author : Minghang Li\r* @Date : 2022-12-03 15:27\r* @LastEditTime : 2022-12-03 16:53\r* @Note :\r* @Copyright(c) : Minghang Li Copyright\r*/\r#pragma once\r/*-----IST8310寄存器地址-----*/\r#define IST8310_CHIP_ID_ADDR 0x00\r#define IST8310_CHIP_ID_VAL 0x10\r#define IST8310_STAT1_ADDR 0x02\r#define IST8310_DATA_XL_ADDR 0x03\r#define IST8310_DATA_XH_ADDR 0x04\r#define IST8310_DATA_YL_ADDR 0x05\r#define IST8310_DATA_YH_ADDR 0x06\r#define IST8310_DATA_ZL_ADDR 0x07\r#define IST8310_DATA_ZH_ADDR 0x08\r#define IST8310_STAT2_ADDR 0x09\r#define IST8310_CNTL1_ADDR 0x0A\r#define IST8310_CNTL1_SLEEP 0x00\r#define IST8310_CNTL1_SINGLE 0x01\r#define IST8310_CNTL1_CONTINUE 0x0B\r#define IST8310_CNTL2_ADDR 0x0B\r#define IST8310_STAT2_NONE_ALL 0x00\r#define IST8310_SELF_CHECK_ADDR 0x0C\r#define IST8310_TEMPL_ADDR 0x1C\r#define IST8310_TEMPH_ADDR 0x1D\r#define IST8310_AVGCNTL_ADDR 0x41\r#define IST8310_AVGCNTL_TWICE 0x09\r#define IST8310_AVGCNTL_FOURTH 0x12\r效果如下： ","零数据手册分析#零、数据手册分析":""},"title":"磁力计数据读取--以 IST8310 为例"},"/blog/auto-survival-guide/imu/overview/":{"data":{"":"","一发展历程#一、发展历程":"","三imu-误差#三、IMU 误差":"","二作用与缺点#二、作用与缺点":"","附某学长写过的-imu-专栏#附、某学长写过的 IMU 专栏":"\rIMU（Inertial measurement unit），惯性测量单元。其作用是测量本身的加速度以及角速度，有时还通过磁力计来测量朝向，当包含磁力计时，IMU 一般被称为 IMMU。\n零、测量原理\rIMU 的工作原理是通过其中包含的加速度计来测量 X、Y、Z 三个移动方向上的加速度，通过一重积分得到速度，通过二重积分得到位置，通过包含的陀螺仪测量 Roll、Pitch、Yaw 三个旋转方向上的角速度，通过一重积分得到姿态，包含磁力计的 IMU 还可以通过测量与地球磁场的夹角来确定当前的朝向，弥补加速度计在水平面上的测量缺失问题。\n一、发展历程\r这里引用一下知乎用户任乾的几张图\n陀螺仪发展历程：\n加速度计发展历程：\n二、作用与缺点\r最早的 IMU 是用来给导弹、潜艇、船舶作惯性导航的，还可用在车辆上，尽可能多的收集当前车辆的速度、转弯率、航向的准确数据。现在的民用级 IMU 是广泛运用在智能手机、运动设备、游戏手柄等，主要用于感知姿态和方向，用作估计距离的地方不多\n在导航中，通过卡尔曼滤波融合陀螺仪角速度积分与加速度计重力矢量解算得到的位置来估计高精度姿态。同时估计出的姿态用于将加速度计测量值转换为惯性参考系，一次积分得到线速度，二次积分得到位置，从而实现导航的目标。其好处在于不需要任何外来输入，也不需要装备在机身外侧，从而拥有了很好的隐蔽性以及抗干扰性。\n用 IMU 进行导航的缺点是 IMU 会出现累计误差，所以导航和民用设备所需的 IMU 的精度也是大不相同的，陀螺仪的精度从 0.1°/s 到 0.001°/h 均有，加速度计从 100mg 到 10ug 的也都有，这些精度粗略的对比的话，意味着对于均未校准过的 IMU 来说，最便宜的精度 100mg 的加速度计在 10 秒之后会丧失了提供 50 米精度的能力，而最贵的精度 10ug 的 IMU 在 17 分钟之后才丧失提供 50 米精度的能力。\n三、IMU 误差\rIMU 的误差通常由以下几部分组成：\n偏移误差：此项误差可分为传感器保持输入条件不变时的漂移，以及相同条件下的两次测量的不同 刻度因数误差：由于加速度计和陀螺仪均通过刻度因数进行信号转换，此中引入的非线性因素会导致误差 非敏感轴互耦误差：指的是传感器本身的轴存在不正交的情况导致的误差 安装误差：指的是传感器旋转与外界机身旋转不同轴带来的误差，与第三项误差基本相同，一个内一个外 加速度灵敏度误差：此项误差仅指陀螺仪，指的是陀螺仪的角速率测量因加速度的影响带来的误差 随机噪声：主要由结构的随机噪声和电路的随机噪声组成 不同领域对 IMU 精度的不同要求：\n附、某学长写过的 IMU 专栏\r车把手和轱辘印的知乎专栏","零测量原理#零、测量原理":""},"title":"IMU 综述"},"/blog/auto-survival-guide/math/":{"data":{"":"\rPrevious\rNext    \r/ [pdf]\rView the PDF file here."},"title":"卡尔曼滤波公式推导"},"/blog/auto-survival-guide/overview/":{"data":{"":"自动化其实是一门特别繁杂的课，涉及机械、电气、计算机等多个学科的专业知识\n在短短大学四年的学习中，可能要上工程制图、机械设计、电路、模电、数电等多门课，十分恶心\n这些课吧，有些可能有用，有些可能卵用没有，就比如机械设计，我是真没想明白有啥用，教会我怎么选螺丝？（笑）\n但话说回来，自动化这些课究竟是要干什么？\n没错，我也没想明白。\n但我大概知道一件事，通过大学四年的学习，有的同学坚定了自己转码的信心，有的同学找到了自己喜欢的机器人研究方向。以我做例子，在四年的技术和理论学习中，我大概对如何成为一名合格的机器人工程师有了一个初步的了解。\n对，这么多课，学校的目的应该是想让大伙成为一个全栈机器人工程师，但可惜确实有点难，对于大部分人来说，混个毕业，混个研究生，去找个 30w 的码农工作，就完事了。所以不想系统了解机器人工程的同学其实可以离开了。\n画了一张小图，大概浓缩了一个我对机器人系统的理解，也大概是这大学四年以来我点的技能树吧。\n首先是为啥要分成上层和底层捏，就跟人一样，大脑是上层，脊柱是底层，如果脊柱废了不影响大脑思考，大脑有一点点问题不影响人活着（虽然可能不太恰当但差不多是这个意思\n写了好多好多，也不是说每个技能树都要点到，就是我每个寒假或者暑假回家的时候就会点一个技能树，积少成多就这么多啦\n本部分就会就这里面涉及到的技术进行讲解，我会一个一个部分的写文档，并且附上相应的论文进行讲解，希望能坚持下来吧哈哈哈。\n希望看到这里的人都能成为稚晖君，加油吧朋友们。\nlmh. 2022.11.13 01:09"},"title":"综述"},"/blog/auto-survival-guide/ros/index.zh/":{"data":{"":"","解决-rosdep-init-与-rosdep-update-失败的问题#解决 rosdep init 与 rosdep update 失败的问题":"学 ROS 建议跟着 Autolabor 的赵虚左老师一起手把手从配环境装 ROS 开始学\nhttps://www.bilibili.com/video/BV1Ci4y1L7ZZ\n如何解决 rosdep init 与 rosdep update 失败的问题：rosdep 问题解决 解决 rosdep init 与 rosdep update 失败的问题\r网上的教程鱼龙混杂，根本不能用，还是自己写一个吧\n我们安装完 ROS 后，要进行如下两个操作：\nsudo rosdep init\rrosdep update\rrosdep能帮助我们安装 ROS 包所需要的依赖，然而执行的时候，通常会出现：\n这个问题来源是大陆的 DNS 污染，我们首先要手动更改域名解析：\n打开 https://site.ip138.com/ ，输入raw.githubusercontent.com，查询其 IP 地址：\n打开一个终端，输入：\nsudo vim /etc/hosts\r在文件最后的末尾添加：\n185.199.110.133 raw.githubusercontent.com\r当然，换成185.199.110.133或者185.199.109.133都可以\n保存退出，再执行：\nrosdep init\r如果还是访问不了的话，那我们手动进行rosdep init的操作：\n用电脑访问 https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list ,可看到如下界面：\n我们复制一下如下这几行，\n# os-specific listings first\ryaml https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/osx-homebrew.yaml osx\r# generic\ryaml https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/base.yaml\ryaml https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/python.yaml\ryaml https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/ruby.yaml\rgbpdistro https://raw.githubusercontent.com/ros/rosdistro/master/releases/fuerte.yaml fuerte\r# newer distributions (Groovy, Hydro, ...) must not be listed anymore, they are being fetched from the rosdistro index.yaml instead\r之后在终端中输入：\nsudo mkdir -p /etc/ros/rosdep/sources.list.d/\rcd /etc/ros/rosdep/sources.list.d/\rsudo vim 20-default.list\r把前面复制的内容粘贴进去，这实际上就完成了rosdep init的操作\n之后执行：\nrosdep update\r通常情况下，会出现：\n我们使用域名代理的方法进行解决\n执行：\nsudo vim /usr/lib/python2.7/dist-packages/rosdistro/__init__.py\r在第 68 行的https://raw.githubusercontent.com/ros/rosdistro/master/index-v4.yaml前面加上https://ghproxy.com/\n执行：\nsudo vim /usr/lib/python2.7/dist-packages/rosdep2/gbpdistro_support.py\r在第 34 行的https://raw.githubusercontent.com/ros/rosdistro/前面加上https://ghproxy.com/\n执行：\nsudo vim /usr/lib/python2.7/dist-packages/rosdep2/sources_list.py\r在第 64 行的https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list前面加上https://ghproxy.com/\n同一个文件，在第 301 行中添加：url=\"https://ghproxy.com/\"+url\n执行：\nsudo vim /usr/lib/python2.7/dist-packages/rosdep2/rep3.py\r在第 36 行的https://raw.githubusercontent.com/ros/rosdistro/master/releases/targets.yaml前面加上https://ghproxy.com/\n执行：\nsudo vim /usr/lib/python2.7/dist-packages/rosdistro/manifest_provider/github.py\r在第 68 行的https://raw.githubusercontent.com/%s/%s/package.xml前面加上https://ghproxy.com/\n同一个文件，在第 119 行的https://raw.githubusercontent.com/%s/%s/%s前面加上https://ghproxy.com/\n之后再执行：\nrosdep update\r可以看到成功执行，至此 ROS 完美安装成功"},"title":"ROS"},"/blog/cet-intro/":{"data":{"":"","#":"全国大学英语四、六级考试简称 CET（College English Test），是对于每位学子都很重要的考试。保研、考研、找工作都对英语成绩有要求，而四、六级成绩是其中最基础的两项（至少四级如此）。\n四六级考试每年进行两次，分别是 12 月份和 6 月份，每次考试有 2-3 套题。每次四六级考试开始报名时，学院都会有通知，切勿错过。\n本文主要介绍四、六级 笔试 的信息。然而，在此之前，先明确一个问题：\n要不要报考口试？\r四六级中，笔试和口试是两个独立的项目，且口试为选考项目。在报道成绩时，笔试和口试的成绩 分开报道：（可以点开 考试大纲 翻到第 212 页，看看四、六级的成绩单长什么样）\n笔试呈现为一个总分与三小项得分，大家平时说的「四六级考试成绩」或者「过没过」都指的是 笔试成绩，一般向用人单位提供的四六级成绩也是笔试成绩； 而口试的成绩只有等级没有分数。如果不报考口试，则该部分显示为空，但不影响笔试分数，也就「几乎」不影响你的四、六级成绩单在别人面前的呈现效果。只有确定想要通过四六级考试证明自己的口语水平的情况下才考虑报考口试。 大多数人并不用通过四六级考试证明自己的口语水平（要么没有需求，要么可以通过 IELTS / TOEFL 等考试来证明）。所以，对于绝大多数人，这个问题的结论是：\n不用报名。\n报名时官网会弹出来口语报名界面，一般来说无需理睬。（当然，假若你决计要报，哈工深本身就是四、六级口试考点，不用跑去其他地方，这点无需担心。）\n以下部分仅涉及四六级笔试部分。\n四六级成绩怎么看？\r首先区分两个概念： 原始分和报道分。原始分，也就是卷面总分，满分是 100 分；而报道分则是对原始分赋分得到。所谓赋分，就是通过某种原始分和报道分的对应关系，将原始分映射到报道分上的过程，实际上就是函数。\n四、六级成绩单上呈现的是 报道分，不是原始分。总报道分是用下面这个公式计算出来的： $$ 报道分 = \\frac{原始分 - Mean}{SD} \\times 70 + 500 $$ 其中，$ Mean $是常模群体1平均分，$ SD $是常模群体标准差；你可以认为是抽样确定好的常数。由于官方并不公布这两个常数，因此即使知道报道分，你也无法逆推出卷面分/原始分。\n各题型（见下一节）也有报道分，总报道分等于它们的和。报道分的满分是 710 分，其中听力满分 249 分（35%），阅读满分 249 分（35%），翻译和写作满分共 212 分（30%）。各题型的原始分占总原始分的比例，等于各题型的报道分占总报道分的比例。\n另外，四级不设及格线（官网原话），但四级成绩在 425 分及以上者才能报考六级。\n❓\r既然无法由报道分知道原始分，那么报道分有什么用呢？\rℹ️\r报道分数其实只是「卷面分在常模群体中排位比例」的反映；也就是说，可以从报道分得出你在全国考生（的代表群体）中的大致排名情况，它不过是排名的另一种说法；与原始分不同，报道分是赋分而来，绝对分数并不直接反映你的卷面情况。新高考地区的同学应该较为熟悉这一点。当然高考赋分的分数意义重大\r点此展开/收起四级分数 - 排名对照表\r四级报道分-排位对照表\r点此展开/收起六级分数 - 排名对照表\r六级报道分-排位对照表\rℹ️\r此处有关报道分的解释都引用自 官网分数解释 ，大家可以去查看，里面有更多例子。\r分项分数及试题组成\rPART 1 写作（15%）： 短文写作。\nPART 2 听力理解（35%） ：试卷上仅给出选项，试题在听力录音中；四、六级考试仅有这一项的题型构成不同。\n点此展开/收起详细题型构成\r四级：\n测试内容 测试题型 题量 分值比例 短篇新闻 选择题（单选） 7 题 7%（每题 1 分） 长对话 选择题（单选） 8 题 8%（每题 1 分） 听力篇章 选择题（单选） 10 题 20%（每题 2 分） 六级：\n测试内容 测试题型 题量 分值比例 长对话 选择题（单选） 8 题 8%（每题 1 分） 听力篇章 选择题（单选） 7 题 7%（每题 1 分） 讲话/报道/讲座 选择题（单选） 10 题 20%（每题 2 分） PART 3 阅读理解（35%）：\n1.词汇理解（选词填空，共 10 空，每小题 0.5 分，共占 5%）\n2.长篇阅读（给出 10 个句子，要求匹配到对应的段落，每小题 1 分，共占 10%）\n3.仔细阅读（10 小题，每小题 2 分，共占 20%。一般是两篇，每篇 5 道单项选择题）\nPART 4 翻译（15%）： 汉译英，翻译一段话。\n点击 这里 查看 CET 官网给出的的具体题型分布。\n考试大纲 从第 150 页开始给出具体的样卷，可以看看，熟悉题型分布。不过，实际上作文并不是印在最前头，而是试题册最后一面。\n考试流程\r哈工深考场不需要自带耳机，听力是广播播放！\n四级正式考试时间 9:00 - 11:20；六级正式考试时间 15:00 - 17:25。时间点可能有些许误差，以考前实际安排为准！\n时间 事项 四级 8:40 - 9:00\n六级 14:40 - 15:00 试音时间 四级 9:00 - 9:10\n六级 15:00 - 15:10 发放试题册2 、答题卡 1 和 23、条形码\n填写个人信息，粘贴条形码\n只允许浏览作文试题，\n禁止翻阅试题册其他部分 四级 9:10 - 9:40\n六级 15:10 - 15:40 作文答题时间\n只允许作答作文，也不能翻阅其他部分 四级 9:40 - 10:05\n六级 15:40 - 16:10 听力答题时间 四级 10:05 - 10:10\n六级 16:10 - 16:15 收答题卡 1，期间不允许作答。\n听力播放完毕后立即收卷，\n务必在听力播放间隙涂好答题卡 四级 10:10 - 11:20\n六级 16:15 - 17:25 完成其余部分 四级 11:20\n六级 17:25 考试结束，收答题卡 2 和试题册 备考策略\r诸位都是能上哈工深的人，相信大部分同学已经有了自己的一套英语学习习惯；适合自己的才是最好的，了解题型组成以后，如果读者觉得自己的习惯有效果，或者看完这一部分觉得「这人写的怎么怪怪的」，完全不必拘泥于笔者自己的建议，可以直接跳到 学习渠道推荐 。\n对于比较迷茫的同学，笔者推荐利用各种信息资源平台，例如 B 站——在上面搜索「四六级 XX 题型备考策略」，可以看到专门研究四六级的专业人士给出的建议，不妨试一试！\n下面给出的只是笔者的个人想法，不构成明确的行动指南。\n通过研究分数构成和真题，我们不难发现： 分值的大头是听力和阅读，各占 35%；此外，它们都是客观题，而客观题相比主观题最大的优势就是：可以蒙，可以利用各种做题技巧，拿分相对容易。相比之下，仅各占 15% 分值的作文和翻译都是实打实的分，性价比实在不高。 如果你觉得 考高分 比 提高英语水平 的优先级高一些，那么备考的重点也应该是客观题。\n客观题\r客观题的总体备考策略很简单——熟能生巧，毕竟都是客观题，只需要做做往年真题的这两部分，做多了手感自然就有了。\n听力\r一般而言听力的正确率低于阅读，因此笔者四、六级考前一周的复习时间主要是在练听力，力求在听懂大致意思的基础上，记住尽可能多的细节。\n阅读\r笔者英语老师推荐的做题顺序是\n两篇仔细阅读（阅读理解） 长篇阅读 词汇理解（选词填空） 也就是没必要按照试题册顺序来。理由也很功利简单：根据分值和难度综合判断，\n仔细阅读 分值高而且难度低、耗时相对短 长篇阅读 分值中等，但需要读非常长的文章 词汇理解 分值太低 当然笔者的情况是 阅读 + 翻译 时间充裕，所以我觉得没必要分这么细\n仔细阅读的做题步骤是：\n先读一个问题 看段落前几句或者通读某一段，定下答案区间 读完原文，再读选项并选择 看下一个问题，回到 1. 这是笔者六级考试时采用的 长篇阅读做题方法，不需要细致地通读全文。\n主观题\r作文\r一般是议论文或者应用文，想偷懒可以吃高中老本，也可以学习各种资料上的范文。\n翻译\r只能靠平时积累；一个技巧是，如果不确定某种译法是否正确，不要硬生生地把中文直译为英文，可以把中文词汇的意思用英文表达出来。\n例如，忘记「时钟」的说法，你可以翻译为 the thing to show time（\n学习渠道推荐\r个人体会，上手就做真题，不需要做模拟题。\n以 4-6 套/年（2-3 套/次）的出题速度，真题数量已经足够你找手感、研究了。况且模拟题质量参差不齐，既然有权威优质的真题资源，何必忍受模棱两可的答案呢？若你是大一下及之后参加考试，那么因为学业任务沉重，不可能花太多时间来刷题，就更应该选择真题。\n笔者用的是「四六级黄皮书」，体验极好，列举一些优点：\n真题数量多 答案分册，方便批改，而且有详解 附赠听力音频 完全按照官方试题册进行排版印刷。黄皮书上的一套试题就是一本试题册，和官方的排版一致，可以让你提前适应考试风格。 市面上还有不少大品牌出版的资料，你还可以多搜搜，货比三家，看看别人对它们的评价再做决定。\n此外，有学院也会在考前一周组织免费的四六级模拟考，届时可报名；最大的作用是适应考试的时间安排。试题一般就是从往年真题里选一套。\n考试用处\r四级成绩在 425 分及以上者才能报考六级。所谓「低分飘过四级」指的是分数在 425 上一点点，并不是「及格」的意思（再次重复，四级其实没有「及格线」一说）。 转专业。不同专业转入要求的四级分数不同，也有不要求的专业。具体可查查各学院的转专业要求。 免听英语课。四、六级分数达到一定分数线者，可申请免听英语课，细节请参考当年的教学秘书通知。 督促你学英语。这不是一句套话——大学的课外自学资料，有相当一部分是英文版。 …4 目前（2024 年），哈工深毕业并不需要四六级。但是，毕业不需要 ≠ 不用考四级 ≠ 不用学英语！\n后记\r写这篇「指北」的动机，是在 23 级自救群的见闻。无论是报名开始时学长「不要报四级口语」的怒吼（？）、不少人报完口试才知道可以不报的感叹，还是考前不久有人才知道四级做题是强制顺序，都让我感受到信息的封闭。\n诚然，四级官网上有详细介绍，但一来这些网页较为分散，难以整合信息，二来对没考过的大一新生而言，仅凭 不知道多久才更新一次的 官网信息，想「居高临下」地一览四级考试全貌，并不容易。因此萌生了「写一份四级备考指北」的想法。\n这篇指北面向新生群体，目的是让大一新生对四级考试的全流程（包括备考过程）有一个比较清晰的了解，减轻未知带来的焦虑和迷茫；而不是介绍四级刷高分的技巧。按照笔者的理解，无论什么考试，要想拿到超出常人的高分，大量刷题是必不可少的；这已经超出了本文的写作意图——毕竟对大部分人而言，四、六级并不是极其重要的考试。\n本指北中，相当一部分资料其实是引用或者参考自四级官网，感兴趣的同学可自行探索： https://cet.neea.edu.cn/ 和 https://cet-bm.neea.edu.cn/\n官网的原话是\n四级考试的常模群体选自全国 16 所高校的约三万名非英语专业的考生，六级考试的常模群体选自全国五所重点大学的约五千名非英语专业的考生。\n但也只说到这，没有给出更多信息。 ↩︎\n试题册，顾名思义，就是一本薄薄的装订好的小册子，跟高考试卷那种一张长卷子不一样。 ↩︎\n答题卡 1：作文和听力共用的答题卡； 答题卡 2：阅读和翻译共用的答题卡 ↩︎\n一些学校的保研夏令营会有入营的六级分数门槛，但笔者目前并没有得到确切的信息和学校名单，因此不放在正文中，也不过多解释。 ↩︎"},"title":"四、六级备考指北"},"/blog/contribution-guide/edit-multi-docs-and-upload-files/":{"data":{"":"","git-本地编辑#Git 本地编辑":"我们介绍的正规方法需要一些 Git 基础，这是 GitHub 界面功能不足导致的。\n如果你没有 Git 相关知识，可以查看 HITSZ 开源技术协会同学编写的 Git 教程。\nGit 本地编辑\rgit clone\r首先将仓库 Fork 到自己名下， 然后进入自己的仓库，找到仓库链接、复制下来， 在命令行运行 git clone \u003c你刚刚复制的仓库链接\u003e 这样，仓库就已经成为你的本地文件；在本地，你就可以随心所欲地进行各种修改，包括文档修改和文件上传。\n还记得本地的概念吗？本地文件指的是你存在自己电脑上、想要提交到我们的仓库里的文件。\ncommit \u0026 push\r确认所有改进都完成后，我们就可以把本地文件推送到远程仓库了；这时候，远程仓库还是你自己的，而非 HOA 的。（从自己的远程仓库，通过Pull Request，才能把内容推送到 HOA 的远程仓库）\n在命令行中，逐行执行以下命令：\ngit add . # 将当前目录下所有修改部分提交至暂存区 git commit -m \"commit message\" # 提交 commit message，需要遵守公约 git push # 将本地修改同步到远端仓库\rℹ️\r如果在 push 时遇到以\"fatal: unable to access\"开头的错误，例如：\nfatal: unable to access 'https://github.com/\u003cusername\u003e/AUTO3005.git/': OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443\r可能是因为你的网络环境无法访问 Github，可以尝试使用 VPN 或者参考 《新人指南：不使用第三方工具访问 GitHub》 中修改 Host 文件的方法。\n发起 Pull Request\r参考 单文档的情况 即可。"},"title":"2. 多文档修改和多文件夹上传文件"},"/blog/contribution-guide/edit-single-file-and-upload-file/":{"data":{"":"","公约#公约":"单文档修改：以课程文档为例\r对课程文档进行修改应该是单文档修改的主要情况。HITSZ OpenAuto 的课程文档大致可分为以下几部分，如果你发现其中任一项有缺失/与实际情况不符，或是你有自己的理解与体会，都可以增补。\n课程名 课程性质：必修/限选/选修；考试课/考查课；学分/学时；成绩构成 教材与参考书 授课教师及授课风格 授课内容/课程建议/备考策略 从整体上看，修改文档可以分为两步：\n在分支仓库修改文档\r我们的课程文档界面实际上已经做好了入口， 由于只有 HOA 团队成员具有直接写入权限，因此贡献者一般需要先创建分支仓库（Fork）。点击按钮，创建仓库在自己账号下的分支（fork）， 就可以在 GitHub 的网页编辑器修改内容，如下图所示： 图示：\n编辑器，使用 Markdown 语言进行写作。\n预览 Markdown 渲染效果。注意，HOA 使用的渲染器和此渲染器不同，预览效果仅供参考。\n修改此文件路径。用 .. 表示跳到上一级文件夹。一般不需要修改。\n提交你的修改。关于 commit message 的填写，详见下文公约。\n发起 Pull Request\rPull Request 是指把你的仓库里新的内容合并进我们已过时的仓库内容的过程。\n点击按钮，GitHub 会要求你填写 PR 的描述。我们给这份描述添加了一些指引，因此只需要按照指引填写即可。 ℹ️\r如果有疑问，可以先看看 单文件夹上传文件 的教程，因为这两者的流程是一致的\r单文件夹上传文件\rGitHub 提供的功能实际上支持多文件上传，但这些文件必须上传到同一个目标文件夹，因此称为「单文件夹上传」。\n使用场景如：上传某课程试卷和/或其答案，同属 exams 文件夹\n手动 Fork 仓库\r由于我们的仓库设置了文件上传保护，需要手动创建自己的仓库分支。 在自己的仓库上传文件\r在自己的仓库总页面，点击你想上传的文件夹，然后点如图按钮；在上传界面拖拽文件即可。这一步支持多文件上传。 ℹ️\r注意，请确保所上传的文件不是 公约 中所述「不宜上传文件」；填写 commit message 仍然需要遵守公约。\r发起 Pull Request\r再次回到自己的仓库，主界面会发现显眼的标注 然后就是和上文一样的流程。\n公约\r修改文档或上传文件需要遵守以下公约：\n不要随意删除/修改他人的评价、建议\n在提出某项意见/评价时请按格式署名（不一定要真实姓名）、标注时间，放在你所修改部分的最末尾。例如：\n\u003e 文 / [IcyDesert](https://github.com/IcyDesert), 2025.1\rcommit message 和 PR 的标题，不要只写「增加/修改/删除一些内容」，而要明确写清：「增加 xx 教师的信息及评价」、「更新课程大纲」、「增加课程建议」、「修改学分学时安排」等\n中文排版应按照 中文文案排版指北 的规范进行\n我们的初心是分享学习经验，坚决反对抄袭/盗版，以下是不宜上传的文件：\n盗版电子书，盗版软件以及一切和盗版有关的东西 未经老师同意上传的教学课件 不推荐上传与成绩考核相关的作业答案与实验代码，但鼓励上传作业中的难题思路和大实验的代码思路。 ","单文件夹上传文件#单文件夹上传文件":"","单文档修改以课程文档为例#单文档修改：以课程文档为例":""},"title":"1. 单文档修改和单文件夹上传文件"},"/blog/contribution-guide/prerequisites/":{"data":{"":"","本地和远程#\u003ccode\u003e本地\u003c/code\u003e和\u003ccode\u003e远程\u003c/code\u003e":"\r本系列文章重点介绍 Git 的实际操作方法，不深入探讨其底层原理和实现机制；如有学习需要请移步互联网，也可以查阅 HITSZ 开源技术协会同学编写的 Git 教程。\n稳定连接到 GitHub\r如果你已有合法访问国际互联网途径，或者能确保 GitHub 的稳定访问，可跳过。\n参见我们的博客 《新人指南：不使用第三方工具访问 GitHub》，任意一种方式均可。\n本地和远程\r一般来说，本地（local） 文件指的是你的电脑磁盘上的文件，而 远程（remote） 文件指的是存储在服务器上的数据文件。\n在 HOA 的语境下，本地文件指的是你保存在自己电脑上、想要提交到我们的远程仓库里的文件，而 远程仓库则是我们在 GitHub 上的 各个仓库。 所谓的贡献文件，实际上就是通过 GitHub 提供的方法将本地文件提交到远程仓库的过程。","稳定连接到-github#稳定连接到 GitHub":""},"title":"0. 预备知识"},"/blog/distributive-guidance-for-21/":{"data":{"":"","专业限选课#专业限选课":"","实践课程体系#实践课程体系":"","限选课选课建议#限选课选课建议":"自动化专业的培养方案中有三个模块的专业限选课以及“实践课程体系”，常常让人摸不着头脑。这里给大家来分析一下这些课的信息、以及给大家一些选课的建议。\n此为 21 级学生方案，22 级的指南见此处。\n点击蓝色的课程名即可跳转对应页面查看详情及下载资料。\n实践课程体系\r序号 开课学期 课程名称 学分 总学时 讲课 实验 1 大二上 C++ 语言程序设计 2.0 32 20 12 2 大二下 数据结构与算法 2.0 32 24 8 3 大三下 DSP 的原理与应用 3.0 48 30 18 以上 3 门课至少选择其中一门，即达到学分要求。\n（FPGA 设计与应用（2 学分）不开课）\n专业限选课\r首先，所有的限选课都是考查课。\n其次，限选课和必修课是一起选课，而不是和通识课一起选课。\n再次，限选课共有 3 个模块，分别是控制理论与控制工程模块、机器人与智能系统模块、智能检测模块。\n这 3 个模块里面选 1 个作为主选修，要修满 6 学分；选 1 个作为副选修，要修满 4 学分。下面分成几种情况讨论：\n（1）控制理论与控制工程模块\r序号 开课学期 课程名称 组内必修 or 选修？ 学分 总学时 讲课 实验 1 大三下 过程控制系统 必修（二选一） 3.0 48 36 12 2 大三下 数学规划 必修（二选一） 3.0 48 48 3 大四上 先进控制概论 选修 2.0 32 32 1° 若作为主选修模块：（至少达到 6 学分）\n前两门必须全选，否则达不到学分要求。第三门本来也是选修，所以如果只是要达到学分要求，那就可选可不选。\n2° 若作为副选修模块：（至少达到 4 学分）\n可以前两门全选，也可以前两门选一门，再选上选修。\n（2）机器人与智能系统模块\r序号 开课学期 课程名称 组内必修 or 选修？ 学分 总学时 讲课 实验 1 大三下 机器人学导论 必修 2.0 36 28 8 2 大四上 运动控制系统 选修 2.0 32 24 8 3 大四上 移动机器人导论 选修 2.0 32 24 8 4 大四上 机器学习概论 选修 2.0 32 32 1° 若作为主选修模块：（至少达到 6 学分）\n《机器人学导论》必选，后三门至少选两门。\n2° 若作为副选修模块：（至少达到 4 学分）\n《机器人学导论》必选，后三门至少选一门。\n（3）智能检测模块\r序号 开课学期 课程名称 组内必修 or 选修？ 学分 总学时 讲课 实验 1 大三上 数字图像处理 必修 2.0 32 24 8 2 大三下 机器视觉 选修 2.0 32 24 8 3 大四上 人工智能基础 选修 2.0 32 32 4 大四上 模式识别 选修 2.0 32 24 8 1° 若作为主选修模块：（至少达到 6 学分）\n《数字图像处理》必选，后三门至少选两门。\n2° 若作为副选修模块：（至少达到 4 学分）\n《数字图像处理》必选，后三门至少选一门。\n综上所述，一共有如下 6 种组合\r（1）主选修模块：控制理论与控制工程；副选修模块：机器人与智能系统\n序号开课学期课程名称组内必修 or 选修？学分总学时讲课实验\r1大三下过程控制系统必修3.0483612\r2大三下数学规划3.04848 \r3大三下机器人学导论2.036288\r4大四上先进控制概论可选可不选2.03232 \r5大四上运动控制系统选修至少一门2.032248\r6大四上移动机器人导论2.032248\r7大四上机器学习概论2.03232 \r（2）主选修模块：控制理论与控制工程；副选修模块：智能检测模块\n序号开课学期课程名称组内必修 or 选修？学分总学时讲课实验\r1大三下过程控制系统必修3.0483612\r2大三下数学规划3.04848 \r3大三上数字图像处理2.032248\r4大四上先进控制概论可选可不选2.03232 \r5大三下机器视觉选修至少一门2.032248\r6大四上人工智能基础2.03232 \r7大四上模式识别2.032248\r（3）主选修模块：机器人与智能系统；副选修模块：控制理论与控制工程\n序号开课学期课程名称组内必修 or 选修？学分总学时讲课实验\r1大三下机器人学导论必修2.036288\r2大三下过程控制系统必修（二选一）3.0483612\r3大三下数学规划3.04848 \r4大四上运动控制系统选修至少两门2.032248\r5大四上移动机器人导论2.032248\r6大四上机器学习概论2.03232 \r7大四上先进控制概论【注】 2.03232 \r【注】如果第 2、3 门课都选了，就不用选。否则就要选。\n（4）主选修模块：机器人与智能系统；副选修模块：智能检测模块\n序号开课学期课程名称组内必修 or 选修？学分总学时讲课实验\r1大三下机器人学导论必修2.036288\r2大三上数字图像处理必修2.032248\r3大三下运动控制系统选修至少两门2.032248\r4大四上移动机器人导论2.032248\r5大四上机器学习概论2.03232 \r6大三下机器视觉选修至少一门2.032248\r7大四上人工智能基础2.03232 \r8大四上模式识别2.032248\r（5）主选修模块：智能检测模块；副选修模块：控制理论与控制工程\n序号开课学期课程名称组内必修 or 选修？学分总学时讲课实验\r1大三上数字图像处理必修2.032248\r2大三下过程控制系统必修（二选一）3.0483612\r3大三下数学规划3.04848 \r4大三下机器视觉选修至少两门2.032248\r5大四上人工智能基础2.03232 \r6大四上模式识别2.032248\r7大四上先进控制概论【注】 2.03232 \r【注】如果第 2、3 门课都选了，就不用选。否则就要选。\r（6）主选修模块：智能检测模块；副选修模块：机器人与智能系统\n序号开课学期课程名称组内必修 or 选修？学分总学时讲课实验\r1大三上数字图像处理必修2.032248\r2大三下机器人学导论必修2.036288\r3大三下机器视觉选修至少两门2.032248\r4大四上人工智能基础2.03232 \r5大四上模式识别2.032248\r6大四上运动控制系统选修至少一门2.032248\r7大四上移动机器人导论2.032248\r8大四上机器学习概论2.03232 \r限选课选课建议\r（欢迎学长学姐补充）\n据学长介绍，最多人选和大四课最少的方案是：\n【主选修模块：控制理论与控制工程；副选修模块：智能检测模块】\n序号开课学期课程名称组内必修 or 选修？学分总学时讲课实验\r1大三下过程控制系统必修3.0483612\r2大三下数学规划3.04848 \r3大三上数字图像处理2.032248\r4大三下机器视觉选修2.032248\r按此选课策略，可以修满控制理论与控制工程模块的 6 学分和智能检测模块的 4 学分而达标。"},"title":"21 级自动化学生限选课选课说明及选课建议"},"/blog/distributive-guidance-for-22/":{"data":{"":"","基础选修课#基础选修课":"","拓展选修课#拓展选修课":"","限选课选课建议#限选课选课建议":"根据新鲜出炉的培养方案，22 级自动化学生需要选择“基础选修课”和“拓展选修课”。这里给大家来分析一下这些课的信息、以及给大家一些选课的建议。\n此为 22 级学生方案，21 级的指南见此处。\n培养方案每年都在更新，因此欢迎学弟学妹参与贡献！\n首先明确，所有的限选课都是考查课。其次，限选课和必修课是一起选课，而不是和通识课一起选课，所以不要忘了选课！\n基础选修课\r（点击蓝色的课程名即可跳转对应页面查看详情及下载资料）\n序号 开课学期 课程名称 学分 总学时 讲课 实验 1 大三上 数学规划与数值优化 2.0 32 32 2 大三上 数字图像处理 2.0 32 24 8 3 大三上 模式识别 2.0 32 24 8 4 大三下 过程控制系统 2.0 32 20 12 5 大三下 机器人学导论 2.0 36 28 8 6 大三下 运动控制系统 2.0 32 24 8 7 大四上 凸优化与最优控制 2.0 32 32 以上 7 门课至少选择其中 2 门，即达到学分要求。\n拓展选修课\r（点击蓝色的课程名即可跳转对应页面查看详情及下载资料）\n序号 开课学期 课程名称 学分 总学时 讲课 实验 1 大二上 C++ 语言程序设计 2.0 32 20 12 2 大二下 数据结构与算法 2.0 32 24 8 3 大三上 机器学习概论 2.0 32 32 4 大三上 嵌入式系统 2.0 32 20 12 5 大三下 机器视觉 2.0 32 24 8 6 大四上 人工智能基础 2.0 32 32 7 大四上 移动机器人导论 2.0 32 24 8 8 大四上 信息论 2.0 32 32 9 大四上 脑机接口导论 2.0 32 24 8 10 大四上 类脑智能技术 2.0 32 32 11 大四上 先进控制概论 2.0 32 32 以上 11 门课至少选择其中 1 门，即达到学分要求。\n限选课选课建议\r（欢迎补充）\n毕业的最低学分要求降低了，减轻了学生的负担，是好事；同时课程总量更加丰富，给有提升自己的需求的同学更广的选择余地。\n建议大家根据自身学习能力妥善选课。（能力强的同学可以选一些目前没有资料的课程，建设课程资料）"},"title":"22 级自动化学生限选课选课说明及选课建议"},"/blog/graduate-school-application-experience-sharing-jjz01/":{"data":{"":"","#":"子夜，风起，无眠，遂写一篇推免笔记。\n本人背景\r哈工大深圳 19 级自动化专业，绩点 rank3 /196，预推免综测 rank1/196，竞赛有数模国一队长，国家奖学金，若干课程项目，有弱科研经历但无论文发表，若干其他奖项，英语六级 536，口语水平刚好够在面试中表达。由于哈工大控制为 A+ 学科 (三所控制 a+ 的学校为：清华，哈工大，浙大)，我的排名在专业里也很靠前，有一项强竞赛，背景和纸面实力相对较硬，因此在夏令营和预推免中能百分百入营。\n夏令营情况\r七月初，清华大学深圳国际研究生院信息学部人工智能项目夏令营。入营难度：卡 985 前 5％，需要提前联系老师。根据我的了解，我们专业入营的同学都联系了老师，有排名更靠前的同学没联系老师且没能入营。清深该夏令营前后一共四到五天，强度较高，分初试和复试。随着报名的实验室不同，参加的初试内容不同，具体实验室和初试内容不便透露。通过初试后，可以参加复试。复试形式为 5 分钟场外英文文献阅读翻译和 15 分钟面试 (仍然含英面）。夏令营复试结束一周左右出录取结果和优营名单。无论是入营还是录取，清深的导师都有很大的决定权，所以一定要提前联系。由于我报名联系的老师课题组今年需要机械方向学生，背景原因遗憾错过清深。\n七月初，上海交通大学电子信息与电气工程学院自动化系优秀生源夏令营。入营难度：从群发的邮件来看，都是中上游 985 学生，不乏大量上交本校生和其他华东五校学生。夏令营相对轻松，为时一共一天，上午为笔试，下午为面试。笔试有数学，专业知识和编程，具体内容不便透露。面试为 15 分钟，据我了解，面试内容随着面试小组不同而大相径庭，感觉交大在这方面做的很不好。面试和笔试各自 100 分，总分 200 分，按照排名择优录取。值得一提的是交大电院七月中上旬就开了夏令营，八月底才出录取结果，很是让人煎熬。更值得一提的是上交往年被鸽的很惨，今年也是。所以夏令营排名不理想也不用担心，后续也有可能可以录取。自动化系的录取名额大概为学硕 25 人，专硕 40 人，直博不详，本人最终拿到了控制学硕预录取。\n八月初，浙江大学控制科学与工程学院“控制之旅”学术夏令营。浙大控院夏令营分不同的研究所和下属不同的项目组，入营与否由你报名的项目组决定。入营后需要跟随项目组做项目和项目完成情况考察，考察形式可能是 ppt 答辩，研究报告等等，每个项目组都不同。夏令营的组织结构为控制学院 - 研究所 - 项目组，每个研究所都有优秀营员和特优营员的名额，优秀营员根据你的项目完成情况来考评分配，优秀营员可以参与复试环节，竞争特优营员的名额。夏令营的特优营员即为预录取。夏令营的优秀营员将获得直接进入预推免复试的资格。本人在夏令营中获得优秀营员。\n浙大无论是夏令营还是预推免，如果报名直博，英语六级需要达到 480 分。在预推免报名后，本人收到了上海交大录取的通知，因此存在一些获取了复试资格但是没有参加的情况。也是及时让出复试机会，给更需要的同学。\n预推免情况\r浙大控院预推免，控院预推免也是分研究所进行，外校推免生和浙大本校生共同参加复试，根据复试排名择优录取，对于学硕专硕问题，根据我的观察，外校生也有很大机会拿到学硕。由于夏令营中项目表现较好，老师对我比较满意，本人拿到老师的直博录取接受函，收获直博录取，我也锚定浙大。\n上交密院，清深人工智能，自动化所 均获取复试资格，均未参加。\n干货补充\r清华本部，自动化所，由于本人实力限制或者个人偏好问题，夏令营和预推免均未参加，想要了解可以查阅 @惊澜的笔记。\n推免四板斧：学校及学科背景，绩点，科研，竞赛。本人的遗憾是没有较强的科研经历，如果有，或许会比现在的结果更好。\n干货还有一点补充，部分学校或者老师可能存在提前邀请你做项目或者提前面试的情况，做项目耗时耗力，还得仔细权衡。面试尽量参加，可以作为面试的锻炼，或许可以拿到口头 offer。浙大部分强组由于竞争太过激烈，就出现了提前私下组织一轮面试筛选学生的情况。\n私货\r江苏人，希望回江浙沪读书，所以在同层次的院所中只考虑了交大和浙大。不得不提文理学院南京大学，其实我也报了南大的人工智能学院开放日夏令营，但是这似乎是为计算机科班同学准备的，存在大量的算法和数据结构题，我也是在没有准备的情况下笔试中狼狈被刷。我高中的好兄弟南大保送本校 lamda 实验室直博，我很羡慕。\n浙大老师 (也就是我最终的导师）问我手上还有别的 offer 吗，如果同时录取了是否会选择浙大，我并没有隐瞒有上交的 offer，并表示更偏爱浙大。他说我有 offer 保底他就放心了，希望我们学生不要把鸡蛋放到同一个篮子里。疫情时代线上推免，海王泛滥，承诺包票有时只是一纸戏言。老师既想要录取我，又为我有别的 offer 保底而感到放心，让我深为感动。关于鸽上交的问题，上交发 offer 存在录取和候补两种情况，本人放弃了录取会有后面的同学补上来。\n希望大家能一个萝卜一个坑，有保底的话尽量及时退场，善待他人。保研如是，人生亦然。待人真诚，方得始终。我的推免周期拉的比较长，一路上有许多校内校外的老师，学长学姐的无私帮助，向你们致意！\n保研只是一个新的开始。告别过这段懵懂而忙碌的岁月，无论选择何种道路，我们都要成为更好的自己。\n转载自：22 年自动化推免笔记 (清浙交) - JJz01 的文章 - 知乎 https://zhuanlan.zhihu.com/p/574594361\n已获得作者本人许可"},"title":"22 年自动化推免笔记 (清浙交)"},"/blog/guide-for-developer/backend/":{"data":{"":"","基本介绍#🏠基本介绍":"","生成课程文档#📄生成课程文档":"\rWarning\n本文将主要涉及 Python 脚本的编写，可能需要一定的 Python 基础知识。\n我们的网站后端主要是围绕与 GitHub API 的交互，涉及很多网络请求，为减少运行时间开销，脚本内使用了很多异步编程。\n异步编程是一种编程模式，用于处理可能会花费较长时间的操作，而不会阻塞其他代码的执行。\n我们会以当前最重要的 scripts/build_course_pages.py 为例，逐步理清整个脚本到底做了些什么工作。\n🏠基本介绍\r在确定前端框架后，我们需要着手解决内容迁移的问题。如果采用手动方式将各个文档逐一复制，不仅工作量巨大，也不便于后期扩展。因此，我们计划开发自动化脚本，用于获取当前所有公开课程仓库的内容，包括分散在各仓库中的 README 文档以及已上传的资料元信息。同时，我们将借助 GitHub Action 实现定期检测：按照设定的时间间隔自动查询各课程仓库的更新状态，并据此判断是否需要重新构建内容。\n在项目初期，由于课程仓库和网站功能相对简单，我们采用了直接在 workflow yaml 文件中编写 shell 脚本的方式。随着项目规模的扩大，脚本的复杂度也随之提升。这促使我们进行了一系列优化：首先，将部分难以用 shell 实现的功能提取出来，改用更易维护的 Python 脚本；其次，为了解决因网络请求增多导致的执行时间过长问题，我们在最近的一次大规模更新中将同步处理改为了异步处理；最后，为提升代码的可维护性，我们把原本集成在 yaml 文件中的所有 shell 脚本都独立出来，统一存放在 scripts 文件夹下。\n. ├── __init__.py ├── about │ ├── __init__.py │ └── update_about.py ├── courses │ ├── __init__.py │ ├── build_course_pages.py │ ├── fetch_opened_prs_and_issues.py │ ├── gen_links.py │ ├── gen_repo_update_time.py │ └── wrap_badges.py ├── filetrees │ ├── __init__.py │ ├── filetree_manager.py │ └── filetrees.json ├── infos │ ├── netdisk_notice.txt │ ├── notice.txt │ └── sponsor.txt ├── news │ ├── __init__.py │ ├── gen_image.py │ └── gen_news.py ├── requirements.txt └── workflows ├── build_course_pages.sh ├── build_directory_pages.sh ├── build_semester_pages.sh ├── build_single_course_page.sh ├── check_before_build_single_course_page.sh └── fetch_repos.sh\r📄生成课程文档\rbuild_course_pages.py 整个脚本的主要目的便是从 GitHub 课程仓库获取课程信息，并生成课程页面。在 course.yaml 中，我们可以看到脚本是通过如下方式被调用的：\njobs: build-documentation: runs-on: ubuntu-22.04 permissions: contents: write id-token: write env: PYTHONPATH: /home/runner/work/hoa-moe/hoa-moe steps: - name: Setup Python uses: actions/setup-python@v5 with: python-version: \"3.11\" - name: Install Python dependencies run: | python -m pip install --upgrade pip pip install -r scripts/requirements.txt # 获取 OpenAuto 组织下仓库名等步骤已省去，具体内容可自行查看 .github/workflow/course.yaml - name: Build course pages run: python scripts/courses/build_course_pages.py \"HITSZ-OpenAuto\" ${{ secrets.PERSONAL_ACCESS_TOKEN }}\rWarning\n注意，此处出现代码为方便理解在部分地方做了修改。\n既已知道脚本的调用方式，我们便可以先从脚本的 main 函数入手：\nif __name__ == \"__main__\": # 1. 设置命令行参数 # 命令行内使用 python scripts/courses/build_course_pages.py HITSZ-OpenAuto token 调用 parser = ArgumentParser(description=\"Generate course pages from GitHub repositories.\") parser.add_argument(\"owner\", help=\"GitHub repository owner\", default=\"HITSZ-OpenAuto\") parser.add_argument(\"token\", help=\"GitHub token\") # 2. 从环境变量获取仓库列表 # 查看 course.yaml 可以发现，在之前步骤中已经把可用仓库名设置成了 repos_array 的环境变量 repos_json = os.environ.get(\"repos_array\") repos = json.loads(repos_json) if repos_json else [] # 3. 记录执行时间并运行主要处理函数 # 进入下一个函数 -\u003e process_multiple_repos start_time = time.perf_counter() asyncio.run(process_multiple_repos(args.owner, repos, args.token)) end_time = time.perf_counter() execution_time = end_time - start_time\r大部分代码还是很好理解的，下面让我们进入 process_multiple_repos 函数看看吧。\nprocess_multiple_repos\rasync def process_multiple_repos(owner: str, repos: list, token: str) -\u003e None: # 1. 过滤掉特定仓库（.github, hoa-moe, HITSZ-OpenAuto） repos = [repo for repo in repos if repo not in [\".github\", \"hoa-moe\", \"HITSZ-OpenAuto\"]] sorted_repos = sorted(repos) # 排序，用于在并行的情况下保证构建网页时的顺序 # 2. 为每个仓库创建一个 GitHubAPIClient 实例 # 只需要知道这个类主要是用来和 GitHub 网络通信拿取有关信息就行 clients = [GitHubAPIClient(owner, repo, token, index) for index, repo in enumerate(sorted_repos)] tasks: list[asyncio.Task] = [] # 3. 使用异步方式并行处理所有仓库 # 为每个仓库都单独创建一个执行 process_repo 函数的 task，每个 task 可以同时执行（只消耗一份时间） for client in clients: await client.init_session() task = asyncio.create_task(process_repo(client)) tasks.append(task) await asyncio.gather(*tasks) # 等待所有 task 执行完毕 # 4. 最后更新学期类别文件并关闭所有会话 for client in clients: client.update_semester_category_file() # 最后执行更新学期类别文件，以固定构建网页时的顺序 await client.close_session()\r本函数的作用便是把各个仓库的主要执行函数分成能异步执行的一个个 task，节约时间开销。现在让我们看看整个脚本的最重要任务 process_repo 在干嘛吧。\nprocess_repo\rasync def process_repo(client: GitHubAPIClient) -\u003e None: # 1. 读取仓库中的 tag.txt 文件获取课程信息（类别、学期、课程名等） tag_content: str = await client.fetch_file_content(\"tag.txt\") # 2. 根据学期和类别信息创建或更新相应的分类文件 category_match = re.search(r\"category:\\s*(.*)\", tag_content) if category_match: category_raw = category_match.group(1) category, extra_info = category_mapping.get(category_raw.strip()) log += f\"Matched category: {category}\\n\" semesters_match = re.search(r\"semester:\\s*(.*)\", tag_content) # ... name_match = re.search(r\"name:\\s*(.*)\", tag_content) # ... # 一个课程可能会有多个学期 for semester in semesters: # 3. 获取 README.md 的内容 readme_content: str = await client.fetch_file_content(\"README.md\") # 4. 生成包含课程信息、更新时间、README 内容等的完整课程页面 s: str = \"\" s += \"---\\n\" s += f\"title: {course_name}\\n\" s += ( \"toc: true\\n\" + f'editURL: \"https://github.com/{client.owner}/{client.repo}/edit/main/README.md\"\\n' + \"math: true\\n\" + \"---\\n\\n\" ) s += readme_content + \"\\n\" # 5. 添加资料下载、网盘提示和赞助信息 s += \"## 资料下载\\n\\n\" with open(\"scripts/infos/netdisk_notice.txt\", \"r\", encoding=\"utf-8\") as notice_file: s += notice_file.read() + \"\\n\" with open(f\"{client.repo}_cards.txt\", \"r\", encoding=\"utf-8\") as cards_file: s += cards_file.read() + \"\\n\" with open(\"scripts/infos/sponsor.txt\", \"r\", encoding=\"utf-8\") as sponsor_file: s += sponsor_file.read() + \"\\n\" # 6. 将生成的界面内容写入对应路径下的 Markdown 文档 repo_md_filename = f\"./content/docs/{semester_en}/{client.repo}.md\" with open(repo_md_filename, \"w\", encoding=\"utf-8\") as f: f.write(s)\r你可以打开一个我们课程的 Markdown 文档的源码比对着看，相信你很快就能知道文档的各部分是怎么来的了。"},"title":"后端架构概览"},"/blog/guide-for-developer/frontend/":{"data":{"":"","hugo-前端框架#📐Hugo 前端框架":"","基础架构介绍#🏠基础架构介绍":"","如何在本地调试前端界面#🐛如何在本地调试前端界面":"\rWarning\n如果你尚且不清楚什么是 HTML、CSS 和 JS，可以在 MDN 官网 学习 / 询问 AI 后再来看此篇文章。\n本文将从前端角度介绍 HOA 的基础架构，包括：\n基础架构介绍 如何在本地调试前端界面 tree -L 1 . # hoa-moe 文件树 . ├── archetypes ├── assets # 包含自定义的 CSS 样式、JS 脚本 ├── content # 存放 md 文件，Hugo 能自动将其中的 markdown 文件转化成相应 HTML 网页 ├── i18n # 语言相关配置 ├── layouts # 包含自定义的 HTML 框架 ├── public # Hugo 最终构建出的产物（即网站本体），一般不需要做任何改动，也不会被同步到 GitHub 远端仓库中 ├── scripts # 存放 HOA 后端脚本文件 ├── static # 存放网站相关静态文件，如 Logo、缩略图等 ├── themes # Hugo 主题模块文件夹 └── hugo.yaml # 网站基础配置文件\r🏠基础架构介绍\r前端前端，「三大件」总是少不了。先来回顾一下包含 CSS 和 JS 的最小化前端 HTML 是什么样的吧：\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"zh\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e最小化 HTML\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"styles.css\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e \u003ch1\u003eH1 标题\u003c/h1\u003e \u003cp id=\"message\"\u003eP 段落\u003c/p\u003e \u003c/div\u003e \u003cscript src=\"script.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e\r本项目的架构源于最基础的 HTML 结构，通过模块化扩展而成。虽然项目中仍然保留了传统 HTML 的核心元素 (如 \u003chead\u003e、\u003cbody\u003e 标签) 以及 CSS 和 JavaScript 的引入机制，但我们采用了组件化的管理方式，将这些元素拆分为独立的模块，最终再组装成完整的页面。具体拆分方式例子如下：\n头部标签 \u003chead\u003e 被抽取为 layouts/partials/head.html 组件，通过 {{- partial \"head.html\" . -}} 引入 样式表引用 \u003clink rel=\"stylesheet\"\u003e 被抽取为 layouts/partials/head-css.html 组件，通过 {{- partialCached \"head-css.html\" . -}} 引入 脚本引用 \u003cscript\u003e 被抽取为 layouts/partials/scripts.html 组件，通过 {{- partial \"scripts.html\" . -}} 引入 我们可以从源码中发现，网页内只导入了 css/compiled/main.css 和 css/custom.css 两份 CSS 文件，如果你直接在 CSS 对应文件夹下新增一份 .css ，写入新 CSS 文件的样式是不会被渲染到网页上的。同理，你也可以看到有哪些 JS 脚本被引入了我们网页。\n{{- $scripts := slice $jsTheme $jsMenu $jsCodeCopy $jsTabs $jsLang $jsFileTree $jsSidebar $jsBackToTop | resources.Concat \"js/main.js\" -}} \u003cscript defer src=\"{{ $scripts.RelPermalink }}\" integrity=\"{{ $scripts.Data.Integrity }}\"\u003e\u003c/script\u003e\r关于 CSS 相关文件和 {{- -}} 类语法我们会在后续章节中继续讨论。\n📐Hugo 前端框架\rNote\n本部分内容聚焦于如何编写 Hugo 博客主题，而非实现一个类似 Hugo 的博客框架。\n我们这里主要讨论 layouts, contents 与 assets 几个文件夹。\n原模板样式与自定义样式\r在项目根目录外，我们可以在 themes 里的主题文件夹内找到很多同名文件夹，例如 layouts 与 themes/hextra/layouts，assets 与 themes/hextra/assets，这就不得不提及 Hugo 框架的特性了。\nHugo 在渲染 Markdown 文件时遵循特定的文件查找优先级：首先在项目根目录下查找同名文件，若未找到，则使用主题内的相应文件。利用这一机制，我们可以通过在根目录下创建与主题目录内相同路径和名称的文件来覆盖原有内容。这种方法使得 themes 可以作为 submodule 保持，而在需要修改样式时，只需将目标样式文件复制到项目根目录，并在根目录下的新文件中进行定制化修改。\n从 Markdown 到 HTML 网页\r比对 contents 和 layouts 下的文件树目录，可以发现有很多相似之处，那么，Hugo 是怎么让 Markdown 套用我们编写的模板从而渲染成网页的呢？\n├── _default │ ├── _markup │ │ ├── render-blockquote-alert.html │ │ ├── render-blockquote-regular.html │ │ ├── render-codeblock-mermaid.html │ │ ├── render-codeblock.html │ │ ├── render-heading.html │ │ ├── render-image.html │ │ └── render-link.html │ ├── baseof.html │ ├── list.html │ ├── list.rss.xml │ ├── single.html │ └── wide.html ├── blog │ ├── list.html │ └── single.html ├── docs │ ├── list.html │ └── single.html\rblog 和 docs 文件夹下的 list.html 与 single.html 分别对应我们「博客」和「文档」版块内的「列表页面模板」与「单页面模板」；_default/list.html 与 _default/single.html 则对应那些并没有在 layouts 下单独设立文件夹的页面，如 content/faq 及 content/sponsor 页面。此外，_default/_markup 这部分内容则是针对 Markdown 内的像 blockquote、codeblock 等具体内容的渲染模板。\n总之，Markdown 总是需要能够在 layouts 下找到对应模板文件进行渲染，对应模板文件内也可以访问到 md 文件内的 head info 从而为自己所用。\n如果你想更进一步了解，推荐访问 Hugo 官方 template 文档 进行学习。\nHugo 短代码的使用\rHugo 的短代码（Shortcodes）是一种强大的模板机制，允许我们在 Markdown 和 HTML 内容中嵌入动态渲染的代码片段。但同时，它有着非常严格的语法要求，多一个少一个空格都不行：\nMarkdown 中使用 {{\u003c/* shortcode */\u003e}} 的形式，调用 layouts/shortcodes 内的模板 HTML 中使用 {{- shortcode -}} 的形式，引入 Hugo 相关语法 我们以一段 HTML 代码（themes/hextra/layouts/partials/scripts.html）为例子做简要语法解释：\n{{- $jsFileTree := resources.Get \"js/filetree.js\" -}} {{- $jsSidebar := resources.Get \"js/sidebar.js\" -}} {{- $jsBackToTop := resources.Get \"js/back-to-top.js\" -}} {{- $scripts := slice $jsTheme $jsMenu $jsCodeCopy $jsTabs $jsLang $jsFileTree $jsSidebar $jsBackToTop | resources.Concat \"js/main.js\" -}} {{- if hugo.IsProduction -}} {{- $scripts = $scripts | minify | fingerprint -}} {{- end -}} \u003cscript defer src=\"{{ $scripts.RelPermalink }}\" integrity=\"{{ $scripts.Data.Integrity }}\"\u003e\u003c/script\u003e {{/* Search */}} {{- if (site.Params.search.enable | default true) -}} {{- $searchType := site.Params.search.type | default \"flexsearch\" -}} {{- if eq $searchType \"flexsearch\" -}} {{- $jsSearchScript := printf \"%s.search.js\" .Language.Lang -}} {{- $jsSearch := resources.Get \"js/flexsearch.js\" | resources.ExecuteAsTemplate $jsSearchScript . -}} {{- if hugo.IsProduction -}} {{- $jsSearch = $jsSearch | minify | fingerprint -}} {{- end -}} {{- $flexSearchJS := resources.Get \"lib/flexsearch/flexsearch.bundle.min.js\" | fingerprint -}} \u003cscript defer src=\"{{ $flexSearchJS.RelPermalink }}\" integrity=\"{{ $flexSearchJS.Data.Integrity }}\"\u003e\u003c/script\u003e \u003cscript defer src=\"{{ $jsSearch.RelPermalink }}\" integrity=\"{{ $jsSearch.Data.Integrity }}\"\u003e\u003c/script\u003e {{- else -}} {{- warnf `search type \"%s\" is not supported` $searchType -}} {{- end -}} {{- end -}}\r前三句比较容易看懂，为变量赋值嘛；再下一句提示了我们该如何使用变量——$。\n{{- $jsFileTree := resources.Get \"js/filetree.js\" -}} {{- $jsSidebar := resources.Get \"js/sidebar.js\" -}} {{- $jsBackToTop := resources.Get \"js/back-to-top.js\" -}} {{- $scripts := slice $jsTheme $jsMenu $jsCodeCopy $jsTabs $jsLang $jsFileTree $jsSidebar $jsBackToTop | resources.Concat \"js/main.js\" -}}\r再接着跟着 if 条件判断和 HTML 语句——如果 Hugo 工作在生产环境，则将所有 JS 脚本最小化哈希化，最后导入 HTML 中：\n{{- if hugo.IsProduction -}} {{- $scripts = $scripts | minify | fingerprint -}} {{- end -}} \u003cscript defer src=\"{{ $scripts.RelPermalink }}\" integrity=\"{{ $scripts.Data.Integrity }}\"\u003e\u003c/script\u003e\r再往后基本是以上语法的重复利用，不过需要注意的一点是变量 site.Params.search.type 来自 hugo.yaml:\nparams: # Search # flexsearch is enabled by default search: enable: true type: flexsearch flexsearch: # index page by: content | summary | heading | title index: content # full | forward | reverse | strict # https://github.com/nextapps-de/flexsearch/#tokenizer-prefix-search tokenize: forward\r其它一些变量后缀这里就不做具体讲解了，想要了解的可以自行 Google 查阅官方文档。\n我自己之前也写过一篇关于 Hugo 短代码的博客，放在这里：Hugo ShortCode | 丰富你的 Markdown\n🐛如何在本地调试前端界面\r克隆本仓库代码后，在本地仓库根目录下运行 hugo server，你便可以从命令行获得调试时所需的端口号，浏览器内打开即可：\nWarning\n由于 Hextra 主题使用 TailwindCSS，但在配置上有部分错误，我们需要手动做些调整才能将新的 Tailwind 样式渲染至页面。\n更改 themes/hextra/tailwind.config.js module.exports = { prefix: 'hx-', // 由于存在这么一行，所有 TailwindCSS 类都需要在原基础上加上 'hx-' 前缀 content: [ './**/hugo_stats.json', '../../layouts/**/*.{html, js}' // 新增这一行 ], ... }\r更改 themes/hextra/package.json { \"scripts\": { \"dev:theme\": \"hugo server --logLevel=debug --config=hugo.yaml,../dev.toml --environment=theme --source=exampleSite --themesDir=../.. --disableFastRender -D --port 1313\", \"dev\": \"hugo server --source=exampleSite --themesDir=../.. --disableFastRender -D --port 1313\", \"build:css\": \"npx postcss --config postcss.config.js --env production assets/css/styles.css -o assets/css/compiled/main.css\", \"build\": \"hugo --gc --minify --themesDir=../.. --source=exampleSite\", \"watch\": \"npx postcss --config postcss.config.js --env production assets/css/styles.css -o ../../assets/css/compiled/main.css --watch\" // 新增这一行 } }\r在 themes/hextra 目录下运行 npm run watch 做完以上步骤后，我们在 layouts 下的 html 中写的 TailwindCSS 类才能被编译到 assets/css/compiled/main.css 中，从而被完整导入进 head-css.html。\n如果你想更改组件样式，或添加新组件，则可以在根目录的 layouts 文件夹下进行修改了！如果涉及对 themes 主题文件夹内文件的修改，请按相同路径复制一份到根目录，再在新文件内做修改！"},"title":"前端架构概览"},"/blog/guide-for-developer/maintenance/":{"data":{"":"","从一个-pr-开始#😎从一个 PR 开始":"","其它附属组件#📎其它附属组件":"","完结撒花#🎉完结撒花":"本篇是开发者指南的最后一篇，我们将会从宏观纵览整个 HOA 工作流。\n😎从一个 PR 开始\r当用户往课程仓库提交 PR 被合并后，课程仓库内的 workflow 会被触发： curl -X POST \\ -H \"Accept: application/vnd.github.v3+json\" \\ -H \"Authorization: token $GITHUB_TOKEN\" \\ https://api.github.com/repos/HITSZ-OpenAuto/hoa-moe/actions/workflows/course.yaml/dispatches \\ -d '{\"ref\":\"main\",\"inputs\": {\"repo_name\": \"'\"${REPO_NAME}\"'\"}}'\r而且，由于主仓库的 workflow 里存在如下设置：\nworkflow_dispatch: inputs: repo_name: description: \"Name of the repository\" required: true default: \"NOT_ASSIGNED\"\r故主仓库会运行一遍 workflow，从而更新主仓库内的课程文档。\n当主仓库有新 PR 被创建后，会触发 course-debug.yaml 里的工作流，检查网页是否能正常构建。 on: pull_request: branches: [main]\r并且，由于仓库已经配置好了 netlify bot，bot 会自动创建一个针对 PR 的网页 preview，由此便可以检查前端样式是否正确设置。\nPR 被合并后，可以到主仓库的 Action 界面看 workflow 日志，有问题方便定位。 📎其它附属组件\rHOA 集成了 giscus 评论系统，我们可以在仓库的 Discussions 界面查看页面评论 HOA 有一个名为 course-template 的私有模板仓库，创建新课程仓库时请选择从该模板仓库生成 你可以在组织的 Projects 界面内新建任务，方便管理当前某项任务的进度 🎉完结撒花\r看完本系列教程，相信你对 HOA 的功能开发已有一个完整认识。通过逐步学习和实践，你已经掌握了从基础架构到具体功能实现的全过程。\n当然，技术学习是一个持续的过程，本文档介绍的内容只是一个起点。希望你能够在项目的日常维护中运用这些知识，并在实践中不断探索和创新，发现更多优秀的开发模式和解决方案。让我们携手共建更好的 HOA！\nTalk is cheap, show me the code!🚀"},"title":"运维架构概览"},"/blog/guide-for-developer/overall/":{"data":{"":"","主体--github-action#💪主体 —— GitHub Action":"","结尾与下一章#👉结尾与下一章":"如何用一句话介绍完 OpenAuto 项目的主要内容及技术栈？（感谢 Claude-3.5 Sonnet）\n我们构建了一个基于 Hugo 静态站点生成器和 GitHub Action 持续集成与部署工作流的开放式资源共享平台，致力于知识传播和技术交流。\n与大多数托管在 GitHub 的资源共享项目不同，我们有着对用户更加友好的前端页面展示；也因此，我们的项目是一个集成前端、后端和运维的全栈型项目，无论是相关功能添加还是日常维护都需要一定的学习成本与技术积累，部分新人开发者可能会望而却步。本指南旨在改变这一状况，用简单明了的语言介绍清楚网站的整体架构，方便新人开发者快速上手开发。\n具体架构指南将分为三部分：\n前端架构详解 - 如何修改网站样式 后端架构详解 - 网站脚本的工作原理 运维架构详解 - 我们的网站工作流 而在本篇，我们会着眼于三者之间的联系而忽略大部分技术细节，简要剖析 OpenAuto 的网站是如何搭建起来的。\ntree -L 1 . # hoa-moe 文件树 . ├── archetypes ├── assets # 包含自定义的 CSS 样式、JS 脚本 ├── content # 存放 md 文件，Hugo 能自动将其中的 markdown 文件转化成相应 HTML 网页 ├── i18n # 语言相关配置 ├── layouts # 包含自定义的 HTML 框架 ├── public # Hugo 最终构建出的产物（即网站本体），一般不需要做任何改动，也不会被同步到 GitHub 远端仓库中 ├── scripts # 存放 HOA 后端脚本文件 ├── static # 存放网站相关静态文件，如 Logo、缩略图等 ├── themes # Hugo 主题模块文件夹 └── hugo.yaml # 网站基础配置文件\r🦴骨架 —— Hugo\r先借用 WikiPedia 里对 Hugo 的介绍：\nHugo 是一个用 Go 编写的静态网站生成器。Hugo 把用户提供的数据文件、i18n 包、配置、布局模板、静态文件，以及用 Markdown 编写的内容，处理并生成一个完整的静态网站。较出色的功能包括多语言支持、图像处理、定制输出格式、短代码等等。\n由于 Hugo 的可拓展性，我们可以在网上找到很多基于 Hugo 的博客主题，用户可以很简单的对主题进行定制化从而构建出属于自己的博客站点：更改对应配置文件并在 markdown 文件内写好内容后执行 Hugo 命令便能得到网页。我们网站的前端便是在博客主题 Hextra 基础上魔改来的。如此一来，我们就能更专注于内容的编写，不需要过多考虑前端样式问题。 （是这样……吗？）\n生成 public 文件夹中的 Hugo 构建产物后，我们便可以将其部署在 CloudFlare Page 上，绑定域名后通过 hoa.moe 访问网页了。\n💪主体 —— GitHub Action\r有了 Hugo 作为框架，我们便可以开始填充内容了。为了方便用户，同时避免一个仓库体积过大，我们按课程编号将最早的大仓库拆成了一个个小仓库。因此，我们需要在网页对应的仓库里用一种方式将各个课程仓库中的 README.md 内容拿到，移动到网页仓库的 content 文件夹下，再生成静态站点，我们所采用的方式便是 GitHub Action。\nGitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline. You can create workflows that build and test every pull request to your repository, or deploy merged pull requests to production.\nGitHub Actions goes beyond just DevOps and lets you run workflows when other events happen in your repository. For example, you can run a workflow to automatically add the appropriate labels whenever someone creates a new issue in your repository.\nGitHub provides Linux, Windows, and macOS virtual machines to run your workflows, or you can host your own self-hosted runners in your own data center or cloud infrastructure.\nGitHub Action 会为我们的仓库「分配」一台包含仓库内文件的虚拟机，我们可以在这台虚拟机上运行我们的脚本，执行复杂的任务。正是凭借这一特性，我们做到了诸如：抓取 README 文件、获取仓库内文件相关信息、为课程文档进行分类等一系列操作，最终构建出前端网页。\n👉结尾与下一章\r在正式开始进入下一章前，可以先阅读一下这篇文章：Hugo + GitHub Action，搭建你的博客自动发布系统，这篇文章几乎囊括了我们网站搭建过程中的所有步骤，所给出的例子也是网站的最小化实现。\n确保你对网站整体有个大概印象，下面让我们具体聊聊网站的前端样式吧：\n前端架构详解 - 如何修改网站样式 ","骨架--hugo#🦴骨架 —— Hugo":""},"title":"整体架构概览"},"/blog/how-much-money-can-students-make-without-being-a-coder/":{"data":{"":"","一些前提和共识#一些前提和共识":"","个人秋招#个人秋招":"","前言#前言":"","点击就送#点击就送":"","硬件方向#硬件方向":"前言\r我的自我定位大概是本科自动化学生的中层，最多再偏上一点点。随着大伙考研上岸和春招拿到好 offer，我的定位还有不小的下滑空间。\n为避免我误人子弟，任何自我定位或预期定位比我强的同学都可以把我这篇东西当作在放屁。\n鉴于自动化本科太过拉跨，读研的性价比相对来说还是很高的，无论是老师还是学长，相信都会给大家灌输自动化必须读研的概念。但是这个研总归不是任何同学都能顺利读上的，建议大家多考虑一下。\n十分建议考研的同学在秋招时投递一些点击就送保底的岗位，不会花去太多的时间，但效果会比考研失败了春招再投要好些。而且一般企业考上研了是可以无条件违约的，不用交违约金。\n一些前提和共识\r校招 / 秋招 / 春招：点我\n税前 / 税后 / 五险一金：点我\n白菜价：普通档的薪资水平；\nsp：special 的 offer，就是特别的薪资档位，比普通的薪资待遇更好；\nssp：super special，就是比 sp 又要更好上一级的薪资待遇。\n三方：学校、企业、学生三方签订的就业协议，意在确保学生毕业之后能够到该企业工作。理论上这个确保是双向的，学生不能鸽企业，企业也不能鸽学生，但是个人和企业的体量完全不能相比，通常来说三方只能限制住学生。三方填写需要在广东大学生就业创业小程序进行，需要两级审核后，企业通过，才算你正式申请完了三方，如果中间被任意一方打回，则视为没填过三方（比如刚填了三方但是有更好的 of 来了，还没审核完的话可以联系辅导员截止）。\n两方：企业、学生方签订的就业协议，没什么用，一般来说学生可以随便违，所以来两方就大胆放心签。\n点击就送\r列举一下仅仅是我知道的知名的点击就送的企业，大家可以参考一下能拿到什么价位。\n1. TP-LINK\r关于 TP 详情可参考《TP——从秋招到离职的一条龙服务》，在转码交流群群文件可获得\n基本情况\r做路由器等产品的纯纯学历厂，不点白不点。属于制造业，分为内销的普联和外销的联洲，两家独立招聘，岗位基本相同，建议都投递。 优势：\r门槛低点击就送，基础薪资高。本科白菜价是 17k，硕士 21k。 劣势：\r有一定的加班强度，工作时间为 995.5 或 996，工作日加班到 9 点之前算 1 次加班，周末加班 4 个小时算 2 次，加班没有加班费，只有 30 块餐补，并且加班次数会有排名，工作日上限 1 次，周末上限 2 次。 普联存在试用期结束卡转正的问题（联洲 22 届的转正率为 95%，考虑到自己跑路的存在，可以认为基本不卡转正）。 往年普联的年终都会给够 4 个月，但 24 年出现了波动，即个人年终可能在 0~10 个月波动，大概是最后 10% 的人无年终，引发声讨。截至 24 年，主打海外市场的联洲效益不错，所以不论是开的薪资，转正，年终都会显得比普联更好，但是据网上爆料，两家公司根底上的文化是相同的，也就是当效益褪去，联洲很可能就会跟普联一样卡转正，裁员，不给年终。 可能学不到技术，跳槽认可度不足，跳槽可能涨薪困难，甚至低于在 TP 的薪资。 个人投递情况\r6 月投递普联提前批（那时候不知道还有联洲），系统设计硬件工程师岗位，共三面，三面均问技术，面试时长均在 30 分钟左右，面试内容我已经忘了。\n8 月份开奖，电话告知薪资等级为 +5，即 sp + 5，在白菜价的工资上 +5k，签两方。\n9 月投递联洲正式批，系统设计硬件工程师岗位，共三面，三面均问技术，面试时长均在 10 分钟左右，基本是我介绍一遍我的项目，面试就结束了，非常快，快的离谱，非常简单，简单的离谱。\n10 月联洲正式批开奖，电话告知薪资 23k*16，推算为 sp+6。提前批只告知薪资等级的，具体薪资提前批和正式批都会在 10 月份开出来，可以参考 offershow 上往年的白菜价格，24 届和往年的白菜价格一样，为 17k*16。据说三面就有 sp，只有二面就是白菜。\n个人想法\r普联不考虑，联洲的我认为完全可以接，他开的实在是太高了，其他家面试基本都是被拷打还开的低，在联洲面试官表示出了对我的认可和期待我的加入 (泪目)。而且企业知名度高，暗坑少，基本就两点，加班和学不到技术。 关于加班，据学长称他所在一个比较好的部门软件每月平均加班次数为 13 次，且硬件略大于软件，我个人推算为加班 20 - 25 次左右，也就是 995.5 左右，我认为这个强度在制造业还算正常，双休还是有的。\n我拿到手的 of 基本都是这个强度，而联洲是其中开的最高的，遥遥领先，怎么选已经很明显了。事实上我已经心动得填了三方，因为学院迟迟没审批所以后来又有变数（，最终没去。\n2. 信步科技\r基本情况\r只校招 985 的重度学历歧视患者，做主板的。具体情况可以找找在里面的电信学长问，我了解不多。 优势：\r无技术笔试，难度点就送，薪资开的尚可，估计在 20W - 25W。 劣势：\r老板个人风格浓郁，采用了笔试写小作文的考察方式，老板可能不喜欢你的小作文就一票否决你的 of。 牛客可搜\r是电信的点送但不一定是自动化的点送，他们更偏向于收电信的学生，自又输，但是在秋招人还没招满的时候，自动化去蹭口饭吃应该也没问题，春招就基本只要电信的了。 不交公积金，但提供 60W 的无息贷款，也就是宣称校招员工都能深圳买房的原因。 个人投递情况\r9 月多投递，9.27 发了笔试题，我一看都是小作文就不想写，并且 HR 在中秋国庆放假期间打电话询问我的情况（期望薪资，岗位，以及一些 HR 面的问题，表示她们相比于嵌软更缺硬件，我很合适），并催促我完成笔试。我问她不放假吗，她回答调休过了，然后过了几天还在国庆假期又打了一次电话催促笔试。\nHR 态度还是很好的，就是放假打电话和小作文有点难绷，最终没提交笔试，HR 也没有后续。\n个人想法\r这家估计是真不看技术，学历和文字对胃口就行了，而且开的不算低，建议技术差的点一下。\n3. 比亚迪\r基本情况\rC9 传统工科最后的荣光，具体我了解不多，可以找在里面的学长问问。 优势：\r点送，薪资明确，F 类专业不止这些，范围很广，大数据、光电肯定也算 F 类，感觉跟车沾点边，泛工科的都算。 把你当什么都不会的招进去培养，不用担心你不能胜任工作 比亚迪\r劣势：\r管理混乱，岗位不是你选的是他分的，可能分到你完全不想去的岗位。 涨薪慢，本科生干三年肯定涨不到研究生起薪。薪资对于硕士来说很香，对于本科生来说基本是底线了。 氛围，待遇等各个部门不同，与小部门和领导强相关，有的部门绩效不是 36% 而会更高，有的部门 8 小时完全不加班，6 点人就走完了。 24 届招聘人数收缩，不再是投递就发 of，可能在简历池里泡死了都没捞起来，但是捞起来的人拿 of 的难度还是很低，难度上依旧是点送，只是比起 23 届（即 19 级）招的人少了，需要多一点点运气。 宿舍四人间，能拿每个月几百房补，可申请单人间但是很少，住单人间每个月交几百块。不住宿舍外面租房拿 1k 房补。（这条不知道算优势劣势，反正放着吧） 24 年 BYD 进行了一些改革，包括但不限于削减补贴，降低绩效，强制至少一个人要被打低分之类的。建议去其他渠道了解清楚。迪子或许已经不是那么淳朴的点送了，悲。 关于 BYD 认不认一年硕，23 届以前是认的。认的话一年硕拿到迪子的硕士价还是很香的。24 届刚开始也是认的，但是招着招着突然不认了，一刀切了所有一年硕的招聘流程，全部送进人才库。但是后来春招快结束的时候，它又认一年硕了，又问你还来不来……总之就是一个管理混乱，朝令夕改，大伙悠着点吧。 个人投递情况\r在 BYD 到学校宣讲前投递就好，迪子是每到一个学校就处理那个学校的简历，所以宣讲过后再投递有可能简历就不会被捞起来了，但是你可以尝试联系 HR 捞一下。\n迪子安排在学校教室进行线下面试，HR 面和技术面连着，捞我面试的部门是系统开发部门，技术面面试官看起来是做软件的，试图问我一些简单的八股，比如会不会 C++，知不知道智能指针之类的，我说都不会，我想要硬件岗，然后面试官就只能问我项目了，然后他也不是很能 get 到我的点，但是看的出来他在努力理解我做了什么。\n后面又来了一个电话，询问情况，项目之类的，我理解为电话加面。最后开的岗是 Layout 工程师，负责高速板的绘制。没去签约会所以不知道具体 of 情况。\n个人想法\r本科开的低还是 Layout 岗，没必要去。考研的建议点一下，也就花半天时间在学校教室面一下，就算阿巴阿巴跟面试官没接上线也还是过了。\n4. 南方电网 / 广东电网\r基本情况\r985 提前批免笔试，仅需一面即可收获老家垄断国企的 of。待遇整体次于国家电网。除了关系户，大体上按学历分配。 南网招聘官网，官方 APP“南网微招聘”。 优势：\r无需笔试，投入精力非常小。 垄断国企，稳定，没有裁员危机，待遇相比其他国企来说较高，而且可回老家。 劣势：\r非常不透明，薪资保密，岗位要等到二批招完才分配，直到你入职后统一培训完也就是入职 3 个月后才告诉你分配地点和岗位，也就是在你不知道你的岗位、薪资、工作地点、工作内容的时候就要跟它签 3 方，纯纯赌命。 不同地区、不同岗位差距较大，需要很细化的了解情况。 工作内容与所学毫无关系，可能杂活多，电气的得去砍树爬杆子（配电应该？），非电的不知道要不要爬。 新入职要爬岗，一开始工资很低，逐渐上涨，一般讨论的都是满岗后的待遇。 人员退三进一，新进去的小东西干活是少不了的。 子弟多，关系户多，没关系的难晋升，有钱又有闲的岗位都被子弟占据，普通人基本上躺一辈子（能躺一辈子真好）。 电气的点送，不一定是自动化的点送，自又输。 三方违约金 1w5，是最高的，而且考上研，考上公都不能免违约金（一般其他企业考上研和考上公是可以无条件违约的）。解除三方的日期是到 6 月 30 日，也就是基本不给你解约的机会。 个人投递情况\r一开始没想过国企，国庆的时候突然想起来有个广东电网，网上搜到了提前批投递方式和邮箱，在截止前投递了，投递时间应该是 9 月多到国庆。\n（电网不会来我们学校校招，而电网这招聘方式非常传统而原始，提前批以线下去 985 学校宣讲为主，我记得我是搜到了哪个学校的通知，里面有投递方式，我这才投递的了，看我们学校的就业公众号是没有的。）\n（广州供电局和深圳供电局独立招聘，待遇也是这俩最好，我们学校电气本科据说点送深供，自大输特输。那个时候我都不知道广深独立招聘，没投，知道的时候提前批时间已经过了。。）\n电网下面子公司很多，直属中心机构什么的，我都不太了解，一般说的电网狭义上可认为是各地供电局，当时不了解各个供电局和直属机构，投递好像能填 3 个志愿，我乱选的几个供电局，印象里是惠州，佛山，珠海。 我投的非电的信息通信岗（顾名思义，计科和通信的岗位，笔试题都是计科和通信的专业课，也就是提前批免笔试，自才能蹭一口）。\n10.12 一面，只有一面，提前两天短信通知（注意！电网这 b 所有通知都是用短信发的，注意短信！）。\n面试要穿正装，双机位，面试前先进一个腾讯会议检查机位等，等叫号进真正的面试间。面试官很多，包含 HR 和技术，但是面试时间很短，HR 问意向的城市，为什么，意向的岗位，为什么，对它有什么认知之类的。 技术问了两个问题，什么是面向对象和什么是差分放大（和私企的技术面疯狂拷打形成鲜明对比，泪目）。\n电气类的第二天也就是 13 号就会通知 of，非电类的可能得一个多月以后才出，电话通知 of。 我是只收到了惠州供电局（老家）的 of，电话中告知待遇保密，可视同当地公务员，地点和岗位入职后统一分配，但是提前批大概率市局（统一说法，是否画饼难说）。给半个小时考虑，回电是否接下 of。\n我的签约过程有点搞，广东电网是我秋招经历的最烂的招聘。HR 以为我是本部的，把我按哈工大的签约流程走，但事实上我是广东的，得按广东的流程走，我反复说她都没听懂，一个劲的说我是哈工大的，按她说的准没错。 然后就出错了……而且只能跟 HR 座机电话沟通，非常难以沟通，听不懂人话就算了，打过去要么占线要么不接，并且下午 4 点以后就不再接电话了……（哥你两点才上班啊 TAT）（行政岗是真轻松啊 TAT）\n（另外 HR 没权决定你的 of，当时电话说了要接 of 应该就不会被鸽，所以可以接了 of 然后拖着不签三方？）\n个人了解到的情况：\n所有东西都保密，只能互联网上搜到零散的信息，能找到在电网的学长直接问就再好不过了。 信通岗如果分配在主网 / 市局的话可能是调度中心和信息中心，但是名额很有限，都是个位数的。如果在配网/区局，那么专业和岗位都无所谓，配电和营销是个人都能干，所以直接无视你的专业和投的信通岗。变电岗就是传说中的上二休四，不过只有电气才有去。 电网以岗定薪，本科爬岗两年，一年考中作一年考高作。前期集中培训 3 个月，统一月薪 3k。培训结束后分配，开始有绩效工资，可能 4 - 6k，看具体的情况。一年后可能 8、9k。 电网一般是年终多，月薪少。以惠州供电局为例，满岗后大概主网 16W，配网 14W（按不同岗位和学历浮动，数字只是大概）。网上看的佛供 18W，广供 20W+，深供 30W+，珠三角大于非珠。满岗后薪资基本不涨了，但是还是在涨的（公积金）。 （电网谈薪只谈纯到手，即税后打到卡里完完全全拿在手里能支配的（没把公积金算进来，算进来更高），因为月薪低和不可描述的原因，年收入也可以用公积金指代，电网的公积金是真实年收入的双边 12%，不是按的基本工资）\n公司有食堂，几块钱自助。深供提供 8 年单人宿舍，惠供我忘了几年了。\n电网基本按学历分配，但是电网学历太卷了，双 9 硕才能拿到一些入场卷，比如电科院等。往年广供难进的很，但 24 届好像招的人比较多，本科也能进，但是肯定分配不了什么好地方了，会到郊区比较偏僻的地方去。像惠州这样的珠三角里靠后的，学历还不是那么卷，双 9 硕比较少，单 9 硕比较多，本 9 电气也稳进主网，非电不好说，视乎当年的竞争情况。再下来非珠三角地区的待遇更差，非电本 9 也能进主网了。这样看下来除了广深，基本只有回老家才有性价比。\n以下是某区级供电所配网的情况，可以当作下限来看能不能接受：工作时间 8.30-12.00，2.00-5.30，营销准时下班，但是要直面用户。配电可能经常加班，半夜起来查线抢修。凌晨工作第二天上午可以不去，其他加班的都得正常上班。营销月底月头周末要加班。配电要值班，以某所为例，6 天一轮，值班当天要全天在辖区内（过年也要值班）。\n5. 中广核\r基本情况\r核电工程公司，了解不多。宣讲待遇为本科总包 19W+20W 安家费分五年发放。硕士为 21W 总包。 优势：\r点送 稳定，没有裁员危机，待遇还行。 海景房住宿，独立单人间，水电全包，有餐补，等等各种福利补贴。基地内各种设施齐全。 劣势：\r远离人间。基地一般在很偏僻的地方，离市区远，下了班没什么地方好去（所以基地设施齐全，就在基地里放松娱乐。）拍拖很难，除非跟同公司的，不然一周五天都难见到人，就周末能出去放风。（在深圳就还好？） 工作内容未知，反正跟专业毫无关系，进去重新学。进去了估计就跳不出来了，跳其他核电公司可能还行，但是其他核电公司还有比中广核待遇好的吗？ 养鱼大户，可能会一直让你面试，体检，到最后却没有 of 发出来。 宣称的总包计入了乱七八糟的福利，水分可能比较大。 个人投递情况\r9.24 微信公众号投递，会一直等到来学校宣讲才会处理一个学校的简历，所以不用急，慢慢等。\n10.1 7 来学校宣讲，10.19 通知 10.21 到某酒店一面，一面形式为群面，面试时间为 1 个小时，一共有 10 个还是 12 个人，材料为一张纸，里面有 10 条举措，讨论出 5 条最有用的举措。 （有些人穿了正装，我纯休闲，甚至都没了解过群面怎么准备，反正轮到我就阿巴阿巴发言一下，只有两三个看起来是熟悉群面的在带节奏，大部分人都是阿巴阿巴，感觉只要多发言一两次超过大部分人就行）。\n10.22 23:05 通知 10.23 9:30 在酒店二面（nmd，时间这么紧），二面为 HR 面和技术面主管面一起面，三个面试官，问我如何看待中广核的工作作风“严、慎、细、实”，我说跟我们校训差不多，联系一下瞎扯了一通。 然后问 PID 是什么，HR 问意向的公司和岗位（前面投递的时候填的不作数，HR 会在面试的时候重新确定意向），我说我都不了解，这些岗位都语焉不详的不知道到底干什么，希望跟专业相关一点。\n10.26 晚通知 10.27 早上去南科大医院体检，免费，但也没有体检报告到手里。（对色盲要求好像很严格，在酒店的时候就当场测过）。\n10.29 电话通知 of，惠州公司的维修岗，半个小时考虑，拒了。可以看出来，中广核会在宣讲后的一段时间集中完成面试体检发 of 全过程，需要这几天投入比较多的时间。 个人了解到的情况\r待遇还是按学历来的，网上很多是双非的待遇不可全信，按某位在不是深圳的工程公司的本科学长的说法，我们本科进去总包 20W 左右，月薪和年终大概占 15W，运行岗会更高总包 22W。 月薪的话，税后运行岗 11k，其他岗 10k，不过运行要倒班。总工时小于 964.5。\n个人秋招\r秉持着分享不能只有大佬的分享，也需要看看一般的情况，所以还是斗胆给大家看看我情况吧，仅供参考。\n个人基本情况\r简历： 学分绩 84.9 33% 竞赛：智能车国三，电赛电源题省二 实习：TI FAE（现场技术应用工程师） 外语：六级 429（擦边过，反正也没被卡） 技术栈：单片机裸机开发，一点硬件基础，一点电源基础 求职意向：硬件、电源 个人时间表： 3 月左右开始投暑期实习 7-8 月实习 9 月开投秋招（太晚了） 10 月国庆回来面试集中爆发 Offer： 古瑞瓦特：12k 深圳 硬件工程师 比亚迪：17.9w 深圳坪山 Layout 工程师 雷赛智能：14k*15 深圳南山 硬件工程师 海浦蒙特：16k*15 深圳南山 硬件工程师 汇川 - 联合动力：(16+0.7)k*16 苏州 控制硬件工程师 禾望电气：(16+2)k*16 深圳南山 电力电子软件工程师 TP-LINK 普联：22k*16 深圳南山 系统设计硬件工程师 TP-LINK 联洲：23k*16 深圳南山 系统设计硬件工程师 道通科技 - 新能源：25k*14 深圳南山 电力电子硬件工程师 深南电路：14.5w 深圳 硬件开发岗 中广核：年包 19w+20w 安家费分 5 年 惠州惠东 维修岗 广东电网惠州供电局 待遇保密 岗位未知 （k 为单位的是月薪，w 为单位是年薪，例如 23k*16，意思是 23k 的税前月薪，16 个月的薪水，超过 12 个月的部分为年终奖）\n随便唠唠\r在就业的同学里面我的学分绩应该算高的，一般这个分段的同学都会选择考研或者一年硕或者冲一个竞赛加分，按 20 级的情况，我加 3 分大概也许或者有可能能蹭到保研的边边。\n我是竞赛寄了就不想保了，考研也觉得自己考不上，润又没钱，只好头铁冲秋招。 事实证明头确实很铁，还算凑活的学分绩对于秋招来说没有意义。\n我又是很摆的人，大概是大三上决定要秋招，说是说决定，其实更像是逃避考研，又懒得转码，竞赛里做的硬件部分，所以就想找个硬件方向的工作，但是又没准备好含金量足够的硬件项目。 总之就是基本没怎么准备，两手空空冲秋招，大家千万不要学我，大三上开始转码肯定是来得及的，大三下边转码边投实习一直到秋招也是来得及的。\n虽然我是非典型自动化人（死活不转码，一点代码相关不会，倒是往硬件和电源学了点），但是感觉有相当一部分人技术栈跟我差不多，因为课程和参加过一下比赛，所以会一点点单片机裸机开发，但是多的也不会了，也没用过 FreeRTOS，不会 Linux，没学过 408。 这种情况如果不读研或者考研失败的话相当被动，只能点一下点送的私企或者国企，私企的话大概率也只能单片机的嵌入式，除非另有机缘或者个人有其他方面的技能。\n我个人的求职目标不高，在秋招前的认知和目标大概是拿 24w 左右，希望有 28w，最低不能低于迪子。 最后的结果也基本符合，大部分 of 在 20w+，少数的风评比较差的厂（TP 和道通）开到了 30w+。 我在自动化就业里绝对算不上优秀，同样是硬件岗，同一届自动化有去了拓竹的，建议大家目标放高放远，别学我摆烂。\n我个人认知里本科薪资粗略的划分 (指在深圳)：\n倒数水平：比亚迪常数（17.9w）以下； 普通水平：20w-30w 优秀水平：30w 以上 顶尖水平：40w 以上 出于某种集邮的心态和为了写这段话，我参加了从实习（上一届春招）到秋招的所有在学校举办的大型招聘会，并且尽量参加了有相关岗位的企业宣讲（有硬件岗的都是制造业，而且有硬件岗的企业大概率也招嵌软）。\n我明确下个结论：\n对我来说招聘会就是没用。 招聘会是什么企业可以来报名参加的，所以出现的企业良莠不齐，很多都是深圳本地或者附近的没听过的待遇很差的小厂。 有一些中厂和大厂也会摆摊，但是它们都需要通过网申通道申请，你去摊位询问，他们也是让你去网申，基本线下留份简历在那里没用，甚至有网申通道没开启但是来摆摊的和不招人但是来摆摊的。 基本只有 HR 来摆摊，非常少的情况会有技术在，有技术在的也基本是没听过的待遇差的小厂，跟 HR 没什么好聊的，基本没什么有效信息获取。 招聘会的打开方式应该就是前一天对着参会企业名录看看有没有感兴趣的企业，有就去看一下，加个 HR 微信之类的，没有就不用浪费时间去逛了，没东西。 （其他专业和其他方向可能情况不一样，比如说一些国企之类的可能真能谈谈？但是我破本科硬件也没有研究所国企之类的好去） （我真的去投了那些查不到什么信息的小厂，甚至线下去参观，拿了 of，所以可以下结论确实是没听过的待遇很差的小厂。） 企业宣讲还是有点用，虽然很多情况都是来成为抽奖的分母。 企业来宣讲还是会做一些准备，一般 HR 和技术都会来，还有些小礼品抽个奖之类的。大厂基本不会有当场笔试和面试的机会，但是来加个微信、获取一些信息也算是好的。 有一些中小厂可能会有当场面试，比如海浦蒙特、古瑞瓦特、禾望都是当场面试，TI 是当场笔试。 就业网上的日历可以看什么时候有企业宣讲，还可以。学校的就业处微信公众号有点拉，建议同时加一下本部的、华科的、华工的等等 985 工科的就业公众号。 细说一下\r实习\r我大概是大三下开学开始投实习，硬件的实习其实挺少的，大厂更少，我能过简历的更少，总之就是只投了几个小厂和 TI 和华子。华子头铁投的电源岗，直接笔试挂了 TAT，还有几个小厂钱不多强度还大，感觉意义不大，就拒了。\nTI (德州仪器) 是 3 月底就来学校宣讲，当场笔试，现场投递，（可以后面再补上线上投递）。\nAE（应用工程师）招的很少，基本都是 FAE 和 TSE（FAE 可以姑且理解为售前和售后，一般认为半技术半销售，作为 AE 等和客户之间的桥梁（传话筒），不过 TI 的 FAE 应该更偏销售了，TSE 就是纯销售）。 没信心拿下 AE 所以投了 FAE（模拟方向）（大伙可以投递嵌入式方向的 FAE，模拟要大杂烩什么都学，嵌入式只要专精一个芯片就行，相对来说更技术，没那么销售），大概一周内打电话告知通过笔试，约线下面（要穿正装）。\n只有一面，面试官就是入职后的主管，包含技术面和主管面的成分，以拷打简历上的东西为主，大概 40 分钟。 TI 很喜欢刨根问底，抓着一个点问到你回答不出来为止，不能问上两层的东西就尽量别写简历上了。\n介绍项目的时候让我画出框图，介绍每一部分，逐一拷打，问做的过程遇到了哪些困难怎么解决的；问了电源基础（LDO、DC / DC）；问对 FAE 有怎样的认知；问我为什么不考研，除了 TI 还投了哪些，华子和 TI 都给我实习 of 我去哪（我事后觉得，问这个应该就是要我的意思，只是当时我没反应过来）。\n最后让我用英文介绍家乡，我直说我没准备不会说，他问我过四级没，我说过了，就作罢。\n一周后发 of 吧。对了，虽然我已经做了线下笔试，但是补线上投递的话还是会发线上笔试，然后我就又做了一次（这次的成绩应该不作数？）。\nTI 的笔试（模拟方向）很有意思，题量非常大，涵盖电路、模电、数电、自控、电力电子、通信协议、信号链等内容，以小题为主，只有一个小时，只能会写什么写什么。 不过 FAE 的笔试成绩应该要求不高，AE 要求应该高很多（同一套卷）。\nTI 在中国的大本营在上海，不多的研发岗基本在北京和上海，成都制造为主，深圳销售为主，有不多的 AE 在深圳，不一定招 AE，但是 FAE 和 TSE 应该还是挺缺人的，跑路的人也多，跑路原因基本上是国产芯片厂开价更高，强度可能也比 TI 小（TI 还是会给压力的）。\nTI 对实习生还是挺重视的，但是具体情况还是得看主管和 mentor(导师) 的安排。 虽然我觉得我什么都不会，但是主管觉得我有做过东西，技术还不错的样子，说“哈工大的产学研做的不错的”，我哭死。\n模拟方向 FAE 的一般从电源芯片开始学习（在学校没学过信号链），当然也看安排，同期有一个电气硕的老哥就被安排学习非常多的东西，非常充实。 相对来说我的 mentor 不太管我，所以我整天摸鱼没学到太多东西。\n两个月的时间基本上是前一半时间学习电源芯片基础，拿 TI 的 EVM 板子测试，写写实验报告，后一半时间去跟着 mentor 见客户，线上线下给客户 debug，体验一下售前和售后的 FAE 工作流程，也要写写报告。 最后有一个转正答辩，会有大老板来听，决定是否转正。\n一般来说实习时间是先定 6 周或者 8 周，因为要安排实习计划和答辩时间。不想答辩了那就中间随时可以跑路。\n总的来说，销售岗实习还是对秋招想找技术岗的没什么帮助，也不好把实习经历写成项目，对于技术一般和想走非技术岗的可以投投看。 TI 的销售岗待遇还是相当可以的，也不会歧视本科，本科硕士就底薪差 1k，但是本科还是难进，毕竟本硕同台竞争。\n我印象里 FAE 和 TSE 底薪都是 2w，公积金拉满，季度奖金和年终另算。 而且 TI 是有普调的，第二年能涨 10% 还是多少，不记得了，可能记的不准确。\n但是 TI 的强度比一般外企要高，虽然说是 965，但很有可能要自主加班。 主要是要跟着客户节奏，客户卷产品迭代快，FAE 就得跟着卷 (然后深圳企业普遍压榨和卷……)，然后因为要跟美国人沟通，所以很可能需要半夜自主加班一会。 不过 TI 出来也好跳，至少国内的芯片厂同岗位应该不难拿下。 另外，我其实觉得自动化本科还挺适合销售岗的，都会一点，也只会一点，靠着这点基础卖东西去。 销售岗可能会经常出差，出多远视乎客户在哪里。适合喜欢到处跑跑，跟人打交道的人吧。\n秋招\r我是实习结束才 9 月才开始投秋招，有些晚了。 总结一下秋招就是投了大中小厂 70 家，十几家给面，大厂不理我，黑厂开的高。 很多厂的硬件岗要求写着硕士的我就没投，然后我又只投在广东的企业，感觉投到后面已经不知道还能投什么了。 像 OPPO 笔试挂，VIVO 简历挂；中兴过了笔试但一直没给面。\n说一下几个上面没提的 of 吧。\n古瑞瓦特\r12k，新能源企业，来学校宣讲，现场面试，统一打包价 12k，评价为狗都不去。很后面又打电话说嫌少可以再谈，估计是没人理他，来捞人了，懒得理它。\n雷赛智能\r14k，做运动控制卡的，开的又少又加班，但是 HR 跟我打专业牌，说他家是领域内国内第一，很契合我的专业，在本行业领域就是这个价，不低了哦。我 qnm 的本专业。\n海浦蒙特\r16k，做电梯的小厂，来学校宣讲，现场面试，10 分钟面完通过，of 发的也快。虽然是个小厂，知乎也有黑料，但是这是第一家开的达到我预期薪资的厂，并且飞快的发 of 速度给了我一个保底的信心，态度很好，非常感谢。\n还有就是 HR 小姐姐很可爱，后面也有打电话问我还去不，我哭死。\n汇川 - 联合动力\r16 + 0.7k，据说汇川是小华为，做工控起家，现在也做新能源，感觉对口机电的所有专业（华子下位替代，钱比华子少，加班应该不少）。\n面试拷打的也挺细致，最后就开 16k，真不行吧。\n深南电路\r14.5w，制作 PCB 的厂，看风评虽是国企但是加班很多，来学校宣讲，感觉我是误入，好像来的都是材料学生。\n我看录取名单里都是些普本，哈深是里面最高分的（纯当观察一下别的学校别的专业了，auto 本虽然烂，比材料本还是要好点）。\n禾望电气\r16 + 2k，新能源企业，风电很厉害，离学校很近。\n前面投了简历不处理，直到来学校宣讲才处理，当场 hr 面 + 技术一面。技术面给我拷打麻了，支支吾吾半小时，面完汗流浃背心力交瘁。\n面成这样我都没想到还能通过，没多久打电话约线下去公司二面。HR 说技术说我的基础还不错，我说我基础都被拷打麻了还能不错吗。 两个技术总监一起面，主要问自控基础，S 域 Z 域转换，PID 之类的，好多我都忘了，但是总监在纸上直接推导给我看，泪目。 然后他们得出的结论是我可以用，但是需要人带一下。然后带我参观了一下公司。\nHR 催我签 of，我说要拖一下，也拖的很顺利。总的来说这家整体招聘流程挺舒服的，都很真诚，技术主管和总监都有一种质朴的深耕技术的感觉。\n虽然是电力电子软件岗，但可以没有电力电子基础，会自控就行，有考研失败的同学（毕竟考研专业课是自控）春招去面，拿的 of 跟我一样。 加班的话理论上是三天 8 点半 2 天 6 点对标理论上的华子，实际上可能还存在一些自主加班吧。 道通科技 - 合创数字能源\r25k，道通是深圳四大黑厂之一，做无人机的；合创是做新能源的子公司，做充电桩卖海外，网上风评也不太好，但是据我一个进去的朋友说，换了领导，现在的氛围还好，具体情况可以问问子子学长。\n线上一面，对我的毕设（我毕设跟电气）很感兴趣，问我能不能接受加班。\n约线下公司二面，也不算二面，感觉就是聊聊天，参观一下公司，对话中的感觉就是已经要了我，甚至商量让我在公司做毕设，问我有什么需求，怎么才能做个优毕出来。\n看得出来很缺人，让我早点去实习、做毕设，甚至问我要导师的联系方式，看意思是很想把她学生都打包过来实习 / 就业。其实感觉态度挺好的，对我挺看重的感觉，开的也很高，不过当时囿于网上风评太差，还是拒了，后来我朋友才进去的。\n如果是想做新能源的，又不怕加班的，感觉来这里也挺好，起码钱多（我一个非科班半吊子都有 25k，科班我都不敢想）。\n看这几个 of 应该也能看出来，我试图蹭一口新能源的饭吃，不过最后没蹭上。很多硬件厂比如手机厂比较成熟，招的人少，要求也高，很多都要硕士，新能源还在洗牌，还算是有点机会。\n后来还有几家新能源企业拒面了，面到后面感觉面来面去也是小厂，也是差不多的价格，不想面了。\n这几个 of 里面真正考虑过的有几个：禾望、道通、TP 联洲、老家电网。\n禾望是电源软件 / 电力电子软件，道通是电力电子硬件，都是跳新能源 / 电源混饭吃，禾望相对来说稳定一些，风评好一些，软件方向应该好一些也舒服一些，道通就是开的高但是风险也大些。\nTP 联洲就是纯钱多。老家电网就是我必须考虑这是否是我此生仅有的回家工作的机会。\nof 大家最后总是会有的，无非是好些坏些，最后选择哪个 of，其实不看是不是多那一两千起薪，更重要的是选择发展的方向和想要的生活，这就因人而异了。 面对同样的选择，大家可能考虑的点不一样，做出不同的选择，所以我就不说我最后去哪了（。\n硬件方向\roffer 参考\r以下是某硬件群拿到的 of，里面绝大部分人的本科是没有哈深分高的，大家可以参考一下硬件薪资。点我跳转 可以看到硬件本科是比较难的，大部分薪资都不高，基本没有超过 30w，就算是研究生，也就是拿到计科的本科起薪罢了。（当然这也与群友水平比较低有关，能去疆去竹的自然薪资高） 建议不是想不开的同学还是不要干硬件（大佬随意了），同公司里一般嵌入式软件的岗位数量，薪资，工作强度都优于硬件。大伙还是尽量力扣启动吧。 但是硬件岗的好处就是目前来说招聘的卷度是不如软件的，笔试不用写代码甚至全是选择题（或许会有模电/电力电子计算题），（美团除外，美团硬件岗笔试也得算法题）。但是缺点就是缺少高质量开源资料，缺少免费的培训班和项目，个人很难成长。投入同样的时间精力，在软件上获取的进步和收益应该是比硬件要大的。不少硬件小厂还是保有淳朴的招聘观念：进来再学（反正本来上学也没什么看得过去的硬件项目），所以难度低，点送。但是想进大厂就挺难的吧，不像软件有比较明确的努力路径，所以一般只有依托于竞赛等实验室和课题组有项目的情况才方便找硬件岗。 方向参考\r硬件工程师是一个比较笼统的称呼，很多公司在招聘的时候岗位名称写着硬件，但是工作内容可能差别还挺大的。贴一下 trent 老师（b 站可搜）的分类。 这里的硬件工程师基本都是指板级硬件设计，不包含芯片设计，也基本不包含代码。 我一般指的硬件岗都很狭义，比如 FPGA 岗，写 FPGA 的代码的，我看来这是纯软件岗，画 FPGA 板子的才是硬件岗。\n在小公司里，硬件可能只有 1 或者 2 个人，基本就是硬件全栈，所有有关硬件 / PCB 的东西全包，画原理图，画 PCB，采购元器件，写代码，调试板子，call 原厂 AE 和 FAE 救命，PI/SI 仿真，EMC 整改，与客户沟通。\n大公司岗位就分的比较开了。（某种意义上说，硬件岗天生就是要干杂活的，不想干杂活的就跑路吧）\n与 Layout 工程师 / PCB 工程师对应时，硬件工程师指原理图工程师（只画原理图，Layout 有专人负责或者外包）； 与电子工程师对应时，硬件工程师指涉及高速电路、操作系统、使用高度集成化的芯片的板子的原理图工程师，电子工程师则指不太涉及高速电路，围绕裸机 MCU、分立器件的小硬件全栈工程师。\n硬件的方向可以粗略划分为高频高速和功率，很明显，前者通信更对口后者电气更对口，没关系，auto 都能蹭。\n射频、天线之类的划到高频高速里。功率的话，就是设计电源，其实电源软件和电源硬件挺近的，很多电源佬都软硬全栈的（。\n关于硬件发展，现在芯片的集成度越来越高，硬件（原理图）工程师发挥的余地可以说越来越小，基本就是抄原厂方案，特别是涉及高速高频的芯片，原厂解决一切，有问题就 call 原厂 AE 和 FAE。\n硬件岗可能更多地是做方案集成和解决一下信号完整性的问题？而电源一般认为是模拟电路里不容易被取代的一部分，不过现在小功率电源的集成度也是越来越高，也就电感电容不容易继承进芯片。 由于散热等问题，大功率电源集成不了，还是有广阔天地的（或许），所以也有某种说法是做大功率电源比普通的抄图硬件（包括小功率电源）要好，（不过也有说新能源没几年好日子了，大功率电源/电力电子也要不行了，大伙自己判断吧）。\n硬件逐渐变成抄图的螺丝钉，所以某人有种说法是硬件（原理图）工程师就是板级装机。 值得注意的是，这种专抄图，做方案集成的螺丝钉，（虽然可替代性比较强但）薪资反而可能会很高，因为是大厂，做的是高附加值产品（也许。而在小厂亲手设计电路，难归难，可能工资还没那么高（主要是大厂可能不会让人设计电路，都是有设计规范，用集成芯片的）。\n至于电源，感觉做电源硬件不如做电源软件/电源控制算法，电源的不可替代性强很多，很吃经验，电源厂给应届生很难开到互联网大厂的价格，但（类）互联网大厂却可以给硬件（原理图集成）工程师开出近似于互联网软件岗的价格。\n投递公司方向：\n手机厂相关，招基带、天线等，基本属于高频高速，很多有硕士学历要求。 新能源企业，光伏风电等：以大功率为主，朝电气蹭就完事。 车企相关，车太大了，高速和功率都有。 其他，医疗，家电，机器人等行业，高速可能没那么高，功率也没那么高，总之技术栈比较杂什么都做。 芯片原厂，投 AE 和 FAE，看会什么投做什么方面芯片的厂。 牛客冰洛之城硬件帖子总结 招聘要求参考\r这个应该是华子和大疆的硬件招聘要求，可以看到大疆的要求非常多……我觉得本科应届生能满足几项就不错了\n这个是 trent 老师视频里写的，基本上就是单板硬件的技术栈了（通用硬件，偏高速方向）。\n本科生基本没有什么关于信号完整性和 EMC / EMI 的项目吧，看点相关知识（八股）就差不多吧。\n感觉普通学生对应准备的话，就画下核心板（从简单的 STM32 到复杂的 FPGA），了解下总线和通信协议，（简单的如 I2C、SPI，复杂的高速协议如 PCIe 等感觉要求有点高了，我没这本事 TAT，大佬可能会吧），学一点电源基础（LDO、DC/DC），然后找相关项目吧（发现找不到）（或许可以去 lzl 老师的课题组薅硬件项目，比如趁大三暑期的那个实习去白嫖项目）。\n贴一些链接：\n硬件基础知识，八股：微信公众号硬件工程师炼成之路，他有个几百页的 pdf，虽然比较长但是说人话，可以当字典查。 硬件基础知识，电源基础知识：微信公众号硬件十万个为什么，文章和书写的不错（特别是电源篇我觉得非常好）。培训课没买过不懂。 硬件项目：立创开源硬件平台，现在日子好了，立创开源上有不少挺好的项目了，搞了个星火计划可以看看。但是完全没有硬件项目基础的话，可能会无从下手，可以先找个简单的核心板抄，然后再去找难一些的项目抄。（想往数字、高速方面学的，可以去尝试复刻一下各种派，香橙派，香蕉派什么之类的；想往电源发展的，可以去做一下电赛历年电源题或者 TI 官网的参考项目） 网盘：嘘，提取码：shit "},"title":"不转码的普通自动化学生能拿多少钱"},"/blog/how-to-use-fx991cn/":{"data":{"1-标记与指示符简介#1. 标记与指示符简介":"","2-按键简介#2. 按键简介":"","3-模式简介#3. 模式简介":"","4-设置简介#4. 设置简介":"","5-常用技巧#5. 常用技巧":"","一些链接#一些链接":"​期末月期间在自救群里看到了一些关于卡西欧 FX-991CNX 计算器使用的讨论，才发觉其实有很多同学不那么擅长使用该计算器。\n本人高中时曾经旁听物竞课程，记得当时的第一课既不是运动学，也不是速通微积分，而是 991 使用教学，本人从此开始使用这款功能完备的计算器，也算是略有一些经验。\n​目前，无论是 991 自带的说明书还是网上的教程，对该计算器的介绍都相当全面，但是作为一名自动化学生，这些教程要么过于基础，要么过于驳杂，很难让人有看下去的欲望。\n因此，本文旨在为大家奉上更简洁、更实用、更适合自动化学子的计算器使用教程。本文也可作速查手册使用，可先翻阅右侧的目录以大致了解文档结构。本人对该计算器的使用也并非尽善尽美，欢迎各位批评、指正。\n更适合自动化学子的计算器使用教程1. 标记与指示符简介\r​991 的功能按键存在非常多的复用，即一个按键对应多个功能，不同功能的图标颜色不同。例如：\nsin 上面有黄色的 sin-1、红色的 D，D 被蓝色中括号⌈ ⌉括起来；\nENG 上面有紫色的 i、 黄色的 ∠， 黄色的箭头 ← 由 i 指向 ∠， ∠ 被紫色中括号 ⌈ ⌉ 括起来。 它们调用的方式不尽相同。\n黄色标记的功能需要先按 SHIFT 再按对应按键，以下记为 SHIFT+xx(yy)，括号内为对应的按键标记； 红色标记的功能需要先按 ALPHA 再按对应按键，以下记为 ALPHA+xx(yy)，括号内为对应的按键标记； 蓝色标记的功能在基数模式里调用； 紫色标记的功能在复数模式里调用。 ​ 部分按键按下、部分功能启用或部分设置变化时，屏幕最上方的横栏中会出现对应的提示符。常用的提示符如下：\n按下 SHIFT 会出现 S， 按下 ALPHA 会出现 A； 按下 STO 会出现 **→**x，表示计算器正在等待输入变量名称（ABCDEFxyM），从而为该变量赋值； D, R, G 表示缺省的角度单位，分别为角度、弧度、百分度，可在设置的角度单位子菜单中切换； FIX, SCI 分别表示结果输出格式为固定位数的小数或者有效数字，可在设置中的显示格式子菜单切换； i 和 ∠ 分别表示复数的默认输出格式为 $a+bi$ 或 $r∠θ$，可在设置中的复数子菜单中切换。 2. 按键简介\r此处略去各种较为基础的运算按键，如加减乘除、指数对数、三角函数相关、定积分等，只讲一些可能被忽视的功能，按照个人认为的重要性依次排列。\n数据记录、查询与调用\r很常用\r​STO 与 SHIFT+STO（调用），一般用于记录中间变量以便计算中调用，善用该功能可以简化表达式。\n对于输出的结果，按下 STO，会出现 **→**x。再按任意有变量标记（ABCDEFMxy）的按键，则该值会被记录至该变量下；\n按下 SHIFT+STO（调用），则会在新的页面中显示所有变量的赋值，此时再按任意有变量标记（ABCDEFMxy）的按键，则会在表达式中输入该字母；\n也可通过 ALPHA+ 任意有变量标记（ABCDEFMxy）的按键 输入该字母。\ne.g.\n输入 1，按下 STO，出现 **→**x，按下 sin（它对应的变量为 D），则 D 被赋为 1；\n按下 SHIFT+STO（调用） 显示所有变量的赋值，若 D=1，则表明赋值成功。\n此时按下 sin（它对应的变量为 D），则会输入 D，按下 =，结果为 1；按下 ALPHA+sin（D） 同样可以输入 D，按下 =，结果为 1。\n科学常数\r较常用\r​SHIFT+7（科学常数），包括通用常数、电磁常数、原子与核常数、物理化学常数等。\n分数小数互化与带分数假分数互化\r较常用\r​S⇔D 与 SHIFT+S⇔D。\ne.g.\n若结果为假分数，按下 SHIFT+S⇔D，会使其变为带分数，反之亦然； 若结果为分数，按下 S⇔D 会使其变为小数，反之亦然。\n答案\r较常用\r​ANS。记录了上一个表达式的结果。\n选项\r较常用\r​OPTN。在默认的计算模式下，输入角度的单位默认为设置中的单位，而 OPTN 中可输入角度单位（°、r、g），将输入角度的单位设置为输入的单位。\n在其他模式下会有更多不同功能，在后面模式简介中介绍，此处按下不表。\n​e.g.\n若设置中的缺省角度单位为度，输入 1，按 OPTN 进入选项，按 2 进入角度单位子菜单，再按 1 输入 °，按 =，则输出为 1；\n若在角度单位子菜单中选择按 2 输入 r，则按下 = 后输出约为 57.3（$1 rad ≈ 57.3°$）。\n直角坐标与极坐标互化\r不常用\r​SHIFT++(Pol) 与 SHIFT+-(Rec)，只能在计算模式种使用。\ne.g.\n以直角坐标化为极坐标为例，输入 Pol，再输入 $x, y$ 坐标，两者之间以逗号 SHITF+)(,)隔开，则输出对应的 $r$ 和 $θ$。\n单位换算\r不常用\rSHIFT+8（单位换算）。一般仅用于压力和速度的换算。\ne.g.\n输入待换算的数据，按下 SHIFT+8（单位换算），找到所需的换算式，按下对应的数字，则会输入该换算式，再按 =，则会输出换算结果。\n质因数分解\r不常用\r​SHIFT+°’\"(FACT)，只能在计算模式种使用。\ne.g.\n输入 10 位及以内的整数，按下 =，再按 SHIFT+°’\"(FACT)，则会输出分解结果。\n注意，计算器无法分解过大的整数（7 位及以上），此类整数会用括号标注。\n3. 模式简介\r此处仅介绍常用模式及其功能，大部分功能都集成在 OPTN 选项下，可以在相应模式下按 OPTN 查看。菜单中可以切换模式。\n计算\r最常用\r默认模式，无特殊功能。\n复数\r很常用\r可计算辐角、共轭，提取实部、虚部，进行直角坐标与极坐标转换。不能计算 $e^{iθ}$！\n在复数模式下，按下 ENG 会输入 i，按下 SHIFT+ENG（∠） 会输入 ∠。\n矩阵\r很常用\r可定义、编辑最大 4 x 4 的矩阵，计算矩阵加法、乘法，乘方、逆，行列式、转置，记录上一个矩阵表达式的答案，输入单位矩阵。不能求矩阵的秩！\n定义、编辑矩阵时，需要在相应位置输入各元素的值，输入完成之后按 = 结束对该元素值的编辑。所有元素编辑完成之后，可以直接按 AC 退出编辑、进入计算，也可以按 OPTN 选择继续定义、编辑其他矩阵，或者进入计算。\n定义或编辑方阵后，按 OPTN 进入选项，选择相应的方阵输入，按 x-1，然后按 =，即可求出该方阵的逆矩阵。注意必须要使用 x-1 而不能使用 x□ 再输入 -1，否则会出错。\n同理，输入方阵后，按 x2 或者 SHIFT+x2（x3），然后按 =，即可求出该方阵的平方或者立方。\n向量\r较常用\r可定义、编辑最大三维向量，计算向量加法、乘法、内积、夹角、模长。\n定义、编辑向量时，需要在相应位置输入各元素的值，输入完成之后按 = 结束对该元素值的编辑。\n所有元素编辑完成之后，可以直接按 AC 退出编辑、进入计算，也可以按 OPTN 选择继续定义、编辑其他向量，或者进入计算。\n定义或编辑向量后，按SHIFT+( (ABS)，再按 OPTN 进入选项，选择相应的向量输入，按 =，即可求出该向量的模长；\n按 OPTN 进入选项，选择两个向量形成的夹角（输入 Angle），然后输入相应的向量，两者之间以逗号 SHITF+) (,) 隔开，按 =，即可求出两向量之间的夹角。\n方程\r很常用\r可求解四元及以下的一次线性方程组、四次及以下的一元线性方程。对于二次方程，还可以求解相应二次函数的最值大小和最值点。\n不等式\r较常用\r可求解四次及以下的一元不等式。\n统计\r较常用\r可计算期望、方差、标准差等统计数据，还可以用最小二乘法，根据指定形式函数进行拟合。\n基数\r不常用\r用于 2、8、10、16 进制之间的转换。\nDEC 表示十进制，HEX 表示十六进制，BIN 表示二进制，OCT 表示八进制。\n在十六进制（HEX）模式下，按下 (-)、°’\"、x-1、sin、cos、tan 会分别输入 A、B、C、D、E、F。\n4. 设置简介\r​SHIFT+ 菜单 (设置) 即可进入设置，设置一般默认即可，也可以按需调整。 SHIFT+9(复位) 可将所有设置数据重置为默认值。\n以下介绍顺序按照个人认为的重要性依次排列。\n角度单位\r经常需要调整\r可将输出默认角度单位设置为角度、弧度或者百分度，对应提示符分别为 D、R、G，默认为角度 D，一般只用前两个。\n复数\r偶尔需要调整\r可将输出复数结果的默认格式设置为 $a+bi$ 或者 $ρ∠θ$，对应提示符分别为 i 与 ∠，默认为 $a+bi$。\n分数结果\r一般无需调整\r可将输出分数结果的默认格式设置为带分数或者假分数，默认为假分数。\n方程/函数\r一般无需调整\r可打开/关闭高次方程复数结果的输出，默认为开。\n输入/输出\r一般无需调整\r可设置输入 / 输出默认格式，默认为数学输入 / 数学输出，一般默认即可。\n5. 常用技巧\r此处为本人一些小小的心得体会，欢迎补充。\n解单变量方程\r在计算模式下，​ALPHA+CALC(=) 输入等号，等式两侧输入单变量表达式，SHIFT+CALC(SOLVE) 输入变量迭代初值后求解距离初值最近的解。\n若解距离初值过远可能显示无解，求解过程可通过 AC 打断。\n可用于求解非线性方程、高次方程、超越方程。\n注意：对于有解的方程，如果迭代初值不合适，可能会提示无解。\n​e.g.\n输入 ln(x)，ALPHA+CALC(=)输入等号，再输入 1，此时屏幕中显示 ln(x)=1，按下 SHIFT+CALC(SOLVE)后输入变量迭代初值 0，按下 = 即可求解，解得 x = 0。\n含参表达式求解\r输入含参数的表达式，按下 CALC 后可依次输入各参数的值，最后得到计算结果。\n可使用此功能快速求得单变量方程的数值解，在部分情况下（如自控理论 B 的频率特性校正计算）有奇效，具体操作如下：\n自己化简等式，使等式一侧只含常量，另一侧为含参表达式； 输入含参表达式，通过前述 CALC 功能求出参量取不同值时的结果； 结果与常量足够接近时，参量的值即可视为近似解。 该技巧相当于手动迭代求解代数方程的数值解，每次迭代只需 3 次按键操作（CALC, 数值，=），若能熟练掌握，求近似数值解的速度可以比前述 solve 功能快。\n​e.g.\n已知 $90-\\arctan(0.5x)+\\arctan(0.1x)-\\arctan(0.01x)-\\arctan(0.005x)=0$，求解 $x$。\n解：\n输入表达式 $90 - \\tan^{-1}(0.5x)+ \\tan^{-1}(0.1x) - \\tan^{-1}(0.01x)- \\tan^{-1}(0.005x)$。 按下 CALC 后输入 0（即变量 x 的值），按下 = 后即可求得 x = 0 时表达式的值。 重复前述过程，可以求出参量取不同值时表达式的结果，当结果与 0 较为接近时，此时 x 的值即可作为近似解。 计算传函的分离点并验证是否存在\r在自控理论 A 的中，往往需要绘制开环传函 $G(s)$ 的根轨迹，这时候需要计算传函的分离点并验证每个分离点是否存。用相角条件验证的方法往往很复杂，这里介绍一种简单的方法。\n首先求得特征方程 $D(s)=0$，并与 $D’(s)=0$ 联立消去根轨迹增益 $k$ 之后，得到一个关于 $s$ 的 $n\\leq4$ 次的代数方程（该步骤和课件中推导根轨迹公式的过程一致，自己做的时候推一遍其实更方便）。\n在 991 的菜单中选择方程/函数模式，选择 2.多项式方程 $n$ 次，输入方程的系数，按下 =，得到方程的解，即为传函 $G(s)$ 的分离点。此时计算出来的可能不是实际的分离点，需要进一步验证。对于每跳出来的一个解，使用 STO 记录，即可把精确的分离点都记录下来。\n回到复数模式，通过 $D(s)=0$ 分离出计算根轨迹增益的公式 $k=F(s)$，其中 $F(s)$ 是 $s$ 的函数，此时将 $s$ 替换为刚才记录的分离点，即可得到根轨迹增益 $k$ 的值。\n根轨迹增益 $k$ 存在的条件是，计算出来的 $k$ 为正实数。\n一些链接\r如果想更全面地了解 991 的基础功能，可以参考\nCASIO fx-991CN X 说明书 - CASIO 师生资料下载 - CASIO 如果想了解各路大神在 991 上整出来的花活，可以参考 fx-991cnx 计算器：利用 ROP 漏洞执行任意代码 - 知乎。","更适合自动化学子的计算器使用教程#\u003cstrong\u003e更适合自动化学子的计算器使用教程\u003c/strong\u003e":""},"title":"卡西欧 FX-991CNX 计算器使用指南"},"/blog/how-to-use-hitsz-jw/":{"data":{"":"","关于选课#关于选课":"","更多技术相关#更多技术相关":"本文是关于教务使用的一篇小教程，刚好笔者前阶段对教务也算深有感触，遂写此篇。\n教务承担了课程选课、成绩查询等任务，自然在学期前与学期终迎来大量的流量。然而恕我直言，教务系统本身的编写并不优秀。如果你对 web 与逆向工程稍有了解，那么你肯定在教务卡死的时候尝试一些方法——最后你会发现，这一定是一个外包项目，因为源代码中甚至还有“购物车”这样的字眼。 然而差归差，我们必须捏着鼻子用它，因此更多技术相关内容下文表述，这里我先介绍一些实用的功能。\n首先关于教务系统有一点不得不提的是，它甚至连返回都没做好，请你不要在页面左上角使用浏览器提供的返回上一级按钮，不然你会直接回到认证系统。关于认证系统的信息在文末提供。\n查看课程信息\r首页的 有个主修计划查询，选择大类，点击查询 即可查询大类方案 可以看到课程是考试课还是考察课。另外还可以查看学分要求，确定要选的课程。 查看成绩信息\r事实上很多人并不知道，教务有两个成绩信息的接口。 业务查询中的个人成绩查询和成绩类业务中的个人成绩查询在大部分内容中都是一致的，不过成绩类的信息更加齐全。进入后者，可以直接看到一些关于个人学分绩相关的 tag，一目了然。下面的表格内容则是课程的考试成绩信息。大概是这样的。关于详情内的信息大概如图。 可以发现，里面有关于排名的信息。然而如果没有进行评教的话大概是看不到相关信息的，因此还是尽早评教为好。评教相关这里按下不表，一学期花个 10 分钟就能解决。\n虽然部分课程没有详细信息，但是其实只是没有在网站前端显示而已。打开浏览器 f12 控制台，刷新一次页面之后可以发现一个名为 grcjcx 的请求，并不显然地这个接口实际上是个人成绩查询的拼音缩写。查看返回的 json 数据 可以发现，字段 pm （排名）直接可以看到，尽管并没有详情信息的按钮可以按。\n还有一些关于查看未公布（但是已经录入）的成绩的奇技淫巧——也算是教务的 bug。 在这里有一个成绩类申请的链接，点击进去之后可以发现 成绩复核的按钮。选择对应内容的可申请成绩，直接申请就能看到已经录入但是还没公布的成绩了。记得看完取消申请。 截止目前这个 bug 还在，不保证长期存在。\n其余相关的可提前查看信息\r相似操作可以查看考试时间，直接在成绩类申请的缓考页面中就能找到。（不过这个可能不是最终时间，有几率改动）\n学习进度\r进入主页面中 业务查询/个人成绩查询，可以选择学习进度查看目前的已修学分、排名。需要关注的是下一栏的学分类别要求。有一些课程需要修够特定数量的学分 (例如 23 届要求跨专业需要修满 10 学分)，就可以在这里查看目前已修的学分数量。 建议在选课前提前查看安排接下来的任务。更加详细的选课推荐请前往 hoa 正文查看对应内容。\n关于选课\r选课的入口在 进入之后可以直接选课。关于选什么课、什么课推荐请移步 hoa 正文部分，这里可能更偏重教务本身相关。一个比较有用的小 tip 是 右上角的小按钮展开之后可以选择忽略 0 余量课程与忽略冲突课程。否则你可能看到大量你选不了的课程（在跨专业中）。另外点入课程中可以看到一些课程相关的信息，这对于你是否选课很关键。有些课程有 70% 的考试，而有些课程只需要写论文。这些信息都可以在 点入的课程大纲中查看。\n选课细节\rtips: 本节技术相关，对新手可能不友好。接下来的内容有关逆向工程（web 注入），请时刻谨记网络安全法。\n本篇往下内容仅供学习参考，切勿用于非法用途。笔者不对仿造本文对任何尝试负责。\n教务选课的 api 名称叫做 addGouWuChe，也就是 添加购物车。这点已经懒得喷了，不过更有意思的是，教务似乎并没有对选课进行鉴权，你可以直接直选上体育课、选上别专业的课程 etc. 在不能选课的期间选课按钮是不能按的，但是右键点击检查 发现这个按钮实际上只是一个 disable，右键编辑为 html 删掉 disable属性 我们就可以按这个按钮了。当然了，教务还是对不在选课时间内做了检验的，你不需要担心选上不该选的课程。 但是刚才的请求也是切切实实的发出去了。因此在网络这一栏可以看到这个名为addGouWuChe的请求。整个请求体中有大量无效信息，这是因为教务的所有请求共用了一套表单，这也是教务奇卡无比的原因——做了大量无用的操作。我们看看其中有效的内容。一个必须的字段是xktjz，意思不明，该键值必须为rwtjzyx，意义不明。xn/xq 等等表示学年/学期比较好理解，而 p_id则是这个课程的唯一标识号。获取这个课程的标识号可以通过查看刚进入课程选课获取的表单 获取。而剩余最重要的是一个名为 p_xkfsdm 的键值对。经过猜测可以发现，原来意思是选课方式代码。经过长时间的测试发现\nsx-b-b -\u003e 跨专业课程体系\rxx-b-b -\u003e 限选\rbx-b-b -\u003e 必修\rfankzy-b-b -\u003e 方案内跨专业\r因此之前所说选别的学院的课程和直选体育课实际上就是这个字段。教务并没有对这个字段的严格检查，也就是你只需要找到特定体育课的 id，然后使用直选课程的请求体，更换为该体育课程的 id 就能直选上。当然我并不推荐你这么做——这可能有点危险，无论如何教务最后还是会做一些人工的检查。这里给一些我之前尝试的案例供参考（最后都退掉了 p1 是直选体育课，p2 是选上了建筑学院的毕业设计。建筑学院的毕业设计是我跨专业课程中对外人数为 0 的课程，替换为直选的键值对可以直接被判定为建筑学院的学生然后选上这门课。\n另外学校选课的极限频率大概在 2s/次，超过这个频率会显示请求过于频繁，不过不会被封禁，无需担心。\n最后，我写了一个选课加速器：hit course。用上了别忘了点个星星。\n更多技术相关\rtips: 接下来的内容有关逆向工程，请时刻谨记网络安全法。\n教务的网站实际上有两个端点，分别是校内访问和校外访问。我们日常使用的 web 端是校内访问的，而手机 app 是校外访问的。他们的端点分别在\nhttp://jw.hitsz.edu.cn/\rhttps://mjw.hitsz.edu.cn/\r可以查询 dns 发现，\n\u003e q mjw.hitsz.edu.cn mjw.hitsz.edu.cn. 5m A 219.223.236.18 mjw.hitsz.edu.cn. 5m AAAA 2001:250:3c0f:4003:dbdf:ec12::\r访问 mjw 会发现指向一个反向代理，该代理做了均衡负载，因此实际上在测试中手机端的性能反而比 web 要好一些。并且可以发现，实际上内网中走的是 http，而校外有 https 保护（并且内网的教务甚至明文传输密码），因此从性能和安全考虑我都更推荐使用手机端访问。\n如果你想看看教务具体发了什么包，你可以直接在 web 看 f12，你会很惊喜的发现大量的包均为拼音命名、大量毫无意义的信息，get 方法和 post 方法共用同一套表单 etc. 经过测试，走 mjw 路线的 api 可能不是同一套，当然 mobile 版本的教务系统安全防护依然很低，你很轻松就能抓到包，除了 https 以外没有任何的网络防护（例如双端证书校验/ssl pinning etc.），参考各种 https 的 mitm 方法即可。 想要直接给教务发包，可以通过两种手段，一是复用浏览器获取的 cookie，二是通过账号密码登录。复用 cookie 又分两种方式，直接在浏览器重发请求/复制浏览器请求 cURL 在本地更改重发，以及复用 cookie 自行实现请求客户端。两种方法都比较简单，这里按下不表。\n使用账号密码需要明确登陆流程。校内 web 端截止本文落笔使用一校三区的 sso 登陆。\n什么是 sso？ 单点登录（Single Sign-On, SSO）是一种身份验证机制，允许用户通过一次登录就可以访问多个相关但独立的系统，而不需要重复输入用户名和密码。SSO 的主要目的是简化用户体验并提高安全性。 简单来说，cookie 实际上是通过 sso 服务器获取的，之后与教务系统共享。因此在抢课高峰期被挤出事实上并非 sso 服务器失效，而是教务对 cookie 的验证超时导致的“session 已失效”假象。\n对 sso 有了解之后我们就可以完成登陆。我们使用账号密码往 sso 站点请求登陆，持久化所获取的 cookie 再请求教务的 api 即可。笔者使用 rust 编写了简单的 demo 对操作进行展示。\nuse reqwest::redirect::Policy; use reqwest::Client; use scraper::{Html, Selector}; use serde_json::Value; use std::collections::HashMap; use std::error::Error; #[tokio::main] async fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e { // new client, with cookie store let client = Client::builder() .redirect(Policy::limited(5)) .cookie_store(true) .build() .unwrap(); let response = client .get(\"https://ids.hit.edu.cn/authserver/combinedLogin.do?type=IDSUnion\u0026appId=ff2dfca3a2a2448e9026a8c6e38fa52b\u0026success=http%3A%2F%2Fjw.hitsz.edu.cn%2FcasLogin\") .send() .await? .text() .await?; let document = Html::parse_document(\u0026response); let input_selector = Selector::parse(\"form#authZForm input[type=hidden]\").unwrap(); let mut form_data = HashMap::new(); // username and password provide. form_data.insert(\"username\", username); // username form_data.insert(\"password\", password); // password for input in document.select(\u0026input_selector) { if let Some(name) = input.value().attr(\"name\") { if let Some(value) = input.value().attr(\"value\") { form_data.insert(name, value.to_string()); } } } let response = client .post(\"https://sso.hitsz.edu.cn:7002/cas/oauth2.0/authorize\") .form(\u0026form_data) .send() .await?; // 这一步结束之后拿到 cookie 就可以请求教务对应接口了 // 接下来可以进行各种操作... }\r接下来的操作自然是根据需求完成，直接访问接口即可。使用者可能需要有扎实的拼音功底来辨认完全不是人看的 api。\n最后，sso 对登陆次数进行限制。如果你频繁的登陆可能会被封禁。大概频率极限在 10 次/分钟。如果请求太多你可能会收到的短信/email： 文/ YinMo19，关于相关内容可以通过 Me@YinMo19.top 联系我。不过我看邮件有点佛系……","查看成绩信息#查看成绩信息":"","查看课程信息#查看课程信息":""},"title":"关于教务的两三事"},"/blog/how-to-use-mirrors-in-hitsz/":{"data":{"":"","什么是镜像站#什么是镜像站？":"","我是如何使用镜像站的#我是如何使用镜像站的？":"由 开源技术协会（OSA） 建设的 镜像站 其实从去年就开始运行了，但是目前只为各大实验室和开源技术协会的同学所使用，以至于身边的很多同学都仍在使用网上的各种清华换源、中科大换源教程，并且屡屡碰壁。这篇文章我想分享一下作为一名自动化的本科生，我们可以如何使用校内镜像站。\n什么是镜像站？\r顾名思义，镜像站就是将现有的网站镜像到自己的服务器上，一方面是为了加快网站的的访问速度，另一方面是为了对网页内容进行备份。我们日常会用到镜像站的场景包括但不限于：\n下载 Ubuntu、Arch 等 Linux 发行版本的安装镜像 使用 Anaconda 安装 Python 环境中的各种包 安装 ROS（机器人操作系统） 进行 Ubuntu 中各种包的更新 … 而由于众所周知的原因，国内往往很难访问到国际互联网的内容，当我们需要配置环境时，往往会碰到很多困难，这时候镜像站就从可选项变成必选项。但是国内各大面对公网的镜像站的质量往往参差不齐，而 OSA 推出的面向校内同学的镜像站却允许我们以数十兆的速度从内网获取资源，可以说把镜像站从一个必选项变成了一个最优解。\n我是如何使用镜像站的？\r就按照上面介绍的场景展开吧\n安装 Ubuntu\r很多同学会通过虚拟机或者双系统的方式安装 Ubuntu，但是首先都需要下载 Ubuntu 的安装镜像文件（.iso）。你可以在 mirrors.osa.moe 这里找到相应的发行版进行下载，如下图所示：\nUbuntu 软件源\r当你使用 sudo apt update 更新软件源的时候，报错最有可能的原因是你的网络问题，为此我们需要设置成自己的软件源，当你点开标题为 ubuntu 的链接的时候，OSA 会很贴心地为你跳转到使用帮助页面：https://mirrors-help.osa.moe/ubuntu/。\n按照使用帮助上的介绍配置即可，你需要修改的是 /etc/apt/sources.list 这个文件。\n在 使用官方安全更新软件源 选项中，我建议选择否，否则仍有可能遇到网络问题。\n其他\rAnaconda 和 ROS 的配置方法同样可以通过参考对应的使用帮助页面进行配置，ROS 在换好源后请从 官网教程 的 1.4 节开始安装。"},"title":"我是如何使用 OSA 镜像站的"},"/blog/markdown-and-latex/basic-of-latex-with-markdown/":{"data":{"":"","10极限#10、极限":"","11累加累乘及交集并集#11、累加、累乘及交集、并集":"","12上加帽上加点上加波浪带帽符号#12、上加帽、上加点、上加波浪（带帽符号）":"","13选取符号下括号上括号框选#13、选取符号（下括号、上括号、框选）":"","14矩阵#14、矩阵":"","15方程式序列#15、方程式序列":"","16条件表达式#16、条件表达式":"","17配置行高#17、配置行高":"","18数组与表格#18、数组与表格":"","19希腊字母#19、希腊字母":"","1公式的插入#1、公式的插入":"","20注释文字#20、注释文字":"","21特殊字符#21、特殊字符":"","22字体#22、字体":"","23文字颜色#23、文字颜色":"","24删除线#24、删除线":"关于 Markdown 的标题、段落、字体等样式的设置，请看这里。\n本文介绍如何在 Markdown 文档中使用 LaTeX 输入公式，也可做 LaTeX 速查手册之用。本文档按照以下顺序排列：公式样式（如分数、上下标等）- 希腊字母、特殊字符 - 字体及文字颜色格式 - 其他不常用命令。可先翻阅右侧的目录以大致了解文档结构。\n本文不作过多文字性描述，更多时候只提供 Typora 中可以简单实现的 LaTeX 示例代码。读者只需要在 Typora 中输入对应的代码，即可看到实时预览的效果。（所有的代码块都可以复制！将鼠标移至代码块上，会发现右上角出现复制图标，点击图标即可复制！）\n本文档目前尚在修改中，日后会加入更多的文字说明。\n读者若想进一步了解 LaTeX 这种排版方式并用它来编辑更多文档，可以参考以下内容：（这个将来或许也会写成一篇单独的文档）\n语法介绍：一份不太简短的 LaTeX2e 介绍与一份其实很短的 LaTeX 入门文档。 环境配置：请看这里。 1、公式的插入\r①行中公式\r对于 Typora，在设置-Markdown-Markdown 扩展语法中勾选“行内公式”就可以使用这个语法了。\n代码：\n$x=0$\r效果： $x=0$\n②独立公式\r代码：\n$$ x=0 $$\r效果： $$ x=0 $$\n2、上下标\r代码：\n$x^{y^z}=(1+e^x)^{-2xy^w}$ $x_1=x_2+2$ $\\underset{6}\\bigotimes$\r效果：\n$x^{y^z}=(1+e^x)^{-2xy^w}$\n$x_1=x_2+2$\n$\\underset{6}\\bigotimes$\n3、分数\r代码：\n$\\frac{a}{b}\\quad\\dfrac{a}{b}\\quad {a\\over b}$\r效果： $\\frac{a}{b}\\quad\\dfrac{a}{b}\\quad {a\\over b}$\n4、括号和分隔符\r代码：\n$\\langle\\quad\\rangle\\quad\\lceil\\quad\\rceil\\quad\\lfloor\\quad\\rfloor\\quad\\lbrace\\quad\\rbrace\\quad\\lVert\\quad\\rVert$ $f(x,y,z)=3y^2z\\left(3+\\dfrac{7x+5}{1+y^2}\\right)$ $\\left.\\dfrac{\\mathrm{d}u}{\\mathrm{d}x}\\right|_{x=0}$\r效果：\n$\\langle\\quad\\rangle\\quad\\lceil\\quad\\rceil\\quad\\lfloor\\quad\\rfloor\\quad\\lbrace\\quad\\rbrace\\quad\\lVert\\quad\\rVert$\n$f(x,y,z)=3y^2z\\left(3+\\dfrac{7x+5}{1+y^2}\\right)$\n$\\left.\\dfrac{\\mathrm{d}u}{\\mathrm{d}x}\\right|_{x=0}$​\n说明：\n\\quad代表空格 \\left( \\right)代表根据其所括起来的内容可变大小的括号，具体见下一点。 \\mathrm代表数学正体。 5、大括号和行标\r说明：使用\\left和\\right来创建自动匹配高度的()、[]、{}、.。在每个公式末尾使用\\tag{行标}来实现行标。\n代码：\n$$ f\\left( \\left[ \\dfrac{1+\\{x,y\\}}{\\left(\\dfrac{x}{y}+\\dfrac{y}{x}\\right)(u+1)}+a \\right] ^{\\dfrac{3}{2}} \\right) \\tag{行标} $$\r效果： $$ f\\left(\\left[\\dfrac{1+{x,y}}{\\left(\\dfrac{x}{y}+\\dfrac{y}{x}\\right)(u+1)}+a\\right]^{\\dfrac{3}{2}}\\right)\\tag{1} $$\n说明：如果你想将行内显示的分隔符也变大，也可以使用\\middle命令\n代码：\n$$ \\left\\langle q\\middle\\|\\dfrac{\\dfrac{x}{y}}{\\dfrac{u}{v}}\\middle|p\\right\\rangle $$\r效果： $$ \\left\\langle q\\middle|\\dfrac{\\dfrac{x}{y}}{\\dfrac{u}{v}}\\middle|p\\right\\rangle $$\n6、开方\r代码：\n$\\sqrt{2}\\quad\\sqrt[3]{2}$\r效果： $\\sqrt{2}\\quad\\sqrt[3]{2}$\n7、省略号与多点\r代码:（\\quad代表空格）\n$\\cdots\\quad\\ldots\\quad\\vdots\\quad\\ddots$\r效果： $\\cdots\\quad\\ldots\\quad\\vdots\\quad\\ddots$\n8、矢量和均值\r代码：\n$ \\overrightarrow{E(\\vec{r})} \\overleftarrow{E(\\vec{r})} \\overleftrightarrow{E(\\vec{r})} \\underrightarrow{E(\\vec{r})} \\underleftarrow{E(\\vec{r})} \\underleftrightarrow{E(\\vec{r})} \\overline{v}=\\bar{v} \\underline{v} $\r效果： $\\overrightarrow{E(\\vec{r})}\\quad\\overleftarrow{E(\\vec{r})}\\quad\\overleftrightarrow{E(\\vec{r})}\\quad\\underrightarrow{E(\\vec{r})}\\quad\\underleftarrow{E(\\vec{r})}\\quad\\underleftrightarrow{E(\\vec{r})}\\quad\\overline{v}=\\bar{v}\\quad\\underline{v}$\n9、积分\r代码：\n$$ \\iint\\limits_D\\left(\\dfrac{\\partial Q}{\\partial x}-\\dfrac{\\partial P}{\\partial y}\\right){\\rm d}x{\\rm d}y=\\oint\\limits_LP{\\rm d}x+Q{\\rm d}y $$\r效果： $$ \\iint\\limits_D\\left(\\dfrac{\\partial Q}{\\partial x}-\\dfrac{\\partial P}{\\partial y}\\right){\\rm d}x{\\rm d}y=\\oint\\limits_LP{\\rm d}x+Q{\\rm d}y $$\n10、极限\r代码：\n$\\lim\\limits_{n\\to\\infin}(1+\\dfrac{1}{n})^n=e$\r效果： $\\lim\\limits_{n\\to\\infin}(1+\\dfrac{1}{n})^n=e$\n11、累加、累乘及交集、并集\r$ \\sum\\limits_{i=1}^n\\dfrac{1}{n^2} \\prod\\limits_{i=1}^n\\dfrac{1}{n^2} \\bigcup\\limits_{i=1}^n\\dfrac{1}{n^2} \\bigcap\\limits_{i=1}^n\\dfrac{1}{n^2} $\r效果： $\\sum\\limits_{i=1}^n\\dfrac{1}{n^2}\\quad \\quad\\prod\\limits_{i=1}^n\\dfrac{1}{n^2}\\quad \\quad\\bigcup\\limits_{i=1}^n\\dfrac{1}{n^2}\\quad \\quad\\bigcap\\limits_{i=1}^n\\dfrac{1}{n^2}$\n12、上加帽、上加点、上加波浪（带帽符号）\r输入 显示 输入 显示 \\hat{xy} $\\hat{xy}$ \\widehat{xyz} $\\widehat{xyz}$ \\tilde{xy} $\\tilde{xy}$ \\widetilde{xyz} $\\widetilde{xyz}$ \\check{x} $\\check{x}$ \\breve{y} $\\breve{y}$ \\grave{x} $\\grave{x}$ \\acute{y} $\\acute{y}$ \\dot{x} $\\dot{x}$ \\ddot{x} $\\ddot{x}$ 13、选取符号（下括号、上括号、框选）\r输入 显示 输入 显示 \\fbox{a+b+c+d} $\\fbox{a+b+c+d}$ \\overbrace{xx\\cdots x}^{lots\\ of\\ x} $\\overbrace{xx\\cdots x}^{lots\\ of\\ x}$ \\underbrace{xx\\cdots x}_{lots\\ of\\ x} $\\underbrace{xx\\cdots x}_{lots\\ of\\ x}$ 14、矩阵\r①无框矩阵\r代码：\n$$ \\begin{matrix} 1\u0026x\u0026x^2\\\\ 1\u0026y\u0026y^2\\\\ 1\u0026z\u0026z^2\\\\ \\end{matrix} $$\r②边框矩阵\r说明：在开头将matrix替换为pmatrix、bmatrix、Bmatrix、vmatrix、Vmatrix。\n③带分割线的矩阵\r说明：可以使用cc|c来在一个三列矩阵中插入分割线。\n代码：\n$$ \\left[ \\begin{array}{cc|c} 1\u00262\u00263\\\\ 4\u00265\u00266 \\end{array} \\right] $$\r15、方程式序列\r说明：可以使用\\begin{align}...\\end{align}来创建一列整齐且默认右对齐的方程式序列。请注意{align}是自动编号的，使用{align*}来声明停止自动编号，也可以使用\\notag来取消特定行的自动编号。在需要的时候，你可以使用\\begin{equation}...\\end{equation}来强制表达式自动编号。\n代码： $$ \\begin{align} f(x)\u0026=1+1\\ \u0026=2 \\end{align} $$\n$$ \\begin{equation} \\left[ \\begin{array}{cc|c} 1\u00262\u00263\\ 4\u00265\u00266 \\end{array} \\right] \\end{equation} $$\n$$ \\begin{align} \\sqrt{37}=\\sqrt{\\dfrac{73^2-1}{12^2}}\\\\ \u0026=\\sqrt{\\dfrac{73^2}{12^2}\\cdot\\dfrac{73^2-1}{73^2}}\\\\ \u0026=\\sqrt{\\dfrac{73^2}{12^2}}\\sqrt{\\dfrac{73^2-1}{73^2}}\\notag\\\\ \u0026=\\dfrac{73}{12}\\sqrt{1-\\dfrac{1}{73^2}}\\\\ \\approx\\dfrac{73}{12}\\left(1-\\dfrac{1}{2\\cdot73^2}\\right)\\label{A} \\end{align} $$ *** $$ \\begin{align*} v+m\u0026=0\u0026\\text{Given}\\tag1\\\\ -w\u0026=-w+0\u0026\\text{additive identity}\\tag2\\\\ -w+0\u0026=-w+(v+w)\u0026\\text{equations $(1)$ and $(2)$} \\end{align*} $$\r你可以使用\\label{标签}来创建一个标签，就如上面的方程式序列中展示的那样，之后使用\\eqref{标签}引用你想引用的公式。如果不想要括号，可以输入\\ref{标签}。\n公式 1 和 2 的不同列之间存在间隔，如果你不想要，可以通过将align替换为alignat{1}来去除列间隔。\n16、条件表达式\r说明：使用\\begin{cases}来创造一组默认左对齐的条件表达式，在每一行插入\u0026来指定需要对齐的内容，并在每一行结尾处使用\\\\,以\\end{cases}结尾。\n代码：\n$$ f(n)= \\begin{cases} n/2,\u0026\\text{if $n$ is even}\\\\ 3n+1,\u0026\\text{if $n$ is odd} \\end{cases} $$\r17、配置行高\r说明：可以使用\\\\[2ex]语句替代该行末尾的\\\\来让编译器适配 , 其中[ex]指一个\"X-Height\" , 即 x 字母高度 , 也可以使用[3ex]或[4ex]等。\n代码：\n$$ f(n)= \\begin{cases} \\dfrac n2,\u0026\\text{if $n$ is even}\\\\[2ex] 3n+1,\u0026\\text{if $n$ is odd} \\end{cases}\\tag{适配[2ex]} $$ *** $$ f(n)= \\begin{cases} \\dfrac n2,\u0026\\text{if $n$ is even}\\\\ 3n+1,\u0026\\text{if $n$ is odd} \\end{cases}\\tag{不适配[2ex]} $$\r18、数组与表格\r说明：数组与表格均以\\begin{array}开头，并在其后定义列数及每一列的文本对齐方式，c l r分别代表居中、左对齐及右对齐。若要插入垂直分割线，在定义中插入|，若要插入水平分割线，在定义中加入\\hline。\n代码：\n$$ \\begin{array}{c|lcr} n\u0026\\text{left}\u0026\\text{center}\u0026\\text{right}\\\\ \\hline 1\u00260.24\u00261\u0026125\\\\ 2\u0026-1\u0026189\u0026-8\\\\ 3\u0026-20\u00262000\u00261+10i \\end{array} $$\r19、希腊字母\r语法 字母 语法 字母 语法 字母 \\Alpha(\\alpha) $\\Alpha(\\alpha)$ \\Beta(\\beta) $\\Beta(\\beta)$ \\Gamma(\\gamma) $\\Gamma(\\gamma)$ \\Epsilon(\\epsilon)\\varepsilon $\\Epsilon(\\epsilon)\\varepsilon$ \\Zeta(\\zeta) $\\Zeta(\\zeta)$ \\Eta(\\eta) $\\Eta(\\eta)$ \\Iota(\\iota) $\\Iota(\\iota)$ \\Kappa(\\kappa)\\varkappa $\\Kappa(\\kappa)\\varkappa$ \\Lambda(\\lambda) $\\Lambda(\\lambda)$ \\Nu(\\nu) $\\Nu(\\nu)$ \\Xi(\\xi) $\\Xi(\\xi)$ \\Omicron(\\omicron) $\\Omicron(\\omicron)$ \\Rho(\\rho)\\varrho $\\Rho(\\rho)\\varrho$ \\Sigma(\\sigma)\\varsigma $\\Sigma(\\sigma)\\varsigma$ \\Tau(\\tau) $\\Tau(\\tau)$ \\Phi(\\phi)\\varphi $\\Phi(\\phi)\\varphi$ \\Chi(\\chi) $\\Chi(\\chi)$ \\Psi(\\psi) $\\Psi(\\psi)$ \\Delta(\\delta) $\\Delta(\\delta)$ \\Theta(\\theta)\\vartheta $\\Theta(\\theta)\\vartheta$ \\Mu(\\mu) $\\Mu(\\mu)$ \\Pi(\\pi)\\varpi $\\Pi(\\pi)\\varpi$ \\Omega(\\omega) $\\Omega(\\omega)$ \\upsilon $\\upsilon$ \\ell $\\ell$ \\eth $\\eth$ \\hbar $\\hbar$ \\hslash $\\hslash$ \\mho $\\mho$ \\partial $\\partial$ 20、注释文字\r代码：\n$\\text{文字 abcd}abcd1234$\r效果：$\\text{文字 abcd}abcd1234$\n21、特殊字符\r①说明\r可以在字符前使用\\large或\\small以显示更大或更小的字符。 代码：\n${\\LARGE A}{\\Large A}{\\large A}A{\\small A}$\r效果：\n${\\LARGE A}{\\Large A}{\\large A}A{\\small A}$\n②关系运算符\r输入 显示 输入 显示 输入 显示 \\pm(\\mp) $\\pm(\\mp)$ \\times $\\times$ \\div $\\div$ \\nmid $\\nmid$ \\cdot $\\cdot$ \\mid $\\mid$ \\bigodot $\\bigodot$ \\bigotimes $\\bigotimes$ \\bigoplus $\\bigoplus$ \\ge $\\ge$ \\le $\\le$ \\ll $\\ll$ \\geqslant $\\geqslant$ \\leqslant $\\leqslant$ \\neq $\\neq$ \\approx $\\approx$ \\xlongequal{text} $\\xlongequal{text}$ \\triangleq $\\triangleq$ \\sim $\\sim$ \\doteq $\\doteq$ \\equiv $\\equiv$ \\cong $\\cong$ \\propto $\\propto$ \\parallel(\\ ) \\prec $\\prec$ \\pmod{2} $\\pmod{2}$ \\bmod $\\bmod{2}$ ③集合运算符\r输入 显示 输入 显示 输入 显示 \\emptyset $\\emptyset$ \\varnothing $\\varnothing$ \\subset $\\subset$ \\subseteq $\\subseteq$ \\subsetneq $\\subsetneq$ \\supset $\\supset$ \\supseteq $\\supseteq$ \\supsetneq $\\supsetneq$ \\bigcap $\\bigcap$ \\bigcup $\\bigcup$ \\setminus $\\setminus$ \\bigvee $\\bigvee$ \\bigwedge $\\bigwedge$ \\in $\\in$ \\notin $\\notin$ \\ni $\\ni$ ④三角运算符\r输入 显示 输入 显示 输入 显示 \\circ $\\circ$ \\bot $\\bot$ \\angle $\\angle$ \\degree $\\degree$ ⑤微积分运算符\r输入 显示 输入 显示 输入 显示 \\int $\\int$ \\iint $\\iint$ \\iiint $\\iiint$ \\oint $\\oint$ \\oiint $\\oiint$ \\prime(‘) $\\prime$ \\lim $\\lim$ \\infin $\\infin$ \\nabla $\\nabla$ \\grad ∇ ⑥逻辑运算符\r输入 显示 输入 显示 输入 显示 \\because $\\because$ \\therefore $\\therefore$ \\forall $\\forall$ \\exist $\\exist$ \\not\u003e $\\not\u003e$ \\not\u003c $\\not\u003c$ \\land $\\land$ \\lor $\\lor$ \\lnot $\\lnot$ \\top $\\top$ \\vdash $\\vdash$ \\vDash $\\vDash$ ⑨箭头符号\r输入 显示 输入 显示 输入 显示 \\leftarrow $\\leftarrow$ \\rightarrow $\\rightarrow$ \\leftrightarrow $\\leftrightarrow$ \\longleftarrow $\\longleftarrow$ \\longrightarrow $\\longrightarrow$ \\longleftrightarrow $\\longleftrightarrow$ \\Leftarrow $\\Leftarrow$ \\Rightarrow $\\Rightarrow$ \\Leftrightarrow $\\Leftrightarrow$ \\Longleftarrow $\\Longleftarrow$ \\Longrightarrow $\\Longrightarrow$ \\Longleftrightarrow $\\Longleftrightarrow$ \\uparrow $\\uparrow$ \\downarrow $\\downarrow$ \\updownarrow $\\updownarrow$ \\Uparrow $\\Uparrow$ \\Downarrow $\\Downarrow$ \\Updownarrow $\\Updownarrow$ \\to $\\to$ \\swarrow $\\swarrow$ \\nearrow $\\nearrow$ \\gets $\\gets$ \\searrow $\\searrow$ \\nwarrow $\\nwarrow$ \\mapsto $\\mapsto$ \\rightrightarrows $\\rightrightarrows$ ⑩空格\r22、字体\r语法：${\\字体{需要转换的字符}}$\n在公式中的对应标记为：\\mathrm（数学粗体，如$\\mathbf{R}$）、\\mathcal（数学花体，如$\\mathcal{P}$）、\\mathbb（数学黑板粗体，如$\\mathbb{R}$）。\n23、文字颜色\r适用新旧浏览器 代码： $\\color{颜色}{文字}$\r输入 显示 输入 显示 输入 显示 black $\\color{black}{color}$ grey $\\color{grey}{color}$ silver $\\color{silver}{color}$ white $\\color{white}{color}$ maroon $\\color{maroon}{color}$ red $\\color{red}{color}$ yellow $\\color{yellow}{color}$ lime $\\color{lime}{color}$ olive $\\color{olive}{color}$ green $\\color{green}{color}$ teal $\\color{teal}{color}$ auqa $\\color{auqa}{color}$ blue $\\color{blue}{color}$ navy $\\color{navy}{color}$ purple $\\color{purple}{color}$ fuchsia $\\color{fuchsia}{color}$ 适用新版浏览器 代码： $\\color{#rgb}{文字}$ (注：其中 r、g、b 可以输入 0~9 和 a~f 来分别表示红色、绿色和蓝色的纯度)\r输入 输出 输入 输出 输入 输出 输入 输出 #000 $\\color{#000}{color}$ #005 $\\color{#005}{color}$ #00A $\\color{#00A}{color}$ #00F $\\color{#00F}{color}$ #500 $\\color{#500}{color}$ #505 $\\color{#505}{color}$ #50A $\\color{#50A}{color}$ #50F $\\color{#50F}{color}$ #A00 $\\color{#A00}{color}$ #A05 $\\color{#A05}{color}$ #A0A $\\color{#A0A}{color}$ #A0F $\\color{#A0F}{color}$ #F00 $\\color{#F00}{color}$ #F05 $\\color{#F05}{color}$ #F0A $\\color{#F0A}{color}$ #F0F $\\color{#F0F}{color}$ #050 $\\color{#050}{color}$ #055 $\\color{#055}{color}$ #05A $\\color{#05A}{color}$ #05F $\\color{#05F}{color}$ #550 $\\color{#550}{color}$ #555 $\\color{#555}{color}$ #55A $\\color{#55A}{color}$ #55F $\\color{#55F}{color}$ #A50 $\\color{#A50}{color}$ #A55 $\\color{#A55}{color}$ #A5A $\\color{#A5A}{color}$ #A5F $\\color{#A5F}{color}$ #F50 $\\color{#F50}{color}$ #F55 $\\color{#F55}{color}$ #F5A $\\color{#F5A}{color}$ #F5F $\\color{#F5F}{color}$ #0A0 $\\color{#0A0}{color}$ #0A5 $\\color{#0A5}{color}$ #0AA $\\color{#0AA}{color}$ #0AF $\\color{#0AF}{color}$ #5A0 $\\color{#5A0}{color}$ #5A5 $\\color{#5A5}{color}$ #5AA $\\color{#5AA}{color}$ #5AF $\\color{#5AF}{color}$ #AA0 $\\color{#AA0}{color}$ #AA5 $\\color{#AA5}{color}$ #AAA $\\color{#AAA}{color}$ #AAF $\\color{#AAF}{color}$ #FA0 $\\color{#FA0}{color}$ #FA5 $\\color{#FA5}{color}$ #FAA $\\color{#FAA}{color}$ #FAF $\\color{#FAF}{color}$ #0F0 $\\color{#0F0}{color}$ #0F5 $\\color{#0F5}{color}$ #0FA $\\color{#0FA}{color}$ #0FF $\\color{#0FF}{color}$ #5F0 $\\color{#5F0}{color}$ #5F5 $\\color{#5F5}{color}$ #5FA $\\color{#5FA}{color}$ #5FF $\\color{#5FF}{color}$ #AF0 $\\color{#AF0}{color}$ #AF5 $\\color{#AF5}{color}$ #AFA $\\color{#AFA}{color}$ #AFF $\\color{#AFF}{color}$ #FF0 $\\color{#FF0}{color}$ #FF5 $\\color{#FF5}{color}$ #FFA $\\color{#FFA}{color}$ #FFF $\\color{#FFF}{color}$ 24、删除线\r说明：使用\\require{cancel}声明，再使用\\cancel{字符}、\\bcancel{字符}、\\xcancel{字符}、\\cancelto{字符}{字符}来实现各种片段删除线效果。\n代码：\n$$ \\require{cancel}\\begin{array}{r1} \\verb|y+\\cancel{x}|\u0026y+\\cancel{x}\\\\ \\verb|y+\\cancel{y+x}|\u0026y+\\cancel{y+x}\\\\ \\verb|y+\\bcancel{x}|\u0026y+\\bcancel{x}\\\\ \\verb|y+\\xcancel{x}|\u0026y+\\xcancel{x}\\\\ \\verb|y+\\cancelto{0}{x}|\u0026y+\\cancelto{0}{x}\\\\ \\verb+\\frac{1\\cancel9}{\\cancel95}=\\frac15+\u0026\\frac{1\\cancel9}{\\cancel95}=\\frac15\\\\ \\end{array} $$\r说明：使用\\require{enclose}来允许整段删除线的显示，再使用\\enclose{删除线效果}{字符}来使用各种整段删除线效果。其中，删除线效果有horizontalstrike、verticalstrike、updiagonalstrike和downdiagonalstrike,可以叠加使用。\n代码：\n$$ \\require{enclose}\\begin{array}{r1} \\verb|\\enclose{horizontalstrike}{x+y}|\u0026\\enclose{horizontalstrike}{x+y}\\\\ \\verb|\\enclose{verticalstrike}{\\frac xy}|\u0026\\enclose{verticalstrike}{\\frac xy}\\\\ \\verb|\\enclose{updiagonalstrike}{x+y}|\u0026\\enclose{updiagonalstrike}{x+y}\\\\ \\verb|\\enclose{downdiagonalstrike}{x+y}|\u0026\\enclose{downdiagonalstrike}{x+y}\\\\ \\verb|\\enclose{horizontalstrike,updiagonalstrike}{x+y}|\u0026\\enclose{horizontalstrike,updiagonalstrike}{x+y}\\\\ \\end{array} $$","2上下标#2、上下标":"","3分数#3、分数":"","4括号和分隔符#4、括号和分隔符":"","5大括号和行标#5、大括号和行标":"","6开方#6、开方":"","7省略号与多点#7、省略号与多点":"","8矢量和均值#8、矢量和均值":"","9积分#9、积分":""},"title":"在 Markdown 文档中使用 LaTeX 输入公式"},"/blog/markdown-and-latex/getting-started-with-markdown-in-typora/":{"data":{"":"","一标题#一、标题":"","七链接#七、链接":"","三文字显示#三、文字显示":"","九图片插入#九、图片插入":"","二段落#二、段落":"","五区块显示#五、区块显示":"","八脚注#八、脚注":"","六代码显示#六、代码显示":"","十一流程图#十一、流程图":"","十二其他显示效果#十二、其他显示效果":"","十表格#十、表格":"","参考资料#参考资料":"Typora 是一款支持实时预览的 Markdown 文本编辑器。为了保证良好的 Markdown 编辑体验，我们建议您先安装 Typora 后再来阅读之后的教程。同时，由于 Markdown 语法较为简单，本文不作过多文字性描述，更多时候只提供示例的 Markdown 代码。读者只需要在 Typora 中输入对应的代码，即可看到实时预览的效果。（所有的代码块都可以复制！将鼠标移至代码块上，会发现右上角出现复制图标，点击图标即可复制！）\n读者也可将本文档作为 Markdown 语法速查手册使用。\n关于在 Markdown 中利用 LaTeX 书写数学公式的教程，请看这里。\n一、标题\r语法：# (一级标题) ## (二级标题) ### (三级标题) ……\n代码：\n## 这是二级标题 ### 这是三级标题\r效果：\n这是二级标题\r这是三级标题\r快捷键：\nCtrl+ 数字 1~6 可以快速将选中的文本调成对应级别的标题 Ctrl+0 可以快速将选中的文本调成普通文本 Ctrl+ 加号/减号对标题级别进行加减 二、段落\r1、换行\r段落之间空一行，才表示换行。\n示例代码：\n这是一个段落 这是一个段落\r效果：\n这是一个段落\n这是一个段落\n若写为：\n单词 1 单词 2\r则两单词间仅有空格：\n单词 1 单词 2\n2、分割线\r语法： —或者*** 加上 回车\n代码：\n---\r或者\n***\r效果：\n三、文字显示\r1、字体\r语法：\n粗体：用一对双星号包裹 也可用\u003cb\u003e待加粗的文字\u003c/b\u003e 粗斜体：用一对三星号包裹 下划线：用一对 u 标签包裹 斜体：用一对单星号包裹 也可用\u003ci\u003e待倾斜的文字\u003c/i\u003e 以下两个功能并非所有编辑器都支持：\n高亮：用一对双等号包裹\n可以用一对 mark 标记（HTML 语法）来实现高亮。 对于 Typora，在设置-Markdown-Markdown 扩展语法中勾选“高亮”就可以使用这个语法了。 删除线：用一对双飘号包裹（有的并不支持）\n代码：\n**这是粗体** ***这是粗斜体*** ~~这是删除线~~ \u003cu\u003e这是下划线\u003c/u\u003e *这是斜体* \u003cmark\u003e这是高亮\u003c/mark\u003e\r效果： 这是粗体 这是粗斜体 这是删除线 这是下划线 这是斜体 这是高亮\n快捷键:（Typora）\n加粗：Ctrl+B 删除线：Shift+Alt+5 下划线：Ctrl+U 斜体：Ctrl+I 2、上下标\r方法 1：（不一定对所有编辑器都适用。对于 Typora，在设置-Markdown-Markdown 扩展语法中勾选“下标”、“上标”就可以使用这个语法了）\nx^2^ H~2~O\r方法 2：（对所有编辑器都适用）\nx\u003csup\u003e2\u003c/sup\u003e H\u003csub\u003e2\u003c/sub\u003eO\r效果：\nx2 H2O\n3、特殊字符（转义）\r使用转义字符\\。例如若要输入行内代码分隔符`，就要使用\n\\`\r4、文本居中\r代码\n\u003ccenter\u003e内容\u003c/center\u003e\r效果\n内容\r四、列表\r1、无序列表\r语法：*/-/+ (空格) 文字\n只有同一级别\r* 苹果 * 香蕉 * 橘子\r效果：\n苹果 香蕉 橘子 有多个级别\r只需在下一级别前添加制表符（Tab）或空格即可。\n* 一级分类 * 二级分类 * 三级分类\r效果：\n一级分类 二级分类 三级分类 快捷键：Ctrl+Shift+]（增加缩进级别）与 Ctrl+Shift+ [（减小缩进级别）\n2、有序列表\r语法：数字+.+空格\n代码：\n1. 第一个标题 2. 第二个标题 3. 第三个标题 * 子内容 1 * 子内容 2 4. 第四个标题\r效果：\n第一个标题 第二个标题 第三个标题 子内容 1 子内容 2 第四个标题 快捷键：Ctrl+Shift+]（增加缩进级别）与 Ctrl+Shift+ [（减小缩进级别）\n3、任务列表\r代码：\n- [ ] 吃早餐 - [x] 背单词\r效果:\n吃早餐 背单词 五、区块显示\r语法：\u003e+回车，每多一个\u003e就加一层缩进级别。\n代码:\n\u003e这是最外层区块 \u003e \u003e\u003e这是内层区块 \u003e \u003e\u003e\u003e这是最内层区块\r效果:\n这是最外层区块\n这是内层区块\n这是最内层区块\n六、代码显示\r1、行内代码\r代码:\n`int a=0;`\r效果: int a=0;\n快捷键: Ctrl+Shift+`\n2、代码块\r以三个`开头，三个`结尾。\n代码示例1:（C代表代码的语言，会根据它来确定高亮代码的哪些部分）\n```C int main(){ printf(\"Hello World!\"); return 0; } ```\r效果：\nint main(){ printf(\"Hello World!\"); return 0; }\r代码示例2:\n```python def hello_world(): print(\"hello world!\") ```\r效果：\ndef hello_world(): print(\"hello world!\")\r快捷键: Ctrl+Shift+K\n七、链接\r代码:\nwww.baidu.com [百度一下](https://www.baidu.com) [百度一下](https://www.baidu.com \"https://www.baidu.com\")\r效果: www.baidu.com 百度一下 百度一下\n快捷键: Ctrl+K\n八、脚注\r说明: 对文本进行解释说明。\n使用方法：在需解释的文本后跟上[^文本]，下一行接上[^文本]:脚注内容即可。\n代码：\n这是一个技术[^①] [^①]: 这是一个非常好用的框架。\r效果: 这是一个技术1\n九、图片插入\r语法：![不显示的文字,仅是给写作者自己看的](图片路径 \"图片标题（在下面显示）\") 示例代码:\n![GitHub Logo](https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png \"Github logo\")\r效果： Github logo\r若要实现缩放，则需借助 HTML 语法。下面代码将上图缩小到原来的33%。\n\u003cimg src=\"https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png\" alt=\"GitHub Logo\" title=\"Github logo\" style=\"zoom:33%;\" /\u003e\r效果： 快捷键: Ctrl+Shift+I\n十、表格\r代码:\n| 1 | 2 | 3 | | :--- | :--: | ---: | | 4 | 5 | 6 | | 7 | 8 | 9 | | 10 | 11 | 12 |\r效果:\n1 2 3 4 5 6 7 8 9 10 11 12 若需实现合并单元格等高级特性，则需借助HTML语法。\n\u003cfigure\u003e\u003ctable\u003e \u003cthead\u003e \u003ctr\u003e\u003cth\u003e序号\u003c/th\u003e\u003cth\u003e列 1\u003c/th\u003e\u003cth\u003e列 2\u003c/th\u003e\u003cth\u003e列 3\u003c/th\u003e\u003cth\u003e列 4\u003c/th\u003e\u003cth\u003e列 5\u003c/th\u003e\u003cth\u003e列 6\u003c/th\u003e\u003cth\u003e列 7\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003eA\u003c/td\u003e\u003ctd\u003e\u003ca href=\"https://baidu.com/\"\u003e百度\u003c/a\u003e\u003c/td\u003e\u003ctd rowspan='3'\u003e使用 rowspan 合并这几行的单元格，注意下面几行所对应这一列的单元格不要写！\u003c/td\u003e\u003ctd\u003e3.0\u003c/td\u003e\u003ctd\u003e48\u003c/td\u003e\u003ctd\u003e36\u003c/td\u003e\u003ctd\u003e12\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003eB\u003c/td\u003e\u003ctd\u003e\u003ca href=\"https://bing.com\"\u003e必应\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e3.0\u003c/td\u003e\u003ctd colspan='2'\u003e使用 colspan 合并这两列的单元格。注意右面几行所对应这一行的单元格不要写！\u003c/td\u003e\u003ctd\u003e48\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e3\u003c/td\u003e\u003ctd\u003eC\u003c/td\u003e\u003ctd\u003e\u003ca href=\"https://github.com\"\u003eGitHub\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e2.0\u003c/td\u003e\u003ctd colspan='2' rowspan='2'\u003e同时使用 rowspan 和 colspan 合并行列\u003c/td\u003e\u003ctd\u003e8\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e4\u003c/td\u003e\u003ctd\u003eD\u003c/td\u003e\u003ctd\u003e这格没有链接\u003c/td\u003e\u003ctd\u003e\u0026nbsp;\u003c/td\u003e\u003ctd\u003e2.0\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e\u003c/figure\u003e\r效果：\n序号列1列2列3列4列5列6列7\r1A百度使用rowspan合并这几行的单元格，注意下面几行所对应这一列的单元格不要写！3.0483612\r2B必应3.0使用colspan合并这两列的单元格。注意右面几行所对应这一行的单元格不要写！48\r3CGitHub2.0同时使用rowspan和colspan合并行列8\r4D这格没有链接 2.0\r快捷键: Ctrl+T\n十一、流程图\r对于Typora，在设置-Markdown-Markdown扩展语法中，勾选“图表”就可以使用这个语法了。\n1、横向流程图\r代码:\n```mermaid graph LR A[方形]==\u003eB(圆角) B==\u003eC{条件 a} C--\u003e|a=1|D[结果 1] C--\u003e|a=2|E[结果 2] F[横向流程图] ```\r效果：\ngraph LR\rA[方形]==\u003eB(圆角)\rB==\u003eC{条件a}\rC--\u003e|a=1|D[结果1]\rC--\u003e|a=2|E[结果2]\rF[横向流程图]2、竖向流程图\r代码：\n```mermaid graph TD A[方形]==\u003eB(圆角) B==\u003eC{条件 a} C--\u003e|a=1|D[结果 1] C--\u003e|a=2|E[结果 2] F[竖向流程图] ```\r效果：\ngraph TD\rA[方形]==\u003eB(圆角)\rB==\u003eC{条件a}\rC--\u003e|a=1|D[结果1]\rC--\u003e|a=2|E[结果2]\rF[竖向流程图]十二、其他显示效果\r1、表情符号（emoji）\r代码：\n:happy:、:cry:、:man:\r效果： 2、快捷键显示\r代码：\n\u003ckbd\u003e内容\u003c/kbd\u003e\r效果： 内容\n3、填充的黑色箭头\r代码：\n\u0026#x27A4;\r效果： ➤\n参考资料\r【Typora 教程】手把手教你如何用 Typora 撰写笔记 这是一个非常好用的框架。 ↩︎","四列表#四、列表":"","这是二级标题#这是二级标题":""},"title":"在 Typora 中快速上手 Markdown"},"/blog/markdown-and-latex/latex-setup/":{"data":{"":"","#":"返回 Markdown 文章主页\n分两部分：编译器和编辑器。\n编译器配置\r需要安装 TeXLive 或 MiKTeX。不要再用 CTeX 套装了。\nTeXLive 的安装稍麻烦些，可看文章 1+ 文章 2（Linux、WSL、Windows 均适用）；或文章 3的前半部分（Windows）。 MiKTeX 的安装非常简单，可参考这篇文章的第 1、2 点。但据说在 Linux 下经常报错（待补充）。 TeX Live 和 MiKTeX 的区别，详见一份不太简短的 LaTeX2e 介绍附录 A 及LaTeX 配置安装大对比。个人建议，Linux 用户使用 TeX Live，Windows 用户使用 MiKTeX。 Windows 下，安装其中之一后，就会有个纯文本式的编辑器 Texworks，很简洁，但是没有自动补全。 编辑器配置\r使用 TexStudio： Windows：TeX Live 和 TeXstudio 的下载、安装配置及使用，该教程也适用于 MiKTeX 用户。 Linux：（待补充） 使用 Visual Studio Code： Windows：Visual Studio Code \u0026 TeX Live 配置 LaTeX。 Linux：文章 1 （LaTeX Workshop 的 settings.json 文件配置，可结合上一行这篇文章） LaTeX Workshop 扩展的安装文档可参看：Install · LaTeX-Workshop Wiki。文档中明确提及’‘We strongly recommend TeX Live’’. 上述教程即为基于 TeX Live 的教程。 若利用 MiKTeX，同样可参考上述教程，区别仅在于：在 Windows 系统中，如果编译时用到 latexmk，则需额外安装Strawberry Perl for Windows（若不用，则无需理会）。要检验 Perl 是否安装正确，可参考这篇文章的第 3 点。Ubuntu 发行版自带 Perl，故无需担心。 在 Windows 系统中，使用 WSL 可以加速编译，环境配置可参考：文章 1与在 WSL 中安装 LaTeX。关于速度对比的更多信息，可参看：LaTeX 配置安装大对比。 "},"title":"LaTeX 环境配置"},"/blog/master-phd-course-selection/":{"data":{"":"","公共课#公共课":"","关于本研共通课#关于本研共通课":"","学科核心课#学科核心课":"","必修环节#必修环节":"控制学科的硕士、博士分为学术学位研究生（以下简称「学硕」「学博」）和专业学位研究生（以下简称「专硕」「专博」），前者专业代码为 0811，学科名称是「控制科学与工程」；后者专业代码为 0854，学科名称是「电子信息 - 控制工程」。二者的选课学分要求有所不同，有些课程还有特殊注意事项，下面为大家解析。\n说明：本文参考的是教务部发布的 2024-2025 学年硕士研究生培养方案。请注意时效性。 最新资讯，见于以下链接：\n培养方案 - 哈尔滨工业大学（深圳）教务部\n控制科学与工程学科研究生培养方案 - 哈尔滨工业大学（深圳）教务部\n公共课\r这方面，学术型和专业型是相同的。\n课程编号 课程名称 学时（课内/实验） 学分 开课时间 备注 GEIP4004 新时代中国特色社会主义理论与实践 32 2 秋季 必修 GEIP4002 自然辩证法概论 16 1 春季 必修 GEIP4003 中国马克思主义与当代 32 2 春季 博士学位必修 英语 32 2 秋/春 必修 前两门都是必修的；博士学位还要修第三门；对于英语课，如果某些语言类考试（如六级、雅思、托福等）达到一定水平，可以申请免修。具体文件见于 哈尔滨工业大学（深圳）研究生第一外国语（英语）免修办法（2023 秋）- 哈尔滨工业大学（深圳）教务部。\n最常见的情况是：全国大学英语六级 CET-6 考试 550 分及以上；满分为 120 分的 TOEFL iBT 考试达到 80 分及以上；满分为 9 分的 IELTS 考试达到 6.5 分及以上；满分为 340 分的 GRE 考试达到 300 分及以上；满分为 800 分的 GMAT 考试达到 650 分及以上。这几项的成绩有效期为 5 年。\n关于本研共通课\r确认保研到本校的学生，在大四的时候可以选下面表格中标有「本研共通」字样的课程。成绩合格后，到研一时，可以认定这些课程的学分，这样研一就不用重新修这些课程，能减轻一些学业压力。关于这些课程，有如下注意事项：\n在选课时，这些课程有的放在「推免生选课」的栏目下，有的放在 「限选」 的栏目下（注意，不仅仅有「推免生选课」！）。前者，一旦选课，那么到研一时该课程成绩将直接被记录在册，无法重新修读；后者，到研一时，可以选择认定或者不认定，如果感觉成绩不理想（对奖学金评定有影响），仍有放弃认定重新修读的空间。 注意这些课程在研究生培养方案中的类别，尽量不要选过多课而超出学分要求，以免给大四生活增加过大压力。笔者就选多了一门课，不过这样也带来了择优认定的好处 学科核心课\r课程编号\r课程名称\r学时（课内/实验）\r学分\r开课时间\r备注\rMATH4001\r矩阵分析\r32\r2\r秋季\r学硕、学博：数理类课程 ≥ 2 门\n专硕、专博：数理类课程 ≥ 1 门\n其中数值分析为本研共通课\rMATH4002\r优化算法\r32\r2\r秋季\rMATH4004\r数值分析\r32\r2\r秋季\rMATH4008\r随机过程\r32\r2\r秋季\rMATH5004\r实分析\r32\r2\r春季\rAUTO5001\r线性系统理论\r32\r2\r秋季\r本研共通\rAUTO5002\r系统辨识\r32\r2\r春季\r本研共通\rAUTO5023\r凸优化与最优控制\r32\r2\r秋季\r本研共通\rAUTO5004\r鲁棒控制\r32\r2\r秋季\r本研共通\rAUTO5005\r非线性与自适应控制\r32\r2\r秋季\r本研共通\rAUTO5006\r计算机视觉\r28/4\r2\r秋季\rAUTO5008\r机器人学\r28/4\r2\r秋季\rAUTO5014\r机器学习\r28/4\r2\r春季\rAUTO6005\r机器人控制\r32\r2\r春季\r博士学位核心课\rAUTO6007\r强化学习\r32\r2\r春季\rAUTO6006\r深度学习\r24/8\r2\r春季\rAUTO6008\r分布式协同控制\r32\r2\r春季\rAUTO6009\r机器人学中的数学\r32\r2\r春季\rWRCO4024\r学术规范及论文写作\r16\r1\r春季\r必修\rPQ4012\r工程伦理\r16\r1\r春季\r专硕、专博必修\r学硕\r不少于 9 学分。其中，数理类课程 ≥ 2 门（4 学分），《学术规范及论文写作》必修（1 学分），于是，剩下的课程（从 AUTO5001 开始的 8 门课）至少选 两门 即可。当然，也可以选择多修数理类课程。\n专硕\r不少于 9 学分。其中，数理类课程 ≥ 1 门（2 学分），《学术规范及论文写作》、《工程伦理》必修（共 2 学分），于是，剩下的课程（从 AUTO5001 开始的 8 门课）至少选 三门 即可。当然，也可以选择多修数理类课程。\n学博\r不少于 12 学分，且应修读不少于 4 学分的博士层次学科核心课（课程编号第 5 位为 6 的课程，如 AUTO6006）。其中，数理类课程 ≥ 2 门（4 学分），《学术规范及论文写作》必修（1 学分），于是，剩下的课程（从 AUTO5001 开始的 13 门课）至少选 4 门 ，并且课程编号第 5 位为 6 的课程至少选 两门 即可。\n专博\r不少于 12 学分，且应修读不少于 2 学分的博士层次学科核心课（课程编号第 5 位为 6 的课程，如 AUTO6006）。其中，数理类课程 ≥ 1 门（2 学分），《学术规范及论文写作》、《工程伦理》必修（共 2 学分），于是，剩下的课程（从 AUTO5001 开始的 13 门课）至少选 4 门 ，并且课程编号第 5 位为 6 的课程至少选 一门 即可。\n选修课\r详见下面链接中的「附录 1：各专业硕士层次选修课程模块.rar」和「附录 2：各专业博士层次选修课程模块.rar」\n7.控制科学与工程学科研究生培养方案 - 哈尔滨工业大学（深圳）教务部\n学硕、学博的要求：不少于 8 学分，其中《职业伦理》（1 学分）必修。\n专硕、专博的要求：不少于 5 学分，其中管理类课 ≥ 2 学分。\n选修课中目前只有《最优估计》是本研共通课。\n必修环节\r课程编号 课程名称 学时 学分 备注 1.5 学年综合测评 - - 学硕、学博必修 AUTO6991 学术活动 - 1 学博必修 AUTO5993 毕业论文开题 - 1 必修 AUTO5994 学位论文开题 - 1 必修 AUTO5996 专业实践 - 3 专硕、专博必修 点此展开/收起专业实践要求\r（1）可以在校内导师指导下参加具有工程应用背景的科研项目，也可以到专业指定的联合培养单位或实习单位进行主题明确、内容明确、计划明确的系统化实践训练，专业实践时间6 个月以上。对校内实践的学生实行单导师制。导师负责指导学生的课程学习、实践教学和学位论文。对校外实践的学生实行双导师制，校内导师负有工程硕士研究生指导的主要责任，主要指导学生的课程学习和学位论文；企业导师主要指导学生实践环节的学习。完成实践环节后，学生需撰写和提交专业实践报告（不少于 3000 字），完成的实践成果需满足实践任务设定要求，并完成知识产权申请（学生为第一发明人，哈尔滨工业大学（深圳）为申请人），通过认定可获得专业实践 3 学分。\n（2）学校及学院开设系列创新实践项目，不同的项目根据工作量及实施难度分别对应2-3 学分，学生可以根据个人兴趣和研究方向自由选修实践项目（可以跨专业选课），通过完成创新实践项目获得相应学分。\n（3）学生参加国家、省以及国内外权威机构组织的创新创业大赛获奖，可 申请认定奖励学分，多次获奖时，只按最高奖项计分。省部级一等奖及以上 1.5 学分，二等奖、三等奖 1 学分；国家级一等奖及以上 2.5 学分，二等奖、三等奖 2 学分。\n点此展开/收起申请博士学位学术活动的要求\r参加 5 次以上的学术研讨活动（专题讲座、学术研讨会、学术年会、国际会议等等），其中包括至少 3 次校外学术报告（参加人数在 20 人以上，其中至少 1 次使用外文），做学术报告应有书面材料，交导师签字认可后可获得该学分（如有疫情影响，可线上参会，但需提供参会截图 3-5 张）。","选修课#选修课":""},"title":"24 级控制科学与工程研究生选课指南"},"/blog/privileges-with-edu-email/":{"data":{"":"","1-编程相关#1. 编程相关":"","2-硬件相关#2. 硬件相关":"","3-数据分析#3. 数据分析":"许多工程、科研用的商业软件，尤其是国外的软件，如果购买商用的正版，往往价格不菲。 但是好在许多软件厂商都会提供其产品的免费学生版或教育版，通过学校邮箱即可申请使用。\n笔者整理了一些自动化专业学生常用到的、可用学生邮箱申请教育版的免费软件清单（我们亲自测试申请了以下所有许可证）。 也欢迎大家在评论区补充，我会及时更新到正文中。\n1. 编程相关\rGitHub\r申请链接：以学生身份申请 GitHub Global Campus - GitHub 文档\n申请 GitHub Global Campus，相当于：\n将 GitHub 个人账户升级为 PRO 获得 GitHub Copilot 获得包含 JetBrains 在内的 Student Developer Pack 中的权益 GitHub Copilot 并非唯一的 AI 代码助手，它也有其他免费的替代品，例如 TabNine，Codeium 等。\nJetBrains\r申请链接：免费教育许可证 - JetBrains\nJetBrains 是来自捷克的软件开发公司，针对许多编程语言提供了一系列的 IDE，例如面向 Java 的 IntelliJ IDEA、面向 Python 的 PyCharm、面向 C++ 的 CLion 等。\n不巧的是，HIT 位于 JetBrains 的 stoplist 中。 因此在上述申请链接直接使用学生邮箱会申请失败；即使使用 GitHub Student Developer Pack 登录也可能遭到拒绝。\n解决办法： 使用 GitHub Student Developer Pack 登录遭到拒绝的原因是 JetBrains 发现你的 GitHub 用户中含有「xxx@stu.hit.edu.cn」的邮箱。 因此，你可以临时将学生邮箱从你的 GitHub 账户中移除，再使用 GitHub 申请 JetBrains 教育许可证；等到需要更新你的 GitHub 学生认证时再将学生邮箱添加回去。 使用学信网的学籍证明申请 JetBrains 教育许可证。 参考「Jetbrains 学生授权获取指南 - 知乎」中的流程。 Qt\r申请链接：Qt Educational Licenses for Students and Teachers - Qt\nQt 是一个跨平台的 C++ GUI 库，可以用于开发桌面应用、嵌入式应用、移动应用等。 Qt 教育许可证可以免费为用户提供 Qt 的商业专业级功能。\n2. 硬件相关\rAltium Designer\r申请链接：Altium Student Lab - Altium\nAltium Designer 是一款电子设计自动化软件，用于电路原理图、PCB、FPGA 设计，由 Altium Ltd. 开发。\nAutodesk\r申请链接：Autodesk 教育和学生访问权限 - Autodesk\nAutodesk 是一家专业的 CAD 软件公司，旗下的软件包括 AutoCAD, 3ds Max, Maya 等。\nAutodesk 的教育访问权限允许用户免费获得其绝大多数软件产品，包括以上 3 项。\n3. 数据分析\rMATLAB?\r2020 年，HIT 被美国禁止使用 MATLAB。\n考虑使用 GNU Octave 作为在公开研究中的替代。 Python 也可以胜任 MATLAB 除去 Simulink 之外的大部分工作。\n也可以前往淘宝购买正版成品账号，价格在 20 元左右，关键词 MATLAB 正版。\nOrigin\r申请链接：Origin Student Version - OriginLab\nOrigin 是来自 OriginLab 的数据分析和绘图软件，并且拥有 C++ 和 Python API。\nHALCON\rMVTec HALCON 是一款综合性的机器视觉标准软件，拥有全球通用的集成开发环境 (HDevelop)。它不仅能够节约成本而且缩短您产品进入市场的时间。HALCON 的灵活架构有利于快速开发任何类型的机器视觉应用。\nHALCON 虽然也有针对教育用户推出的免费版本，并不可以用 HIT 的学生邮箱申请，拒绝理由显示所在地区没有该计划。所幸 HALCON 对免费试用的申请并不严格，申请 HALCON 正版试用的方法有：\n联系中国代理商申请，这也是官方的唯一正规渠道（笔者 Kowyo 亲自尝试，回复很迅速）。 这个 GitHub 仓库 有每个月更新的 HALCON 试用许可证。 淘宝有一家店也售卖相关的许可证，软件从官网下载即可。 "},"title":"你的学生邮箱能薅到哪些羊毛？"},"/blog/professional-softwares-for-auto-undergraduates/":{"data":{"":"","arduino-ide#Arduino IDE":"","autocad#AutoCAD":"","cadence-系列#Cadence 系列":"","codeblocks#Code::Blocks":"","matlab--simulink#MATLAB / Simulink":"","multisim#Multisim":"","proteus#Proteus":"","solidworks#SolidWorks":"","vivado#Vivado":"之所以水这么一篇文档，主要是因为自己和许多同学一样，经历了\n因为某门课需要，安装了某个大型软件； 课程结束后卸载了该软件； 后来在其他课程或个人需要，不得不重新安装该软件 的过程。 这些软件要么获取困难，要么安装过程繁琐、存储空间占用大，所以或多或少给大家带来了一些麻烦。\n所以我想整理一下我在本科期间用到的专业软件，以及它们在哪些课程中被使用。 读者可以参考这篇文章，在开课前提前寻找相应的资源并安装，以及做出要不要卸载的决定。\nNote\nVisual Studio, Visual Studio Code, Jetbrains 系列等泛用的开发工具不在本文的讨论范围。\nWarning\n本文只列举必修课程会使用的软件，不作其他推荐。\nTip\n即使你不在自己的计算机上安装这些软件，学校多半会在对应实验室的计算机上提供它们。 大多数时候，你只需要在这些软件上进行一些基础的操作，就能满足课程要求了，并不需要精通它们。 Arduino IDE\rArduino IDE 界面（源：Arduino Documentation）\r可能用到的课程 自动化认识与实践（如果有的话） 官网：Arduino IDE 免费 Arduino IDE 是 Arduino 官方的集成开发环境，用于编写、编译和上传代码到 Arduino 单片机开发板。\n2.0 版本以后的 Arduino IDE 其实就是 Visual Studio Code 套壳。 相比之下我更推荐使用 VS Code + Arduino 插件进行开发。 但如果你在这之前从来没用过 VS Code，那你最好还是用 Arduino IDE。\nAutoCAD\rAutoCAD 软件截图（源：AutoCAD 官网）\r可能用到的课程 机械制图 金工实习 官网：AutoCAD 收费，但是可以申请学生许可证，参见我们的另一篇博客：你的学生邮箱能薅到哪些羊毛？ 著名的 CAD 软件，用于绘制 2D 和 3D 工程图，但简易程度不如 SolidWorks。\nCadence 系列\r也许你会在电路系列的实验课里听到 OrCAD Capture、PSpice、Cadence、Allegro 等名词，但它们的关系到底是什么？\n软件的开发商叫 Cadence。所以教学大纲等文件中诸如“使用 Cadence 完成电路仿真”的表达是不准确的。 Cadence 的产品包括 OrCAD, Allegro 和 PSpice。其中 OrCAD 和 PSpice 产品线是收购来的，Allegro 是自家开发的。 OrCAD 和 Allegro 都是绘制原理图和设计 PCB 的 EDA 软件。Allegro 更适合企业场景。 PSpice 用于电路系统的模拟和混合信号仿真。 Cadence 产品线的更多历史可以阅读吴川斌的这篇博客：不要用阿狸狗画 PCB，不专业！用 Cadence！\nCadence 在一众 EDA 软件中的地位类似 Adobe 之于设计软件，其功能强大而复杂。\nOrCAD Capture\rOrCAD Capture 软件截图（源：自己截的）\r可能用到的课程 电路实验 / 模拟电子技术实验 / 电路与电子技术实验 电子工艺实习 OrCAD 和嘉立创 EDA、Altium Designer 同属于 PCB 设计工具，但 Candence 系的产品整体更全面复杂。\nOrCAD Capture 用来绘制电路原理图，原理图可以用于 PSpice 仿真，以及导入到 OrCAD PCB Editor 绘制 PCB（对，原理图和 PCB 要用这两个软件分开处理）。\nPSpice\rPSpice 软件截图（源：自己截的）\r可能用到的课程 电路实验 / 模拟电子技术实验 / 电路与电子技术实验 电子工艺实习 PSpice 在学校内用来进行模拟电路仿真。 基于 SPICE 的电路仿真软件还有免费的 LTspice。\nPSpice 并不能独立运行，你必须在 OrCAD Capture 中绘制电路原理图，然后在 Capture 中调用 PSpice。\nCode::Blocks\r可能用到的课程 高级语言程序设计 官网：Code::Blocks | 民间的汉化版：codeblocks-cn 免费开源 虽然 CodeBlocks 在今天已经显得非常过时，但它开箱即用，不需要自己配置开发环境，因此它仍是学校里 C 语言课程的指定工具。\n这大概是同学们在大学期间第一个要求使用的专业软件，用来对付作业和课内实验就够了，课外完全没有必要使用。\n嘉立创 EDA\r嘉立创 EDA 软件截图（源：自己截的）\r可能用到的课程 自动控制实践实验 电子工艺实习 需要设计 PCB 的竞赛 官网：嘉立创 EDA 免费 国产的 PCB 设计软件，使用方便，很适合初学者。\n就个人经验而言，嘉立创 EDA 最大的功劳是将 EDA 软件与国内的元器件供应商对接，同时省去了自己动手准备原理图库和封装库（绝大多数）的流程。\nMATLAB / Simulink\r可能用到的课程 大学物理实验 信号分析与处理 / 信号与系统 / 数字信号处理 自动控制原理 自动控制实践 自动控制实践实验 系统建模与仿真 官网：MATLAB - MathWorks 收费 MATLAB 是一个用于算法开发、数据可视化、数据分析以及数值计算的高级技术计算语言和交互式环境。 它还带有 Simulink 等工具箱，用于建模、仿真和分析动态系统。 不用多说，控制专业的唯一真神。\nMATLAB 每年会发行 2 个版本，例如 2023 年有 R2023a 和 R2023b。\n学校的计算机房安装有被美国制裁前的 MATLAB R2015b。 如果你在个人电脑上使用较新版本的 MATLAB，可能出现个别 API 和 2015 年不兼容的情况。\n学校机房中也装有国产的 MWorks，功能与 MATLAB 类似。\nMultisim\rMultisim 软件截图（源：Multisim 官网）\r可能用到的课程 数字电子技术实验 / 电路与电子技术实验 自动控制实践实验 官网：Multisim - NI 收费 Multisim 是美国 National Instrments 开发的电子电路仿真软件。 学校里一般用它来仿真数字电路。\nProteus\rProteus VSM 环境演示（源：Labcenter 官网）\r可能用到的课程 自动控制实践实验 官网：Proteus - Labcenter Electronics 收费 Proteus 也属于 EDA 软件，但它的特点在于一个软件集成了原理图、PCB 设计和仿真三个功能，以及支持 Arduino 和 51 单片机的仿真。\n学校本没有任何指定使用 Proteus 的场合，但是笔者在最近结束的自动控制实践实验中被要求制作一个直流电机驱动 L298N 的仿真电路，然而 Multisim 中没有 L298N 的仿真模型，不得不临时使用带有 L298N 元件的 Proteus。 所以还是把 Proteus 放进了本文。\nSolidWorks\rSolidWorks 软件截图（源：3DEXPERIENCE SOLIDWORKS 官网）\r可能用到的课程 工程制图 自动化认识与实践 金工实习 需要设计机械的竞赛 官网：SolidWorks 收费 SolidWorks 是基于特征的三维实体建模软件，也是我们学校自动化、机械等专业，以及各大小机器人竞赛队伍的必备工具。\nSolidWorks 每年会出一个版本，但其实 2015 年后的 SolidWorks 大同小异。 低版本 SolidWorks 创建的文件在高版本中可以被打开，但反之不能。 一般来说，不需要刻意安装最新版本的 SolidWorks，并且 SolidWorks 一直存在卸载不彻底的问题，切换版本比较麻烦。\n学校实验室安装的 SolidWorks 版本是 2018 教育版。 如果想加入校内的机器人战队的机械组，建议先了解队伍内指定的 SolidWorks 版本再安装。\nVivado\rVivado 软件截图（源：Vivado 使用入门 - 清华大学计算机系在线使用平台）\r可能用到的课程 数字电子技术实验 / 电路与电子技术实验 / 数字逻辑设计 官网：Vivado 概述 - AMD 免费（标准版），OSA 网盘中有历史版本安装包。 Vivado 是 Xilinx 公司的 FPGA 开发工具，用于设计、仿真和综合 FPGA 电路。 2022 年 Xilinx 被 AMD 收购，Vivado 也被整合到 AMD 的工具链中。\n如果你在学习过程中课程与专业软件的对应关系发生了变动，请在文末评论区中指出，笔者会及时更新。","嘉立创-eda#嘉立创 EDA":""},"title":"Auto 本科生常用专业软件一览"},"/blog/programming-language-primer/c-language/":{"data":{"c-语言例题与分析#C 语言例题与分析":"","九九乘法表#九九乘法表":"","冒泡法排序-816#冒泡法排序 (8.16)":"","利用数组求长阶乘-817#利用数组求长阶乘 (8.17)":"","利用黎曼和求积分-96#利用黎曼和求积分 (9.6)":"","单词改错#单词改错":"","念整数#念整数":"","插入数据-815#插入数据 (8.15)":"","斐波那契数列#斐波那契数列":"","方针转置-114#方针转置 (11.4)":"","最大公因数的实现#最大公因数的实现":"","玩猜数字游戏-711#玩猜数字游戏 (7.11)":"","素数和#素数和":"","记账系统-v10#记账系统 v1.0":"本文实际上是用 LaTeX 进行写作，写完之后受 OpenAuto 开发者的邀请用 Markdown 进行重写。然而重写是不可能重写的，只能用 python 自己写一个转换程序这样子。写程序总会（或者说很容易）出现 bug，虽然转换之后已再三检验，但错误在所难免。如若发现错误，欢迎和开发者（或笔者）进行沟通（QQ：2672690715）。\n由于本书是个人学习笔记，所以会随着笔者的学习不断的更新，有机会可以将更多内容投放至此。写的并不是很好，具体说明详见第二版前言、第一版前言。祝编程愉快。\n笔者在初学编程语言的时候犯下了许多错误，其中很大的一项是随意猜测代码本意。虽然很快的之后就发现了这样的错误，但是依然给我敲响了警钟。学习编程很重要的是能够理解代码背后的含义，算法思维也是很重要的。如果看到第二章的内容比第一章要简洁很多，虽然可能是因为 Python 语言本身就简洁，但是更多的时候是学完 C 语言之后的想法更好了，自然也写的更好了。如果让我重写第一章的内容，我或许会写的少很多——但是我没有这么做。\n对于一个初学者，留着本来的代码参考是一件很有意思的事情。我留下了第一次遇到这个题目的想法，这也体现了我对某个题目的想法的一步步进步。例如念整数那个题目，我最开始考虑利用switch-case语句来对应一种种情况，后来才知道，利用数组可以很便捷的实现这样的功能，但最开始我利用数字去判断这样的思路难道就有什么问题么？再进一步思考，我最开始就把输入的这个数字真的当成数字有必要么？作为一个个字符，处理起来是否会更轻松呢？如果有这样的想法的一步步进步，那么这些笔记就才值得一看了。否则列一个提纲，直接去 CSDN 上面搜索，我相信每道题都会有答案的。\n寅默\n2023 年秋\nC 语言例题与分析九九乘法表\r输出九九乘法表，只需要写两个简单的循环。注意由于间距不定，我们采用输出制表符$\\backslash{\\rm t}$保证相同间距。\n#include \u003cstdio.h\u003e int main(void) { int i, j; for (i = 1; i \u003c= 9; i++) { for (j = 1; j \u003c= i; j++) { printf(\"%d*%d=%d\\t\", i, j, i * j); if (i == j) { printf(\"\\n\"); } } } return 0; }\r这样就可以输出如下\n1*1=1\r2*1=2 2*2=4\r3*1=3 3*2=6 3*3=9\r4*1=4 4*2=8 4*3=12 4*4=16\r5*1=5 5*2=10 5*3=15 5*4=20 5*5=25\r6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36\r7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49\r8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64\r9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81\r不采用制表符，我们可以采取指定输出整数的位数来实现 (注意我们采用的方法是向右补空格，所以是$%$-nd，其中 n 代表你想要输出的宽度)：\nprintf(\"%d*%d=%-4d\",i,j,i*j);\r另外一种乘法表是写右上角的乘法表，这样的实现也是简单的补制表符即可。我们就不加演示。\n最大公因数的实现\r采用辗转相除法，并将其内置为函数。本次写法为前导式。\r#include \u003cstdio.h\u003e int gcd(int a, int b); //前导式函数引语，指明最大公因数函数的函数的输入输出格式。 int main(void) { int a = 0, b = 0; scanf(\"%d %d\", \u0026a, \u0026b); printf(\"%d\\n\", gcd(a, b)); return 0; } int gcd(int a, int b) { int d = 1, cnt = 1; if (a \u003c= b) { d = a, a = b, b = d; } //判断两数大小，保持大的在前。 for (cnt = 1; b \u003e 0; cnt++) { d = b, b = a % b, a = d; } return a; }\r这里有一个易错点：在 for 循环语句中我们的判断条件是可以继续执行的条件而不是结束条件，所以 gcd 函数中的 for 条件应该是$b\u003e0$，而不是等于 0.\n这样的代码在实现需要的功能已经是没有问题了，那么如果我们还需要多次输入以及美化这个函数，我们可以进行如下修改。\n#include \u003cstdio.h\u003e int gcd(int a, int b); int main(void) { int a = 0, b = 0, n = 0, judge = 1; char K = '1'; for (n = 0; judge; n++) { printf(\"输入两个需要得出最大公因数的正整数（两个数中间用空格隔开）：\"); scanf(\"%d %d\", \u0026a, \u0026b); printf(\"%d\\n\", gcd(a, b)); printf(\"请问您还需要判断下一组数据吗？回答Y或者N：\"); scanf(\" %c\", \u0026K); judge = K == 'Y' ? 1 : 0; } return 0; } int gcd(int a, int b) { int d = 1, cnt = 1; if (a \u003c= b) { d = a, a = b, b = d; } for (cnt = 1; b \u003e 0; cnt++) { d = b, b = a % b, a = d; } return a; }\r请注意这里的易错点：我们输入两个数后按了回车，这个回车键是会被 scanf 扫描进 char 的，因为 char 规定回车键也是字符的一种。所以我们在 scanf 中提前插入空格来保证这个回车不会产生影响。\n上述程序中我们利用了 for 循环的特性来写这样一个判断语句。如果用户输入 Y，我们认定 judge 的值为 1，即条件为真，因此输入 Y 意味着我们可以进行下一轮测试。此外我们还可以利用 if，并且直接省略 for 中的判断语句（但是分号不能丢），采用 continue 和 break 来判断。\nfor (n = 0;; n++) { //直接将其替换上面的代码对应行即可。 printf(\"输入两个需要得出最小公因数的正整数（两个数中间用空格隔开）：\"); scanf(\"%d %d\", \u0026a, \u0026b); printf(\"%d\\n\", gcd(a, b)); printf(\"请问您还需要判断下一组数据吗？回答Y或者N：\"); scanf(\" %c\", \u0026K); if (K == 'Y') continue; else break; }\rbreak 和 continue 起到了 for 语句第二条的作用，实质上这样写便和 while 语句没有区别了。最后我们甚至可以不使用循环语句，仅仅利用 goto。因此我们省去了几个不需要的变量。\nint main(void) { int a = 0, b = 0, c = 0; char K = '1'; A: printf(\"输入两个需要得出最小公因数的正整数（两个数中间用空格隔开）：\"); scanf(\"%d %d\", \u0026a, \u0026b); printf(\"%d\\n\", gcd(a, b)); printf(\"请问您还需要判断下一组数据吗？回答Y或者N：\"); scanf(\" %c\", \u0026K); if (K == 'Y') goto A; else goto B; B: return 0; }\r下一步我们考虑对 gcd 函数的进一步简化。我们有没有必要先判断 ab 的大小进行交换呢？不如这样考虑，如果 ab 不进行交换会发生什么？a 获得了 b 的值，b 获得了 a$%$b的值。注意，由于 b 比 a 大，所以实际上 a$%$b还是 a！这样我们就做了一次交换。所以代码中对 ab 的大小判断实际上是可以删掉的。\nint gcd(int a, int b) { int d = 1, cnt; for (cnt = 1; b \u003e 0; cnt++) { d = b, b = a % b, a = d; } return a; }\r我们在函数中写了一个自降的循环，这是可以的。但是我们实际上在函数的调用中天然就可以写出循环，也就是函数自循环。例如我们在函数的返回值中继续调用 gcd，那么它便又返回 gcd 函数中了。所以我们利用三目运算符和函数自降简化如下：\nint gcd(int a, int b) { return b ? gcd(b, a % b): a; /*b是0吗？不是的话(请注意只写一个b表示布尔运算，即非0为真，0为假)就返回gcd(b,a%b)，是就返回a(程序结束)*/ }\r另外我们换一种自循环的递降算法也一样可以大大简洁代码\n#include\u003cstdio.h\u003e int gcd(int a,int b){ return a\u003eb?gcd(a-b,b):a\u003cb?gcd(a,b-a):a;/*若a\u003eb则返回gcd(a-b,b),若a\u003cb则返回gcd(a,b-a),若都不然(即两数相等)返回a,程序结束*/} int main(){ int a=0,b=0; scanf(\"%d %d\",\u0026a,\u0026b); printf(\"%d\",gcd(a,b)); return 0; }\r最后给出效率最低的方式：穷举法。我们从较小的数开始向下穷举，直到发现第一个可以被两数同时整除的数字。\n#include\u003cstdio.h\u003e int gcd(int a,int b){ int c; for(c= a\u003eb?b:a;a%c!=0||b%c!=0;c--); return c; } int main(void) { int a,b; scanf(\"%d %d\",\u0026a,\u0026b); printf(\"%d\",gcd(a,b)); return 0; }\r素数和\r**问题：**我们认为 2 是第一个素数，3 是第二个素数，5 是第三个素数，依次类推。 现在，给定两个整数 n 和 m，$0\u003cn\\leq m\u003c200$，你的程序要计算第 n 个素数到第 m 个素数之间所有的素数的和，包括第 n 个素数和第 m 个素数。\n#include \u003cstdio.h\u003e int main(void) { int n = 0, m = 0, cnt = 0, zs = 0, i = 0, judge = 0, sum = 0; scanf(\"%d %d\", \u0026n, \u0026m); for (i = 2; cnt \u003c= m - 1; i++) { zs = 1; for (judge = 2; judge \u003c i; judge++) { if (i % judge == 0) { //判断是否是素数 zs = 0; } } cnt = zs ? cnt + 1 : cnt; //是素数则计数器自增 sum+=(zs \u0026\u0026 (cnt \u003e= n))*i; //若是素数且在所需要的区间内算入总和 } printf(\"%d\", sum); return 0; }\r分为几个步骤：判断是否是素数，是素数则计数器自增，若是素数且在所需要的区间内算入总和。其中判断素数可以写为一个函数，虽然在本题中的意义并不大。\nint zspd(int i) { int judge = 1, zs = 1; for (judge = 2; judge \u003c i; judge++) { if (i % judge == 0) { zs = 0; } } return zs; }\r此时原代码只需要去掉main中不需要的变量，并将原本判断素数的循环改为zs=zspd(i);即可。\r念整数\r**问题：**你的程序要读入一个整数，范围是[-100000,100000]。然后，用汉语拼音将这个整数的每一位输出出来。如输入 1234，则输出：yi er san si。注意，每个字的拼音之间有一个空格，但是最后的字后面没有空格。当遇到负数时，在输出的开头加上“fu”，如 -2341 输出为：fu er san si yi。\n#include \u003cmath.h\u003e #include \u003cstdio.h\u003e int main(void) { int m = 0, i = 0, judge = 0, cnt = 0, t = 0, bite = 0, j = 0; scanf(\"%d\", \u0026m); if (m \u003c 0) { //判断有没有没负号，若有则加上fu，并修正为正。 m = -m; printf(\"fu\"); } t = m; for (cnt = 1; m \u003e 0; cnt++) { //判断这个整数的位数 if (m / 10 != 0) m = m / 10; else break; } for (j = 0; t \u003e 0; j++) { //逐个输出每一位数对应的拼音 bite = t / (pow(10, cnt - 1 - j)); switch (bite) { case 1: printf(\" yi\"); break; case 2: printf(\" er\"); break; case 3: printf(\" san\"); break; case 4: printf(\" si\"); break; case 5: printf(\" wu\"); break; case 6: printf(\" liu\"); break; case 7: printf(\" qi\"); break; case 8: printf(\" ba\"); break; case 9: printf(\" jiu\"); break; case 0: printf(\" ling\"); break; } t = t - bite * pow(10, cnt - 1 - j); } return 0; }\r这是一段偏蠢的代码，但是它是很好理解的。我们可以对几处重复的写法进行修正。第一处是一出 for 循环。\nfor (cnt = 1; m \u003e 0; cnt++) { //判断这个整数的位数 if (m / 10 != 0) m = m / 10; else break; }\rfor 循环本身具有判断条件，所以我们根本不需要再利用 if 和 else 来判断是否跳出。不过需要注意的是直接修改可能会出现计数器的错误，因为 for 循环在第二次以上的检验会先对第三条语句进行运算，但是本例中 if 语句是先判断后运算，恰巧一样，故仅修改如下。\nfor (cnt = 1; m / 10 != 0; cnt++) { //判断这个整数的位数 m = m / 10; }\r到这似乎是一个正确的结果了？但是我们注意到一个小问题。如果我们输入一个正数，那么就会在最开始出现一个多余的空格。仔细思考我们确实是这样的。\n修改的蠢办法依然是有的，例如我们将第一位的输出单独再改一次。但是这样做显然过于麻烦，而且代码长度便大大增长了，虽然各位都是 CV 程序员（雾）…注意到 for 循环中自带了一个计数器，我们只需要当第一位的时候不输出空格即可。所以我们修改第三段代码如下：\nfor (j = 0; t \u003e 0; j++) { if (j != 0) { printf(\" \"); } bite = t / (pow(10, cnt - 1 - j)); switch (bite) { case 1: printf(\"yi\"); break; case 2: printf(\"er\"); break; case 3: printf(\"san\"); break; case 4: printf(\"si\"); break; case 5: printf(\"wu\"); break; case 6: printf(\"liu\"); break; case 7: printf(\"qi\"); break; case 8: printf(\"ba\"); break; case 9: printf(\"jiu\"); break; case 0: printf(\"ling\"); break; } t = t - bite * pow(10, cnt - 1 - j); }\r如果我们输入 1234，确实得到了正确结果，但是若是 -1234 我们便会发现 fuyi 之间没有空格。所以我们还需要再对前面第一部分进行修正：\nif(m\u003c0){ m=-m; printf(\"fu \"); }\r这里有个问题，那么多的 switch-case 能不能用什么方法简化一下呢？可以的，我们将字符串直接存在数组里面就可以了。\nchar *zs[10] = {\"ling\", \"yi\", \"er\", \"san\", \"si\", \"wu\", \"liu\", \"qi\", \"ba\", \"jiu\"}; //导言区 for (j = 0; t \u003e 0; j++) { //输出整数每一位的部分 if (j != 0) { printf(\" \"); } bite = t / (pow(10, cnt - 1 - j)); printf(\"%s\", zs[bite]); t = t - bite * pow(10, cnt - 1 - j); }\r这样就从 switch 跳到特定的某一行变成直接从数组里调取某个元素。显然后者实现简单多了。更改结束后的全代码如下。\n#include \u003cmath.h\u003e #include \u003cstdio.h\u003e int main(void) { long m = 0, i = 0, judge = 0, cnt = 0, t = 0, bite = 0, j = 0; char *zs[10] = {\"ling\", \"yi\", \"er\", \"san\", \"si\", \"wu\", \"liu\", \"qi\", \"ba\", \"jiu\"}; scanf(\"%ld\", \u0026m); if (m \u003c 0) { m = -m; printf(\"fu \"); } t = m; for (cnt = 1; m / 10 != 0; cnt++) { //判断这个整数的位数 m = m / 10; } for (j = 0; t \u003e 0; j++) { if (j != 0) { printf(\" \"); } bite = t / (pow(10, cnt - 1 - j)); printf(\"%s\", zs[bite]); t = t - bite * pow(10, cnt - 1 - j); } return 0; }\r在测试的时候又发现了个问题，如果数字太大就直接程序就错误了！那么又怎么办呢？如果我们的输入直接存到一个数组里面，不但解决了数字过大的问题，连最开始的位判断都能省去了。\n#include\u003cstdio.h\u003e int main() { int i=0,shuru[50]={0};//初始化输入的数据 char m=0,*zs[10]={\"ling\",\"yi\",\"er\",\"san\",\"si\",\"wu\",\"liu\",\"qi\",\"ba\",\"jiu\"} ; while(i\u003c50){//检测每次输入是否是回车，是即停止，否则继续存入下一个数字 shuru[i]=getchar(); if(shuru[i]=='\\n'){ break; } i++; } for(int k=0;k\u003c50\u0026\u0026shuru[k]!=10;k++){/*如果遇到回车(ASCII码是10)和输入超出50个任一即退出*/ if(k==0\u0026\u0026shuru[0]==45){ printf(\"fu \"); continue;//判断首位是否是负号(ASCII码是45) } printf(\"%s \",zs[shuru[k]-48]);//否则按位输出 } return 0; }\r我们测试程序如下：\n-1726268272817272823826917391753\rfu yi qi er liu er liu ba er qi er ba yi qi er qi er ba er san ba er liu jiu yi qi san jiu yi qi wu san\r我们发现在每次输出后自然而然的加上了空格。其实这件事并不是很重要，如果我们真的不想让最后一位多输出一个空格，我们就只需要把是否输出空格变成一个条件判断即可。\n玩猜数字游戏 (7.11)\r人与电脑一起报数，从 1 开始，只能报一个或者两个，谁报 30 谁赢。其中由于存在后手必胜策略，电脑的出方式为剩下个数余 3 为 2 则报两个，余 1 报一个，整除则随便报一个或者两个。我们先来看看一个简单的例子。如果我报数 1，电脑则是 2，3，我报 4，5，电脑则报 6.这样显然电脑最后会报 30。若电脑先手，则随便一个或者两个。一旦我出现了纰漏（指报不到三的倍数），接下来则电脑由前面的策略必胜。我们来考虑这样一个代码。首先是随机出一个先手。\n#include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e #include\u003ctime.h\u003e int main() { srand(time(NULL)); char *a[2]= {\"电脑\",\"您\"};//定义一个字符数组 int role=rand()\u00261,cnt=0;/*role是一个随机的数字0或者1，\u0026表示按位与，对1按位于即舍弃二进制前面所有的内容，保留最后一位。*/ printf(\"本次游戏的先手为：%s\\n\",a[role]); return 0; }\r接下来考虑游戏过程。我们考虑对角色 role 的值在每一次游戏过后都变化一次。但是我们还需要在函数中返回游戏进行到哪一步。除了使用指针来改变 role 的值以外，我们可以在循环中每执行一次用按位或来使 role 在 01 之间变换。所以我们写了一个游戏进行的循环。\nint (*play_func[2])(int) = { play_computer, play_human }; int main() { srand(time(NULL)); char *a[2]= {\"电脑\",\"您\"}; int role=rand()\u00261,cnt=0; printf(\"本次游戏的先手为：%s\\n\",a[role]); for(role; 1; role^=1) {//每次通过按位或来对role实行01变换 if((cnt=play_func[role](cnt))==30) {//每次对cnt赋值后调用特定函数 printf(\"%s胜出。\",a[role]);//结束时通过最后的角色来判断谁胜出 break; } } return 0; }\r这里我们使用了函数指针。也就是我们设置了一个函数的数组，使用起来和数组相似。在这里这个数组的元素是一个个函数，我们在调用数组就是一个判断并使用特定函数的过程。这里我们在巧妙运用 if 的特性。每次程序进入 for 循环之后执行 if 判断，即使我们 if 的条件为假，没有进入 if 内的语句，我们依然会执行 if 条件的语句。这样我们在 if 中写入的语句会一次次被执行。我们这个程序依靠计数器 cnt 来完成，所以我们函数的输入和输出都是 cnt。\nint play_computer(int cnt) { int r=rand()%2;//通过取余来实现01随机数选取 if((30-cnt)%3==2) printf(\"电脑:%d,%d\\n\",cnt+1,cnt+2); else if((30-cnt)%3==1) printf(\"电脑:%d\\n\",cnt+1);//基础判断 else if((30-cnt)%3==0\u0026\u0026r) printf(\"电脑:%d,%d\\n\",cnt+1,cnt+2); else printf(\"电脑:%d\\n\",cnt+1);//如果刚好cnt已经是3的倍数，随机加1或2 return (30-cnt)%3==2?cnt+2:(30-cnt)%3==1?cnt+1:cnt+1+r;/*根据上面的输出来返回cnt的值。两次三目运算符分别判断是不是模3余2，模3余1，(剩下情况)整除*/ } int play_human(int cnt) { int human_input; printf(\"请您输入：\"); do { scanf(\"%d\",\u0026human_input); cnt++; } while(getchar()!='\\n');/*例如我们输入3 2(回车),那么首先读入一个数字，while执行判断：空格不是回车，继续读入数字，然后输入2和回车，那么结束循环，离开。在这个过程中我们输入了多少个数字，那么计数器就增加了多少。*/ return cnt; }\r这样就实现了整个过程。完整代码如下。\n#include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e #include\u003ctime.h\u003e int play_computer(int cnt) { int r=rand()\u00261; if((30-cnt)%3==2) printf(\"电脑:%d,%d\\n\",cnt+1,cnt+2); else if((30-cnt)%3==1) printf(\"电脑:%d\\n\",cnt+1); else if((30-cnt)%3==0\u0026\u0026r) printf(\"电脑:%d,%d\\n\",cnt+1,cnt+2); else printf(\"电脑:%d\\n\",cnt+1); return (30-cnt)%3==2?cnt+2:(30-cnt)%3==1?cnt+1:cnt+1+r; } int play_human(int cnt) { int human_input; printf(\"请您输入：\"); do { scanf(\"%d\",\u0026human_input); cnt++; } while(getchar()!='\\n'); return cnt; } int (*play_func[2])(int) = { play_computer, play_human }; int main() { srand(time(NULL)); char *a[2]= {\"电脑\",\"您\"}; int role=rand()\u00261,cnt=0; printf(\"本次游戏的先手为：%s\\n\",a[role]); for(role; 1; role^=1) { if((cnt=play_func[role](cnt))==30) { printf(\"%s胜出。\",a[role]); break; } } return 0; }\r运行结果如下。由于 while 执行判断的方式是判断是否是回车，所以我们输入的时候可以用任何方式输出两个数字（如果你需要的话）的间隔。\n本次游戏的先手为：电脑\r电脑:1,2\r请您输入：3\r电脑:4\r请您输入：5 6\r电脑:7\r请您输入：8,9\r电脑:10\r请您输入：11 12\r电脑:13,14\r请您输入：15\r电脑:16\r请您输入：17 18\r电脑:19\r请您输入：20.21\r电脑:22,23\r请您输入：24\r电脑:25,26\r请您输入：27\r电脑:28,29\r请您输入：30\r您胜出。\r利用数组求长阶乘 (8.17)\r本题需求是求 1 到 40 的阶乘。由于没有任何类型支持超长整数输出，我们需要利用数组来完成这样一个任务。\n本代码的关键是如何实现数组储存长整型。我们考虑两个数相乘（一个很长的数和一个两位数相乘）的时候，我们直接将这个长整型的每一位都和这个两位数相乘，这样我们便可以得到一个每一位都确定的数。例如（请注意这里的第一行和第三行的数字是反序的，也就是前面的是低位，后面的是高位）\n1 3 7 6 5 8 * 34 == 34 102 238 204 170 272\r接下来我们才考虑进位，例如个位上的 34 我们就保留 4，把 3 进位到十位。而十位加上 3 之后得到的 105，我们将 1 进位到千位，百位进位了 0.经过从低到高的进位之后我们就得到了一个数字序列，这个数字序列的反序就是我们的结果。我们将这些数字储存在数组之中，这样便完成了乘法。具体实现即\nvoid jc(int a[100],int c);//导言区 void jc(int a[100],int c) { for(int m=0;m\u003c=99;m++){ a[m]=0; } a[0]=1; for(int k=1;k\u003c=c;k++){//阶乘的每一次乘法 for(int i=0;i\u003c100;i++){//乘法本身 a[i]=k*a[i]; }//每一位乘上对应的数字 for(int j=0;j\u003c98;j++){ a[j+2]+=a[j]/100; a[j+1]+=(a[j]%100-a[j]%10)/10; a[j]=a[j]%10; }//进位的实现 } }\r这里需要注意的是由于我们写成函数，也就是每次都需要用同一个数组进行运算，所以在循环之前需要初始化。在数组乘法实现之后，我们需要将其输出。我们专门写了一个函数实现它的输出。我们注意到由于 00000234000 实际上等价于 234000，也就是在遇到第一个非 0 数字之前的任何 0 都是无效的,所以我们先利用一个循环判断跳出的时机，并在跳出后反序输出每一位数字。为了工整美观，这个函数最后还需要输出一个换行。\nvoid print(int a[100]);//导言区 void print(int a[100]) { int k=0; for(k=99;k\u003e=0;k--){//从最高位开始反序判断 if(a[k]!=0){ break;//如果遇到了第一个非零数即跳出，此时的k就是数组中所储存的数字的最高位 } else; } for(int u=k;u\u003e=0;u--){//反序输出每一位数字 printf(\"%d\",a[u]); } printf(\"\\n\"); }\r下面是完整代码。\n#include \u003cstdio.h\u003e void jc(int a[100], int c); void print(int a[100]); int main(void) { int a[100] = {1}, c = 1; for (c = 1; c \u003c= 40; c++) { // 40并不是一个magic // number，这是题干要求的内容。 jc(a, c); //调用了没有返回值的函数jc（阶乘） printf(\"%2d!=\", c); // 2d表示占格两个，用于对齐 print(a); //输出数组a对应的数值 } return 0; } void jc(int a[100], int c) { for (int m = 0; m \u003c= 99; m++) { a[m] = 0; } a[0] = 1; for (int k = 1; k \u003c= c; k++) { //阶乘的每一次乘法 for (int i = 0; i \u003c 100; i++) { //乘法本身 a[i] = k * a[i]; } //每一位乘上对应的数字 for (int j = 0; j \u003c 98; j++) { a[j + 2] += a[j] / 100; a[j + 1] += (a[j] % 100 - a[j] % 10) / 10; a[j] = a[j] % 10; } //进位的实现 } } void print(int a[100]) { int k = 0; for (k = 99; k \u003e= 0; k--) { //从最高位开始反序判断 if (a[k] != 0) { break; //如果遇到了第一个非零数即跳出，此时的k就是数组中所储存的数字的最高位 } else ; } for (int u = k; u \u003e= 0; u--) { //反序输出每一位数字 printf(\"%d\", a[u]); } printf(\"\\n\"); }\r运行结果如下\n1!=1 2!=2 3!=6 4!=24 5!=120 6!=720 7!=5040 8!=40320 9!=362880 10!=3628800 11!=39916800 12!=479001600 13!=6227020800 14!=87178291200 15!=1307674368000 16!=20922789888000 17!=355687428096000 18!=6402373705728000 19!=121645100408832000 20!=2432902008176640000 21!=51090942171709440000 22!=1124000727777607680000 23!=25852016738884976640000 24!=620448401733239439360000 25!=15511210043330985984000000 26!=403291461126605635584000000 27!=10888869450418352160768000000 28!=304888344611713860501504000000 29!=8841761993739701954543616000000 30!=265252859812191058636308480000000 31!=8222838654177922817725562880000000 32!=263130836933693530167218012160000000 33!=8683317618811886495518194401280000000 34!=295232799039604140847618609643520000000 35!=10333147966386144929666651337523200000000 36!=371993326789901217467999448150835200000000 37!=13763753091226345046315979581580902400000000 38!=523022617466601111760007224100074291200000000 39!=20397882081197443358640281739902897356800000000 40!=815915283247897734345611269596115894272000000000\r接下来我们考虑对代码的改进。第一处是进位。我们考虑直接将每一个位的百位进到那个位前面两个位，这其实是没有必要的。例如我们将 132 的 1 向前进 2 位。3 向前进 1 位，实质上只需要将 13 进位到前一位即可。因为我们实质上的操作是只保留了最后一位 2，那么每一次这样操作之后也只会留下个位数，所以并没有关系。所以改进进位算法如下。\nfor(int j=0;j\u003c90;j++){ a[j+1]+=a[j]/10; a[j]=a[j]%10; }//进位的实现 另外输出的时候我们采用循环判断的方式需要两个循环语句，我们也可以使用 if 判断语句来实现。怎样使用 if 语句来实现只要出现第一非零数字就开始持续不断的输出呢？我们注意到只要让某个计数器改变即可，所以改进如下。\nvoid print(int a[100]) { int k=0,judge=0; for(k=99;k\u003e=0;k--){//从最高位开始反序判断 if(a[k]!=0){ judge=1; } else;/*如果还没遇到非0数字，那么if语句不会执行，后面的输出也不会执行；一旦遇到非0数字，那么接下来即使遇到0，judge也不会改变，依然会输出*/ if(judge){ printf(\"%d\",a[k]); } } printf(\"\\n\"); }\r增加效率的方式是使用压位。我们在上面数组每一位实际上最后只储存了一个不大于 9 的数，这对于一个数组实际上是很浪费的。作为 int 型的数组，我们能在每一位存的数实际上可以远大于 9(实际上 int 储存的最大值是 2147483647，因此我们一般压位的时候储存 4 位（保证效率的时候乘低精度的时候也不容易在最高位溢出）。)。所以如果我们考虑数组中的一个单元储存 2 位，甚至 3 位 4 位，我们就能实现所谓的压位高精。例如，我们本来将数字如下储存\n1 2 3 4 5 6 7 8 9 8 7 a[x]1 2 3 4 5 6 7 8 9 8 7 b[x]0123 4567 8987\r从本来需要存储数组的 11 个元素变为 3 个，这是一个较大的简化。压位的运算和之前完全一样，进位规则也几乎没有区别，只不过我们需要在输出时进行一次判断两次不同的输出。首先判断第一次出现的非 0 数组元素，输出这个元素，剩下的反序输出的同时需要将首位 0 也输出。这看起来有点奇怪，但是你一定不会想让\n0000 0000 0100 0100 1234\r的数组输出是\n100 100 1234\r吧？所以我们在判断输出的时候除了第一个直接输出，其余需要\nprintf(\"%.4d\",a[u]);\r来保证即使不足 4 位，也将前导 0 补齐。\n冒泡法排序 (8.16)\r利用冒泡法做数组内数字的大小排序。\n我们先设置一个数组，并写两个函数来控制这个数组的输入和输出。\n#include\u003cstdio.h\u003e void print(int *score) { while(*score!=-1) printf(\"%d \",*score++);/*当score不是-1的时候，我们让指针向后移位的同时输出这个指针对应的数组的量*/ } void read(int *score) { do scanf(\"%d\",score);//读入数组元素 while(*score++!=-1);//判断指针score对应元素的是否是-1的同时指针向后移位 } int main(void) { int score[40]= {0,};//40是题目指定的数组最大长度，其中我们以不被算入的-1作为结束 read(score); print(score); return 0; }\r接下来考虑冒泡法排序。冒泡法的原理是通过每次比较前后两个数字的大小来实现整个排序过程。所以我们循环的结束条件应该是检验数组内的数字是否已经排列整齐。如果我们每次循环都做这样的检验，未免显得过于麻烦。所以我们换种方式考虑：设置一个计数器，每次进行交换的时候让计数器 +1(当然每次循环都需要初始化为 0)，若循环到最后一次的时候已经不再需要做交换，那么计数器就是 0，也即说明我们的交换已经做完了，可以离开循环了。\nvoid mpf(int *score) {//以指针形式传入数组 int all=-1,temp=0; while(score[++all]!=-1) ;//all自增同时检验是否all是否到达-1的位置 for(int cnt=1; cnt\u003e0;) {/*判断结束的条件是该次循环已经没有再对数组做修改，即操作次数(cnt)为0*/ cnt=0;//cnt最为每次循环的计数器，循环每次初始化为0 for(int test=0; test\u003call-1; test++) {//test最大只能到all-2 if(score[test]\u003escore[test+1]) { temp=score[test]; score[test]=score[test+1]; score[test+1]=temp; cnt++; }//在需要的时候进行交换，并且记录操作次数 } } } //...read(score);//main函数内 mpf(score); //print(score);... 这样程序就完成了。完整代码：\n#include\u003cstdio.h\u003e void mpf(int *score) { int all=-1,temp=0; while(score[++all]!=-1) ; for(int cnt=1; cnt\u003e0;) { cnt=0; for(int test=0; test\u003call-1; test++) { if(score[test]\u003escore[test+1]) { temp=score[test]; score[test]=score[test+1]; score[test+1]=temp; cnt++; } } } } void print(int *score) { while(*score!=-1) printf(\"%d \",*score++); } void read(int *score) { do scanf(\"%d\",score); while(*score++!=-1); } int main(void) { int score[40]= {0,}; read(score); mpf(score); print(score); return 0; }\r测试：\n1 3 2 4 5 9 7 6 26 13 29 333 22 52 42 88 -1//输入 1 2 3 4 5 6 7 9 13 22 26 29 42 52 88 333//输出 插入数据 (8.15)\r题目要求为在一个已经顺序排列的数组中插入一个数据。输入输出的基本架构和上题完全一样。只需要更换一个函数。\nvoid insert(int *score,int x) { int all=-1; while(score[++all]!=-1) ;//记录所输入的数组长度 for(int test=0; test\u003c=all; test++) { if(x\u003cscore[test]||test==all) {//判断x位置 for(int i=all;i\u003e=test;i--) score[i+1]=score[i];//从高位向左赋值 score[test]=x;//插入数字 break;//结束循环 } } } //main函数内插入 int x; scanf(\"%d\",\u0026x); insert(score,x);\r完整代码如下\n#include\u003cstdio.h\u003e void insert(int *score,int x) { int all=-1; while(score[++all]!=-1) ; for(int test=0; test\u003c=all; test++) { if(x\u003cscore[test]||test==all) { for(int i=all;i\u003e=test;i--) score[i+1]=score[i]; score[test]=x; break; } } } void print(int *score) { while(*score!=-1) printf(\"%d \",*score++); } void read(int *score) { do scanf(\"%d\",score); while(*score++!=-1); } int main(void) { int x; int score[40]= {0,}; read(score); scanf(\"%d\",\u0026x); insert(score,x); print(score); return 0; }\r测试如下：\n1 4 6 7 9 10 15 22 55 77 247 -1//数组的输入 34//x的输入 1 4 6 7 9 10 15 22 34 55 77 247//输出 斐波那契数列\r简单实现斐波那契数列是很简单的。\n#include\u003cstdio.h\u003e long fbnq(long init){ return init==1?1:init==2?1:fbnq(init-1)+fbnq(init-2);//初始两个1，接下来是一个递推 } int main(void){ for(long i=1;i\u003c=45;i++) printf(\"fbnq(%d)=%d\\n\",i,fbnq(i)); return 0; }\r但是我们运行就会发现时常非常长，该代码效率极低。为什么？我们做递归的时候，例如我们计算 fbnq(40)，我们把前 39 个斐波那契数全又算了一遍。这是一件非常不合理的事情。在计算第 45 个就已经很吃力了，所以我们仅仅欣赏代码的简洁性。不妨来计算一下这个代码的时间复杂度。\n我们将调用一次函数作为所谓的一次运算。例如我们输入 fbnq(n)，那么下一步运算就是需要计算 fbnq(n-1)+fbnq(n-2)。注意！这里我们的 fbnq(n-1) 依然是一个独立的整体，是需要重新计算的。我们认定计算次数为${\\rm Cnt}(n)$，那么就得到递推关系 $$ {\\rm Cnt}(n)={\\rm Cnt}(n-1)+{\\rm Cnt}(n-2) $$ 我们还知道 n 为 1 或者 2 的时候我们只需要调用一次函数，所以实际上计算次数和斐波那契数的结果是一样的！如果不进行直接数学运算的话，可以看看待会输出的结果，让计算机进行这么多运算来得到结果显然是愚蠢的做法。如果我们知道斐波那契数列的通项公式的话，那么运算的时间复杂度就是$O\\left(\\exp\\left(n\\right)\\right)$。我们刚才说运算到 45 已经很吃力了，我们根据 fbnq(45)=1134903170，在运算这个结果的时候我们反复调用了这个函数 11 3490 3170 次！\n我们利用数组改进如下。\n#include\u003cstdio.h\u003e #define len 700 #define ws 200 int main(void) { int a[len][ws]= {{1,},{1,}};//初始化两个1 for(int cnt=2; cnt\u003clen; cnt++) { for(int init=0; init\u003cws; init++) { a[cnt][init]=a[cnt-1][init]+a[cnt-2][init];//对每一位递推 } for(int jw=0; jw\u003cws-1; jw++) { a[cnt][jw+1]+=a[cnt][jw]/10; a[cnt][jw]%=10; }//实现进位 } for(int cnt=0; cnt\u003clen; cnt++) { printf(\"fbnq(%d)=\",cnt+1);//输出 for(int init=ws-1,codeblock=0;init\u003e=0;init--) { if(a[cnt][init]!=0||codeblock==1){//遇到第一个非0数开始持续输出至首位 printf(\"%d\",a[cnt][init]); codeblock=1; } } printf(\"\\n\"); } return 0; } 这样我们实现了高精度运算。并且利用数组储存我们每一个结果，这样我们进行递推的时候就只需要调用之前的运算结果，这样就极大的简化了我们的运算。我们选取部分输出如下：\nfbnq(290)=1806885656323799249738933639586633513160792578781310139745345 fbnq(291)=2923602405716568564338475449381171413803636207598822186175234 fbnq(292)=4730488062040367814077409088967804926964428786380132325920579 fbnq(293)=7654090467756936378415884538348976340768064993978954512095813 fbnq(294)=12384578529797304192493293627316781267732493780359086838016392 fbnq(295)=20038668997554240570909178165665757608500558774338041350112205 fbnq(296)=32423247527351544763402471792982538876233052554697128188128597 fbnq(297)=52461916524905785334311649958648296484733611329035169538240802 fbnq(298)=84885164052257330097714121751630835360966663883732297726369399 fbnq(299)=137347080577163115432025771710279131845700275212767467264610201 fbnq(300)=222232244629420445529739893461909967206666939096499764990979600 \\\\290~300之间的结果 fbnq(700)=87470814955752846203978413017571327342367240967697381074230432592527501911 290377655628227150878427331693193369109193672330777527943718169105124275\r书接上文，让电脑执行这个数量的运行次数显然不合理。那么利用数组进行运算，由于我们已经将数字存下来了，(在这里我们对位执行操作不计算入运行次数，因为我们如果使用 int 之类的类型来计算，计算机内部也会执行位运算) 所以每计算一个斐波那契数都只需要运行一次。该程序运行起来已经非常迅速。至于再次优化，那么又是压位高精，或者更高级的有关数论的优化算法。例如高精乘法可以从$O(n^2)$利用 FFT 优化到$O(n \\log n)$，这又是很大的进步。(对数增长的速度远远低于幂函数，我们有以下结论：对于$\\forall \\alpha\u003e0$, $$ \\lim_{x\\rightarrow+\\infty}\\frac{\\log x}{x^\\alpha}=0 $$ }\n利用黎曼和求积分 (9.6)\r简单来说即利用梯形法求函数和数轴围成的面积。根据定积分的定义有 $$ \\int_a^b f(x){\\rm d}x=\\lim_{N\\rightarrow\\infty}\\frac{b-a}{N}\\sum_{k=1}^{N}f\\left(\\xi_k\\right),\\xi_k\\in\\left(\\frac{b-a}{N}(k-1),\\frac{b-a}{N}k\\right) $$ ,由于$\\xi_k$的选取是任意的，我们直接选取单边，于是积分公式即 $$ \\int_a^b f(x){\\rm d}x=\\lim_{N\\rightarrow\\infty}\\frac{b-a}{N}\\sum_{k=1}^{N}f\\left(\\frac{b-a}{N}k\\right) $$ 根据上述公式实现代码如下。\n#include \u003cstdio.h\u003e #define N 100000//细分多少份 float Integrate(float(*f)(float),float a,float b) { float c=0; for (int i=1; i\u003c=N; i++) c+=f(i*(b-a)/N);//求和部分 return c*(b-a)/N; } float function1(float x) {//题目要求的两个待积分函数 return 1+x*x; } float function2(float x) { return x/(1+x*x); } float (*f[2])(float)= {function1,function2};//函数指针的数组 int main(void) { printf(\"%f,%f\",Integrate(f[0],0.0,1.0),Integrate(f[1],0.0,3.0)); return 0; }\r输出为\n1.333351,1.151306\r我们可以直接计算两个积分为 $$ \\int_0^1 1+x^2 {\\rm d}x=\\frac{4}{3},\\int_0^3\\frac{x}{1+x^2}{\\rm d}x=\\frac{1}{2}\\ln 10 $$ 可见结果精度还是比较高的。\n方针转置 (11.4)\r#include \u003cstdio.h\u003e void Swap(int *a, int *b) {//按位异或的方式来进行交换 *a=*a^*b; *b=*a^*b; *a=*a^*b; } #define N 10 void transpose_1(int a[][N], int n) { for (int i = 0; i \u003c n; i++) { for (int j = i; j \u003c n; j++) { Swap(\u0026(a[i][j]), \u0026(a[j][i])); } } } void transpose_2(int (*a)[N], int n) { for (int i = 0; i \u003c n; i++) { for (int j = i; j \u003c n; j++) { Swap(\u0026(a[i][j]), \u0026(a[j][i])); } } } void transpose_3(int *a, int n) {//输入时是指针*a,也就是a[0],即a[0][0]的地址 for (int i = 0; i \u003c n; i++) { for (int j = i; j \u003c n; j++) { Swap(a + N*i + j, a + N*j + i);/* a在这里实际上是a[0][0]的地址，即我们直 接对地址进行操作*/ } } } void input(int a[][N], int n) {//输入 for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { scanf(\"%d\", \u0026(a[i][j])); } } } void output(int a[][N], int n) {//输出 for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { printf(\"%3d\", a[i][j]); } printf(\"\\n\"); } } int main() { int a[10][10], n; scanf(\"%d\", \u0026n); input(a, n); transpose_1(a, n); output(a, n); transpose_2(a, n); output(a, n); transpose_3(*a, n); output(a, n); return 0; }\r非对称矩阵转置 (11.5)\r实现矩阵转置。下面的代码使用了一维数组当作二维数组进行动态内存分配。\n#include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e//使用calloc和free函数需要调用 void Transpose(int *a,int *at,int m,int n) {//该转置即将a的内容写入at for(int cnt=0; cnt\u003cm; cnt++) { for(int cntt=0; cntt\u003cn; cntt++) { at[cntt*m+cnt]=a[cnt*n+cntt]; } } } void read(int *a,int m,int n) {//读入a for(int cnt=0; cnt\u003cm; cnt++) { for(int cntt=0; cntt\u003cn; cntt++) { scanf(\"%d\",\u0026a[cnt*n+cntt]); } } } void print(int *at,int m,int n) {//打印at for(int cntt=0; cntt\u003cn; cntt++) { for(int cnt=0; cnt\u003cm; cnt++) { printf(\"%d \",at[cntt*m+cnt]); } printf(\"\\n\"); } } int main(void) { int m,n,*a=NULL,*at=NULL; scanf(\"%d %d\",\u0026m,\u0026n); a=calloc(m*n,sizeof(int)); at=calloc(n*m,sizeof(int));//动态内存分配 read(a,m,n); Transpose(a,at,m,n); print(at,m,n); free(a); free(at);//释放内存 return 0; }\r输出如下 (Example)\n3 5//矩阵大小 2 3 4 5 6 6 5 4 3 2 3 3 7 8 1//初始矩阵 2 6 3 3 5 3 4 4 7 5 3 8 6 2 1//转置后的矩阵 若仿造上一题的做法，那么代码可以是\n#include \u003cstdio.h\u003e void Swap(int *a, int *b) { int const t = *a; *a = *b; *b = t; } #define N 10 #define M 10 void transpose_1(int a[][N], int at[][M], int m, int n) { for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { at[j][i] = a[i][j]; } } } void transpose_2(int (*a)[N], int (*at)[M], int m, int n) { for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { at[j][i] = a[i][j]; } } } void transpose_3(int *a, int *at, int m, int n) { for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { *(at + j*M + i) = *(a + i*N + j);/*与上一题不同的是这题直接对赋值，所以我们考虑指针*/ } } } void input(int a[][N], int m, int n) { for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { scanf(\"%d\", \u0026(a[i][j])); } } } void output(int a[][M], int m, int n) { for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { printf(\"%3d\", a[i][j]); } printf(\"\\n\"); } printf(\"\\n\"); } int main() { int a[M][N], at[M][N], m, n; scanf(\"%d %d\", \u0026m, \u0026n); input(a, m, n); transpose_1(a, at, m, n); output(at, n, m); transpose_2(a, at, m, n); output(at, n, m); transpose_3(*a, *at, m, n); output(at, n, m); return 0; }\r单词改错\r根据莱温斯坦距离，我们首先设计单词距离函数。这个函数需要传入两个单词，也就是两个 char 类型的指针，并返回两者的莱温斯坦距离，也就是一个整数。根据题目意思，设计如下。\nint levenshteinDistance(char *word1, char *word2) { int len1 = strlen(word1); int len2 = strlen(word2);//得到两个单词的长度 int matrix[len1 + 1][len2 + 1]; for (int i = 0; i \u003c= len1; i++) matrix[i][0] = i; for (int j = 0; j \u003c= len2; j++) matrix[0][j] = j; for (int i = 1; i \u003c= len1; i++) { for (int j = 1; j \u003c= len2; j++) { int cost = (word1[i - 1] != word2[j - 1]);//cost是0和1来判断 matrix[i][j] = min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost); } } return matrix[len1][len2]; }\r而在这个函数中我们又需要一个最小值函数，利用三元运算符简单设计如下\nint min(int a, int b, int c) { return a\u003c=b\u0026\u0026a\u003c=c?a:b\u003c=c?b:c; }\r现在可以来设计主函数。首先我们需要调用三个头文件，并定义两个常数\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #define WORD_LENGTH 16 #define WORD_COUNT 8 #define LINE_LENGTH 5000\r接下来在主函数中，我们先读入 (输出) 文件，并定义为指针，并作一定的错误分析。\nint main() { FILE *inputFile = fopen(\"words.txt\", \"r\"); FILE *wordListFile = fopen(\"vocabulary.txt\", \"r\"); FILE *outputFile = fopen(\"output.txt\", \"w\"); if (inputFile == NULL || wordListFile == NULL || outputFile == NULL) { printf(\"Failed to open file.\\n\"); exit(1); }\r接下来读入单词表\n// Read vocabulary char wordList[LINE_LENGTH][WORD_LENGTH]= {0,}; int wordCount = -1; while (fgets(wordList[++wordCount], WORD_COUNT*WORD_LENGTH+10, wordListFile) != NULL) wordList[wordCount][strlen(wordList[wordCount])-1]='\\0';\r这里需要注意，由于 fgets 函数会读入回车，所以我们要将这一行单词的最后一个非零元素改成 0。其中修改的是最后一个元素，所以我们使用 strlen 函数来得出最后一个字符的位置。 接下来从我们要修改的单词文档中读入单词，然后再修改。我们来考虑读入单词的形式。由于每一行单词的格式是四位数字 单词 单词/单词/…/单词所以我们需要给读入的一行断成几个部分来处理。考虑 strtok 函数。\nchar line[WORD_LENGTH*WORD_COUNT+10]; while (fgets(line, WORD_LENGTH*WORD_COUNT+10, inputFile) != NULL) { int ordinal=(line[0]-48)*1000+(line[1]-48)*100+(line[2]-48)*10+(line[3]-48),first=1,a=0; fprintf(outputFile, \"%04d \", ordinal); char *wordPtr = strtok(line+5, \" \"); while (wordPtr != NULL) { int bestDistance = WORD_LENGTH,cnt=0; char bestWord[WORD_LENGTH]; if (wordPtr[strlen(wordPtr)-1]=='\\n') wordPtr[strlen(wordPtr)-1]='\\0'; for (int i = 0; i \u003cwordCount; i++) { int distance = levenshteinDistance(wordPtr, wordList[i]); if (distance \u003c bestDistance) { bestDistance = distance; strcpy(bestWord, wordList[i]); } } fprintf(outputFile, \"%s\", bestWord); if (first==1) { wordPtr = strtok(NULL, \" \"); fprintf(outputFile, \" \"); wordPtr = strtok(wordPtr, \"/\"); } else wordPtr = strtok(NULL, \"/\"); if(wordPtr != NULL\u0026\u0026first==0) fprintf(outputFile, \"/\"); first=0; } fprintf(outputFile, \"\\n\"); }\r我们给出的 wordPtr 指针首先是从读入的一行的第五个元素开始向后段至遇到的第一个空格，而前面的四个数字以补零的方式以一个数值输出。往后通过定义的 first=1，通过 if 判断是否是循环的第一次，然后再考虑接下来的指针的位置。再 while 循环中的 for 循环通过比较每一个单词和词汇表中的莱温斯坦距离来推断哪一个但是是最贴近的单词，利用 strcpy 写入 bestWord 中。最后还需要在每一行的后面输出一个回车。\n还需要注意，由于 fgets 得到的每一行最后有一个回车，所以需要通过 strlen 得到单词长度把回车换成 0。最后我们还需要 fclose 几个文件。\nfclose(inputFile); fclose(wordListFile); fclose(outputFile); printf(\"Correction complete. Result saved to output.txt.\\n\"); return 0;\r于是整个程序就完成了。这个程序需要运行约 30 秒，效率不算高。所有代码如下。\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #define WORD_LENGTH 16 #define WORD_COUNT 8 #define LINE_LENGTH 5000 int min(int a, int b, int c) { return a\u003c=b\u0026\u0026a\u003c=c?a:b\u003c=c?b:c; } int levenshteinDistance(char *word1, char *word2) { int len1 = strlen(word1); int len2 = strlen(word2); int matrix[len1 + 1][len2 + 1]; for (int i = 0; i \u003c= len1; i++) matrix[i][0] = i; for (int j = 0; j \u003c= len2; j++) matrix[0][j] = j; for (int i = 1; i \u003c= len1; i++) { for (int j = 1; j \u003c= len2; j++) { int cost = (word1[i - 1] != word2[j - 1]); matrix[i][j] = min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost); } } return matrix[len1][len2]; } int main() { FILE *inputFile = fopen(\"words.txt\", \"r\"); FILE *wordListFile = fopen(\"vocabulary.txt\", \"r\"); FILE *outputFile = fopen(\"output.txt\", \"w\"); if (inputFile == NULL || wordListFile == NULL || outputFile == NULL) { printf(\"Failed to open file.\\n\"); exit(1); } // Read vocabulary char wordList[LINE_LENGTH][WORD_LENGTH]= {0,}; int wordCount = -1; while (fgets(wordList[++wordCount], WORD_COUNT*WORD_LENGTH+10, wordListFile) != NULL) wordList[wordCount][strlen(wordList[wordCount])-1]='\\0'; char line[WORD_LENGTH*WORD_COUNT+10]; while (fgets(line, WORD_LENGTH*WORD_COUNT+10, inputFile) != NULL) { int ordinal=(line[0]-48)*1000+(line[1]-48)*100+(line[2]-48)*10+(line[3]-48),first=1,a=0; fprintf(outputFile, \"%04d \", ordinal); char *wordPtr = strtok(line+5, \" \"); while (wordPtr != NULL) { int bestDistance = WORD_LENGTH,cnt=0; char bestWord[WORD_LENGTH]; if (wordPtr[strlen(wordPtr)-1]=='\\n') wordPtr[strlen(wordPtr)-1]='\\0'; for (int i = 0; i \u003cwordCount; i++) { int distance = levenshteinDistance(wordPtr, wordList[i]); if (distance \u003c bestDistance) { bestDistance = distance; strcpy(bestWord, wordList[i]); } } fprintf(outputFile, \"%s\", bestWord); if (first==1) { wordPtr = strtok(NULL, \" \"); fprintf(outputFile, \" \"); wordPtr = strtok(wordPtr, \"/\"); } else wordPtr = strtok(NULL, \"/\"); if(wordPtr != NULL\u0026\u0026first==0) fprintf(outputFile, \"/\"); first=0; } fprintf(outputFile, \"\\n\"); } fclose(inputFile); fclose(wordListFile); fclose(outputFile); printf(\"Correction complete. Result saved to output.txt.\\n\"); return 0; }\r词汇表这里不再显示，改之前的 words.txt 大致如下（前几个\n0004 I go/am/went/work\r0005 am I/the/only\r0007 your friend/happiess/shoes\r0008 name after/class/number\r0010 my computer/parents/he/her\r0012 bye bye/see/wave/say\r0013 Miss Mrs/Mr/yours/polite\r0016 you are/he/she/I\r0017 are you/they/we\r1338 is he/she/it\r0020 good afternoon/job/well/fine/nice\r0021 afternoon good/evening/noon/morning\r0023 morning good/afternoon/noon/midnight\r0025 night good/midnight/morning/noon\r0027 this is/that/like\r1340 that this/these/is/like\r0028 Mr Miss/polite/gentle/custom\r0030 to you/me/her/he\r0031 nice good/better/well/people\r0032 meet with/see/watch/walk\r改之后的如下（同样是前几个\n0004 I go/am/went/work\r0005 am I/the/only\r0007 your friend/happiness/shoes\r0008 name after/class/number\r0010 my computer/parents/he/her\r0012 bye bye/see/wave/say\r0013 Miss Mrs/Mr/yours/polite\r0016 you are/he/she/I\r0017 are you/they/we\r1338 is he/she/it\r0020 good afternoon/job/well/fine/nice\r0021 afternoon good/evening/noon/morning\r0023 morning good/afternoon/noon/midnight\r0025 night good/midnight/morning/noon\r0027 this is/that/like\r1340 that this/these/is/like\r0028 Mr Miss/polite/gentle/custom\r0030 to you/me/her/he\r0031 nice good/better/well/people\r0032 meet with/see/watch/walk\r注意到第三行的 happiess 已经改成了 happiness，所以程序大概发挥了应有的作用。\n记账系统 v1.0\r// Amount System v1.0 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #define MAX_NAME_LENGTH 11 #define get_infn(prompt, input, cont) \\ do { \\ do { \\ printf(prompt); \\ } while (scanf(\"%d\", \u0026input) == 1 \u0026\u0026 !(cont)); \\ } while (0) #define _print_list_text(_Ptr, i) \\ do { \\ printf(\"%05d %-16s%-11d%-12d\\n\", _Ptr[i].id, _Ptr[i].name, \\ _Ptr[i].income, _Ptr[i].outcome); \\ } while (0) typedef struct Amount { int id; char name[MAX_NAME_LENGTH]; int income; int outcome; } amount; amount *amounts = NULL; int num; int _void_strcmp(const void *s1, const void *s2) { return strcmp((char *) (((amount *) s2)-\u003ename), (char *) (((amount *) s1)-\u003ename)); } void Input_record(void); void Sort_and_list(void); void Search_records(void); void Calculate(void); void List_more(void); void List_all_records(void); void Exit(void); // Some little function void _list_beginning(void) { printf(\"ID UserName Income Expenses\\n\" \"----- -------- ------ --------\\n\"); } void _list_ending(void) { printf(\"----- -------- ------ --------\\n\"); } void _list_records(amount *amount_ptr) { _list_beginning(); for (int i = 0; i \u003c num; i++) { _print_list_text(amount_ptr, i); } _list_ending(); } void (*function[7])() = { Exit, Input_record, Sort_and_list, Search_records, Calculate, List_more, List_all_records}; int main(void) { int input = 0; extern amount *amounts; do { do { printf(\"1.Input record\\n\" \"2.Sort and list records in reverse order by user name\\n\" \"3.Search records by user name\\n\" \"4.Calculate and list per capita income and expenses\\n\" \"5.List records which have more expenses than per capita \" \"expenses\\n\" \"6.List all records\\n\" \"0.Exit\\n\" \" Please enter your choice:\"); } while ((scanf(\"%d\", \u0026input) == 1) \u0026\u0026 (input \u003e= 7 || input \u003c 0)); getchar(); function[input](amounts, num); } while (1); return 0; } void Input_record() { if (amounts) { free(amounts); } printf(\"Input the number of recorders:\"); scanf(\"%d\", \u0026num); amounts = (amount *) calloc(num, sizeof(amount)); for (int i = 0; i \u003c num; i++) { get_infn(\"Input your ID (length less than 5):\", amounts[i].id, 0 \u003c= amounts[i].id \u0026\u0026 amounts[i].id \u003c 100000); getchar(); printf(\"Input your name :\"); fgets(amounts[i].name, 10, stdin); amounts[i].name[strlen(amounts[i].name) - 1] = 0; get_infn(\"Input your income :\", amounts[i].income, 1); get_infn(\"Input your outcome :\", amounts[i].outcome, 1); } } void Sort_and_list() { if (amounts) { amount *ptr = (amount *) calloc(num, sizeof(amount)); for (int i = 0; i \u003c num; i++) { ptr[i] = amounts[i]; } qsort(ptr, num, sizeof(amount), _void_strcmp); _list_records((amount *) ptr); free(ptr); } else printf(\"Please input the datas firse.(choose 1).\\n\"); } void Search_records() { if (amounts) { char _input_for_search[MAX_NAME_LENGTH]; int i = 0; printf(\"Please input the user name:\"); fgets(_input_for_search, 10, stdin); _input_for_search[strlen(_input_for_search) - 1] = 0; for (i = 0; i \u003c num; i++) { if (!strcmp(_input_for_search, amounts[i].name)) { break; } } if (i \u003c num) { _list_beginning(); _print_list_text(amounts, i); _list_ending(); } else printf(\"404 NOT FOUND\\n\"); } else printf(\"Please input the datas firse.(choose 1).\\n\"); } void Calculate() { if (amounts) { float _per_capita_income = 0, _per_capita_expenses = 0; for (int i = 0; i \u003c num; i++) { _per_capita_income += amounts[i].income; _per_capita_expenses += amounts[i].outcome; } printf(\"Per capita income: %.2f\\n\", _per_capita_income / num); printf(\"Per capita expenses: %.2f\\n\", _per_capita_expenses / num); } else printf(\"Please input the datas firse.(choose 1).\\n\"); } void List_more() { if (amounts) { float _per_capita_expenses = 0; for (int i = 0; i \u003c num; i++) { _per_capita_expenses += amounts[i].outcome; } _per_capita_expenses /= num; _list_beginning(); for (int i = 0; i \u003c num; i++) { if (amounts[i].outcome \u003e _per_capita_expenses) { _print_list_text(amounts, i); } } _list_ending(); } else printf(\"Please input the datas firse.(choose 1).\\n\"); } void List_all_records() { if (amounts) { _list_records(amounts); } else printf(\"Please input the datas firse.(choose 1).\\n\"); } void Exit() { free(amounts); exit(0); }\r我一直认为类函数宏的用法是非常好的。其中一个很重要的原因就是，我们经常可以传入一些很神奇的参数。例如我们有一个结构体表示一个物品的颜色，里面有 RGB 三个量。显然很有可能我们对三个量的操作是类似的，甚至可能就只需要换一下对结构体的调用就可以了——但是你能够对函数传入参数 R 么？只有利用类函数宏才能随意的传入参数，因为类函数宏的调用和内联函数相似，是直接替换掉代码，这是一种很有用的方法。","非对称矩阵转置-115#非对称矩阵转置 (11.5)":""},"title":"C 语言刷题笔记"},"/blog/programming-language-primer/django/":{"data":{"":"","#":"Django 是基于 Python 的网站后端语言，单独列出来一个章节似乎并不是很合适，但是如果从其逻辑和之前的 C 或 Pure Python 并不太一样的角度出发，似乎又可以理解。以我的角度看，Django 是一个动态的语言，它会运行到某个地方停住，然后等待一个用户发来一个 request，然后根据 request 做出反应。因而基于逻辑的不同，独立章节似乎便有必要了。(本来笔者是打算合并在第二章的，但是学习过后发现单列出来更为合适。)\n搭建平台的准备工作\r和之前的 C 或 Pure Python 不一样的是，django 会自动提前生成很多的文件。(这一部分我们只演示一次，之后的范例会直接讲述对views.py与templates/\u003cproject_name\u003e/\u003cname\u003e.html的操作) 首先我们在 Linux/Mac 平台下的命令行输入\ndjango-admin startproject mytest\r就会在该目录下生成以下内容\n/mytest\r├── manage.py\r└── mytest2\r├── asgi.py\r├── __init__.py\r├── settings.py\r├── urls.py\r└── wsgi.py\r其中文件manage.py算是执行文件，我们很多操作，例如调出 Shell 或者是启动 Django 都是通过这个文件进行。我们会用到setting.py、urls.py来进行编写，而剩下的那些，暂时不会用到，也不要去动他们。\n创建一个 APP\r这里的 APP 并不是传统意义上的手机 APP，而是一个 Application，一个应用。一个 Django 项目中可能会含有许多的应用，这些应用分别处理不同的功能。\n我们首先来创建一个应用，我们应该在mytest同级目录下，即在mytest目录下的命令行输入\npython manage.py startapp login_app\r来创建一个 app。(这里便是通过manage.py)来创建一个app。至此我们的文件结构应该是\n/mytest\r├── login_app\r│ ├── admin.py\r│ ├── apps.py\r│ ├── __init__.py\r│ ├── migrations\r│ │ └── __init__.py\r│ ├── models.py\r│ ├── tests.py\r│ └── views.py\r├── manage.py\r└── mytest2\r├── asgi.py\r├── __init__.py\r├── __pycache__\r│ ├── __init__.cpython-311.pyc\r│ └── settings.cpython-311.pyc\r├── settings.py\r├── urls.py\r└── wsgi.py\r另外我们需要创建一个在 app 里面创建一个网站的模板，即 app 目录下创建一个文件夹templates，而后在这个目录下（可选择再嵌套一层与 app 同名的文件夹）写 app 的 html 文件。下面的 tree 并不是刚生成就是这样，这是已经运行过后的。\n/mytest\r├── db.sqlite3\r├── login_app\r│ ├── admin.py\r│ ├── apps.py\r│ ├── __init__.py\r│ ├── migrations\r│ │ ├── __init__.py\r│ │ └── __pycache__\r│ │ └── __init__.cpython-311.pyc\r│ ├── models.py\r│ ├── __pycache__\r│ │ ├── admin.cpython-311.pyc\r│ │ ├── apps.cpython-311.pyc\r│ │ ├── __init__.cpython-311.pyc\r│ │ ├── models.cpython-311.pyc\r│ │ └── views.cpython-311.pyc\r│ ├── templates\r│ │ └── login_app\r│ │ └── login.html\r│ ├── tests.py\r│ └── views.py\r├── manage.py\r└── mytest\r├── asgi.py\r├── __init__.py\r├── __pycache__\r│ ├── __init__.cpython-311.pyc\r│ ├── settings.cpython-311.pyc\r│ ├── urls.cpython-311.pyc\r│ └── wsgi.cpython-311.pyc\r├── settings.py\r├── urls.py\r└── wsgi.py\r其中__pycache__是执行之后的文件，我们无需重写。而我们现在需要在“主函数”(也就是主目录下的) 的settings.py中为 app 注册。即\nINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'login_app.apps.LoginAppConfig',#这里是新增的行 ]\r其中新增的行表示文件login_app/apps.py/中的class LoginAppConfig。我们可以看一下这个文件内的内容。\nfrom django.apps import AppConfig class LoginAppConfig(AppConfig): default_auto_field = 'django.db.models.BigAutoField' name = 'login_app'\r这里面有 app 的名字。至此我们已经可以开一个新的命令行打开这个网站了——我们修改任何代码都会重新加载网站，不需要担心需要手动重启网站。启动网站在命令行输入如下。\npython manage.py runserver\r此后直接打开给出的网址即可。我们可以在输入的时候后面加上指定的端口，如果没有指定默认是 8000。\n开始编写网站\r我们编写的地方主要在urls.py views.py以及你自创的 html 文件。其中的流程大概如此——我们先在urls.py中创建一个功能上类似于网站名的 urls，并调用views.py中的函数。urls.py严格来说是定义了“路由”，而views.py 里的各个函数是负责生成“响应”，也就是“网页”的部分，网站的内容本身我们可以在模板中创作。例如我们的urls.py中应该是\nfrom django.contrib import admin from django.urls import path from login_app import views urlpatterns = [ path('admin/', admin.site.urls), path('login/',views.login_func) ]\r第七行是我们新增的内容，表示我们新创的一个路径。第三行说明第七行中我们对login/ 的反应是调用views.py中的login_func函数来处理。\n#views.py from django.shortcuts import render,redirect,HttpResponse # Create your views here. def login_func(request): if request.method == \"GET\": return render(request,\"login_app/login.html\") user_name = request.POST.get(\"user\") user_password = request.POST.get(\"pwd\") if user_name == \"root\" and user_password == \"111\": return redirect(\"https://arcaea.lowiro.com/\") return render(request,\"login_app/login.html\",{\"error\":\"用户名或密码错误\"})\r而views.py里面最重要的则是函数的输入是一个request。这个request是指一个包含用户所有请求的对象，它可以查看 request.method 的值获得请求的方法。这里对 GET 和 POST 种类的请求做了不同处理，这两种请求分别是进入网站的默认方式和提交表单的默认方式。\n我们的views.py中对请求的方法进行判断，若是直接请求，也就是刚进入这个网站，那么就直接调用模板中的网站。模板如下\n\u003ch1\u003eWelcome\u003c/h1\u003e \u003cform method=\"post\" action=\"/login/\"\u003e {% csrf_token %} \u003cinput type=\"text\" name=\"user\" placeholder=\"用户名\"\u003e \u003cinput type=\"password\" name=\"pwd\" placeholder=\"密码\"\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003cspan style=\"color:red;\"\u003e {{error}}\u003c/span\u003e \u003c/form\u003e\r如果我们已经输入了用户名和密码，也就是提交了表单，这时候就是 (POST) 请求，那么我们读入用户名和密码，并利用if来进行判断。如果可以的话，那么就重定向到一个新的网页 (这里夹带了一点点私货，这是笔者最喜欢的游戏的官网。),否则我们就重新返回这个网页。\n这里我们利用了错误输入。django 的 html 文件语法上是 django 定义的，也就是在生成真正的 html 文件前，会先对其编译，然后进行替换。如果我们没有指定信息，那么替换后的结果为空。利用这个特性，我们在输入错误之后对模板中的错误信息进行填充，这样我们就可以看到错误信息所在。需要注意的是我们在 html 模板中设置输入的时候添加了\n{% csrf_token %}\r这是因为 django 会自动判断我们的输入是否真正的来源于这个网站，其方法就是利用上述的代码生成一段用于验证的码。这是 django 的一项自动的安全措施。"},"title":"使用 Django 搭建一个登录页面"},"/blog/programming-language-primer/python/":{"data":{"":"","python-的模块与包#python 的模块与包":"","python-语言的特性#python 语言的特性":"","yield的世界暂停#\u003ccode\u003eyield\u003c/code\u003e的“世界暂停”":"","关闭资源的省心方法#关闭资源的省心方法":"","动态规划寻找最佳子序列#动态规划——寻找最佳子序列":"Python 这样的语言对比之前的 C 来说，非常的高级。这样的高级很多时候直接体现在逻辑的不一样——我们不会像 C 语言那样直接考虑计算机的底层逻辑，甚至有memcpy这样直接对内存做拷贝的函数。很多时候例如在 C 语言中我们对变量做自增obj++，但是这样的写法在 Python 中是行不通的。因为 Python 不会去考虑这样的写法是否会更符合汇编语言，或者说计算机底层的直接的实现如何。又比如说，Python 中没有宏这样的概念，所以也不需要do{} while(0)语句来实现一些功能。若我们需要在循环之后才判断，我们在 Python 中并没有do{} while()这样的循环可以选择，然而我们可以在 while 中写一个 if 语句进行判断来作为循环后判断的代替。例如我们想要制作一个阶乘计算器，而这个计算器的终止条件是输入一个负数，我们在 C 语言中可以这样做。\n#include \u003cstdio.h\u003e int main(void) { int input = 0, result = 1; do { scanf(\"%d\", \u0026input); result = 1; for (int i = 1; i \u003c= input; i++) { result *= i; } printf(\"%d\\n\",result); } while (input \u003e= 0); return 0; } 但如果是 python，我们则是\nwhile True : my_input = int(input(\"input n:\")) result = 1 if my_input \u003c 0 : break for i in range (1,my_input+1): result *= i print(\"n!=\",result)\r这样的高级性很多时候让 Python 的使用更多的是依靠其丰富的库。很多时候你能用 Python 来做什么不是 Python 能做什么，而是有没有这个功能的库以及你对这方面知识了解多少。这样的使用体验很类似于在 C 语言中使用qsort来进行排序——我不需要知道具体是怎么实现排序这个功能的，我只需要提供排序的依据和需要排序的内容就可以了。\n但是无论怎么说，Python 的学习依然和之前的 C 一样，还是需要多读代码，多写代码才能提高对语言的理解。学习路径大概便是这样，我们将第一章的部分题目用 Python 重新实现，通过 C 和 Python 的关联和对比，我们或许可以更好的学习 Python。至于 Django，由于具体是网站的后端，所以逻辑上不太相似，我们放在下一章。可以说我学习 Python 的目的是为了学习 Django，所以在本体的语言学习上会比较粗浅——但是我只需要能够在出现问题的时候能够知道在哪里获得答案，这就足够了，不是么？\n配置每个项目需要的环境\r如果我们编写大型项目可能就会出现某些问题，例如包冲突。解决包冲突的一种方法就是使用虚拟环境，在每一个 project 里面都配一次环境。输入\npython -m venv venv\rsource ./venv/bin/activate\r来激活虚拟环境，并选择 python 的解释器为 venv，即我们刚刚设置的虚拟环境，然后可以进行环境的配置，例如\npip install django pip install mysqlclient 至于关闭虚拟环境只需要输入如下。\ndeactivate\rpython 语言的特性\rpython 语言是动态的，其自由变量的名称解析发生于运行时而不是编译时。例如，\ni = 10 def f(): print(i) i = 42 f(12)\r这和 C 语言中的\n#include \u003cstdio.h\u003e int a = 10; int func(void) { return a; } int main(void) { extern int a; a = 20; printf(\"%d\", func()); return 0; }\r不是同一个意思，python 把值和标识符上面的，而我们如果调用其 id 就会发现两次的 i 就不是同一个东西了，但是函数调用的依然是后面的那个值，这说明：python 是动态的解析函数内的标识符，这是一件比较独特的事情。\n类与面向对象编程\rpython 语言最重要的特性就是面向对象编程。例如之前学习的 C 语言，我们的表达式类似于 1+1，我们认为这是一种运算——但是在 python 中我们则是会认为这是一种方法，一种类下的方法。\n加法对应着__add__方法，也就是说实际上\n1+1 #与下面的 a = 1 a.__add__(1)\r是等价的。python 的语法糖是说，对于不需要新增语言特性而可以简化写法的一些特定语法。例如加法就是一个语法糖。那么什么是方法什么是类？\n实际上是这样，我们可以新建一个类，类似于如下代码：\nclass MyClass: def __init__(self,a,b): self.a = a self.b = b def SomeFuc(self): pass\r这里我们进行一些简单的解释。首先我们定义了一个类，这个类的名字叫做MyClass，这个类下面可以定义一些方法，其中不可或缺的就是初始化方法。初始化方法固定写法就是前后加上两条下划线，而且第一个“传入”的元素是其本身。什么本身？就是这个类的实例本身。这里需要简单说明一下，我们如果不是直接对这个类进行操作，就需要将类实例化。也就是对特定某个对象进行操作，例如之前我们说的 1+1 中的前面一个 1 就是一个实例，我们对其使用了其名下（python 自带的）方法（也就是类中定义的函数）。需要注意的是初始化是我们创立实例的时候运行的。\n其后我们需要注意的是（尤其是初学者很容易一头雾水的），我们初始化中的self.a = a实际上做的操作是，新建了一个实例名下的特性 a，并赋值为初始化的时候传入的那个值 a。所以我们在实例化的时候就要传入初始化需要的值。\ntest = MyClass(3,5) print(test.b) #output:5\r所以所谓的方法就是实例对应的类名下的函数。而且我们可以随意创建其名下的特性。\n迭代器与 for 循环\r首先定义iterable,iterator对象，即迭代器。迭代器是，凡是可以动态产生“下一个”对象的东西。\n自己实现range如下\nclass MyRange: def __init__(self,beg,end): self.beg = beg self.end = end def __iter__(self): self.cur = self.beg return self def __next__(self): if self.cur == self.end: raise StopIteration r = self.cur self.cur += 1 return r\r例如，在for第一次调用range的时候，我们会自动调用一次的__iter__，以后每一次在for中调用的是__next__。for循环的具体实现方式在下一节，而这里我们写一个偶数迭代器如下。\nclass EvenIter: def __init__(self, n) -\u003e None: self.cnt = 0 self.num = n def __iter__(self): return self def __next__(self): if self.cnt \u003c self.num: tmp = self.cnt self.cnt += 2 return tmp else: raise StopIteration for i in EvenIter(7): print(f\"Loop: {i}\")\r迭代器的一个好处是，不需要占用整个列表的内存，而是每次“加载”下一次的数据。\n实现我们自己的enumerate\r第一个方法是最不好理解的，但是相比第二种方法，他可以复用。首先注意第 15 行，我们在第一次返回MyEnum的时候调用了self.iterable.__iter__，这里实际上进行了两次操作，即初始化和返回值 (如果使用调试就会发现这里进入了两次)\nclass MyEnumIterator: def __init__(self, iterator) -\u003e None: self.cur = -1 self.iterator = iterator def __next__(self): self.cur += 1 return self.cur, self.iterator.__next__() class MyEnum: def __init__(self, iterable): self.iterable = iterable def __iter__(self): return MyEnumIterator(self.iterable.__iter__()) if __name__ == '__main__': for i, e in MyEnum([1, 2, 3, 4]): print(i, e)\rclass MyEnum2: def __init__(self, iterable): self.iterable = iterable def __iter__(self): self.cur = -1 self.iterator = self.iterable.__iter__() return self def __next__(self): self.cur += 1 assert self.iterator is not None return self.cur, self.iterator.__next__()\r显然接下来的第三个是最好理解的，利用yield将两个参数传回。\ndef MyEnum3(iterable): cur = 0 for elm in iterable: yield cur, elm cur += 1\ryield的“世界暂停”\r在for循环中，迭代器本身可以利用yield来做。我们可以实现迭代器如下：\ndef MyRange2(beg,end): cur = beg while cur != end: yield cur cur += 1 return\ryield是一个语法糖。他在使用的时候会返回他后面的东西，并且“短暂的”停止def定义内的函数内容，至例如，for循环去重新调用迭代器的__next__方法。比如我们首先重写一个mymap如下。\nclass MyMap1: def __init__(self,f,it): self.f = f self.it = it def __iter__(self): self.elm = None def __next__(self): self.elm = self.f(self.it.__next__()) return self.elm\r需要注意的是这里的两个__next__不是同一个东西。我们自己定义的__next__是对于我们的mymap使用的，而在__next__里面的\nself.elm = self.f(self.it.__next__())\r本身是对于可迭代对象，例如列表，元组的__next__方法。\ndef MyMap(f,it): for elm in it: yield f(elm)\r这里可以认为，yield是上面写法（也就是用类写的yield对应部分）的相同表述。例如我们写一下的测试代码\nit = MyMap(lambda x: x+1, [1, 2, 3, 4, 5]) print(\"before loop\") try: while True: i = it.__next__() print(f\"Loop: {i}\") except StopIteration: pass\r会输出\nbefore loop Do: 1 Loop: 2 Do: 2 Loop: 3 Do: 3 Loop: 4 Do: 4 Loop: 5 Do: 5 Loop: 6\r也就是，这里的看似函数的写法实际上并不是函数，而是一个语法糖，所以我们实际上在第一行调用的时候并不会输出Do :1，而是先输出before loop。并且我们这里的__next__方法会被自动认为是这个我们改写的MyMap。\n那么什么是“世界暂停\"？这里的暂停实际上就是，我们遇到一个yield之后就会像return一样返回，一直到后面再遇到__next__方法，就会从上一次yield的地方继续往下运行，这又体现出迭代器省内存的优势。\n另外，for循环的实现原理如下\nit = after_in.__iter__() try: while True: i = it.__next__() pass except StopIteration: pass\r最后还有一个yield-from方法，实际上这依然是一个语法糖。例如下面的\ndef flatten(it): for elm_it in it: for elm in elm_it: yield elm\r可以将输入的列表套列表（元组套字典等）展平为一个列表（元组），而这可以等价于\ndef flatten(it): for elm_it in it: yield from elm_it\r另外我们需要注意的是，我们使用了yield实际上就不是一个函数，而是一个类，甚至是一个迭代器——他已经自动帮我们重写了里面的迭代器方法。所以我们可以例如这样\nit = list(flatten([[1,2,3],[2,3,4],[3,4,5]])) print(it)#output:[1, 2, 3, 2, 3, 4, 3, 4, 5]\r这是因为list接受的东西是一个迭代器。例如可以写list(range(1,7))。我们还可以写生成器表达式如下：\n[10*i + j for i in range(1,5) for j in range(1,5) if j%2 == 0 ]\r关闭资源的省心方法\r如果我们清理文件需要很多次的时候我们可以使用with)语句。我们希望就是在某一块区域内如果我们需要离开，我们都必须在最后关掉某个资源——不管是用什么方法退出的情况，我们都需要释放资源。(这是一个语法糖。\nwith open(\"11.txt\",\"w\") as f: f.write(\"111\")\r具体到with语句中就是，在其后的缩进块中退出就会自动关闭其打开的资源。\npython 的模块与包\rpython 的一个包必须含有一个__init__.py的文件，而且是每一个文件夹中都需要有一个。例如我们可以在这个文件夹中的文件内定义的函数import到同文件夹中的__init__.py，然后用__all__，就可以对外直接调用这些函数。例如我们如下的目录路径\n.\r├── addtools\r│ ├── aaa.py\r│ ├── bbb.py\r│ ├── __init__.py\r│ └── __pycache__\r│ ├── aaa.cpython-311.pyc\r│ ├── bbb.cpython-311.pyc\r│ └── __init__.cpython-311.pyc\r└── main.py\r我们在addtools的__init__.py中写入\nfrom .aaa import add1 from .bbb import add2 __all__ = [\"add1\",\"add2\"]\r这样我们在main.py就可以直接写\nfrom addtools import add1,add2 print(add1(1)) print(add2(1))\r即相当于直接对外界暴露我们在一个包内的文件中自己定义的函数。\n类型标注\r类型标注的基本语法类似如下\na:int = 11 b:bool = True c:float = 1.1 if a else 1.3 d:None = None\rlist_int:list[int] = [1,1,1,1] list_int:list[str] = [*'str'] tuple_a:tuple[int,int,int] = (1,1,1)\r所谓Callable是值这个函数是可调用对象。\ndef addone(x:int)-\u003eint: return x+1 addone_c:Callable[[int,int],int]\r如果有默认值的参数，那么写法和最开始的写法是一样的。\ndef addone(x:int，delta:int = 1)-\u003eint: return x+1\r另外函数传入的参数列表中如果默认值是一个可变对象会出现：调用函数对默认值进行修改的风险。所以如果需要，那么需要这样写\ndef bindecrease(xy:list[int],delta:list[int] | None = None): if delta is None: delta = [1,1] return [xy[0]+delta[0],xy[1],delta[1]]\r其中这里对__or__方法进行了重载，这是一个语法糖。\ndelta:list[int] | None = None\r@classmethod @staticmethod\r分别用于不对外开放的方法和逻辑上隶属于这个类的方法。\nfrom typing import overload, assert_never class test_overload(): @overload def __init__(self, date: int) -\u003e None: pass @overload def __init__(self, date: str) -\u003e None: pass def __init__(self,date :int | str) -\u003e None: match date: case int(): pass case str(): pass case _ as unreachable: assert_never(unreachable)\r重载方法用的语法糖（装饰器\n斐波那契数列\r在 C 语言中，我们利用在函数中调用相同函数的特性来计算斐波那契数列，而我们在 python 中自然也可以这么做——但是 Python 语言的特性可以大大简化这样的过程，我们只需要在主函数中使用类似于a,b = b,a+b的语句就可以进行同时的赋值。这样的语句会先进行右边部分的计算，然后再一一对应的赋值给左边。所以 python 语言的值交换是非常简单的。\na, b = 0, 1 while b \u003c 10: print(b) a, b = b, a+b\r这样就是直接利用递推式输出斐波那契数列的不超过 10 的前几项。\n最大公约数\rPython 语言非常简洁——而且非常规范。我们需要注意，例如顶级定义之间空两行，方法定义之间空一行的要求。Python 与 C 不同，Python 不太强调数值的类型，所以函数定义的时候并不是像 C 那样先指明函数的返回类型，甚至在 Python 中不写return 表示无返回值。另外 Python 也有自己的三元运算符，例如本次所写的\ndef gcd(a, b): return gcd(b, a % b)if b else a a, b = (input(\"Input numbers a and b:\").split()) print(f\"Gcd(a,b) = {gcd(int(a),int(b))}\")\rPython 的三元运算符判断的语句在中间而非两边，并且使用了if else来连接，这似乎非常的符合英语的语法，也体现了 Python 语言的高级性。\n念整数\r题目与上一章的一样，我们用 Python 实现如下\nlong_int = input(\"please input a long int:\") int_list = [\"ling\", \"yi\", \"er\", \"san\", \"si\", \"wu\", \"liu\", \"qi\", \"ba\", \"jiu\"] for i in long_int: if i == \"-\": print(\"fu\", end=\" \") continue print(int_list[int(i)], end=\" \")\r这里的思路恐怕和 C 就不太一样，我们不真的把整数看成整数，而是看成字符串再分割成一个个字符做“强转”，并且我们利用了 python 的for循环的特性，可以对列表、元组内的元素遍历——那么字符串我们可以视为一种特殊的元组，还有什么比这更巧的事么？\n矩阵的转置\r在 python 实现转置我们可以使用列表推导式来处理。例如\ndef transpose_list(list_of_lists): return [ list(row) for row in zip(*list_of_lists) ] print(transpose_list([[1, 4, 7], [2, 5, 8], [3, 6, 9]]))\r这里的实现方式非常有趣，以至于一开始还不太好理解。我们在函数中return的是一个列表推导式（换行了）。列条推导式的函数部分（也就是平常for循环的缩进部分）是产生一个列表，这是因为后面出现的那个，没有见过的东西——zip的需要。zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。\n这就是zip和map的相同和不同之处了。后者接受一个函数，将其后传入的可迭代对象按顺序一一取出元素放入函数中，将结果作为新的列表的元素。而前者则是简单的将传入的可迭代对象按顺序一一取出之后列为一个个元组。需要注意的是，为了节省内存，python3 的特性是，需要手动在外面套一层例如，list才能就将其转换为元组的列表。另外如果在zip(*obj)实际上相当于解包。\n就本题而言，传入的二维列表在zip内被转化为三个一维列表 (仅仅只看我们的例子)，而这三个一维列表被zip接受转化为三个对应的元组。现在我们的列表推导式从这个 zip 中接受的是一个个元组（因为此时可迭代对象变成了一个个元组），并转换为了一个个列表。\n所以这实际上用于做矩阵的转置是有一点“作弊”了。这个内置函数的作用刚刚好就是用于做这件事的。另外我们考虑用map；来实现zip的效果。\nmap(lambda *args:args,*list_of_lists)\r实际上这里我们利用了匿名函数参数不定时返回元组的特性。\n汉诺塔\r利用递归将汉诺塔的方法简化为：\n先将前 n-1 层挪到第二根柱子上 将第 n 层挪到第三根柱子上 将前 n-1 层挪到第三根柱子上 将柱子抽象出来为某个元素，这样我们就可以完成递归——其中函数就是将从上往下数 n-1 层的挪动方法。 def hanoi(n,x,y,z): if n == 1: print(f\"{x} --\u003e {z}\") else: hanoi(n-1,x,z,y) print(f\"{x} --\u003e {z}\") hanoi(n-1,y,x,z) n = input(\"请输入汉诺塔的层数：\") hanoi(int(n),'X','Y','Z')\r例如输出\n请输入汉诺塔的层数：4\rX --\u003e Y\rX --\u003e Z\rY --\u003e Z\rX --\u003e Y\rZ --\u003e X\rZ --\u003e Y\rX --\u003e Y\rX --\u003e Z\rY --\u003e Z\rY --\u003e X\rZ --\u003e X\rY --\u003e Z\rX --\u003e Y\rX --\u003e Z\rY --\u003e Z\r我们人类有时候很难去想象一些方法，尤其是递归方法。例如这个问题，如果多层调用同一个函数我们就很难想象其进程。甚至于，如果真的直接处理四层汉诺塔，我们会觉得上面输出的方法很巧妙——然而实际上这个答案不过是由代码生成的，而且代码还很简单（甚至逻辑很简单）。\n迷宫问题 (BFS 深度搜索算法)\r我们用*来代表墙壁，而空格就是路径。另外我们的出发点和出口分别用字母 S(start) , T(terminal) 表示。例如迷宫\nS* ** * * ** * * ** * T\r*******\r找到最短路径并输出。其中提前输入行数。\ndef find_start(map): for i in range(len(map)): for j in range(len(map[i])): if map[i][j] == \"S\": return [i, j] return [-1, -1] def find_next(lis, vlis, pos, step): global min if lis[pos[0]][pos[1]] == 'T' and step \u003c min: min = step for nps in dirs: try: if pos[0]+nps[0] \u003e= 0 and pos[1]+nps[1] \u003e= 0: fps = pos[0]+nps[0], pos[1]+nps[1] if ((lis[fps[0]][fps[1]] == ' ' or lis[fps[0]][fps[1]] == 'T') and vlis[fps[0]][fps[1]] == 0): vlis[fps[0]][fps[1]] = 1 find_next(lis, vlis, fps, step+1) vlis[fps[0]][fps[1]] = 0 except IndexError: continue row = input(\"请输入行数：\") vlis, lis = [], [] dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)] min = 114514 for i in range(int(row)): lis.append([]) lis[i] = input() vlis = [[0*i for i in range(len(lis[rows]))] for rows in range(len(lis))] pos = find_start(lis) vlis[pos[0]][pos[1]] = 1 find_next(lis, vlis, pos, 0) print(\"最短路径为\", min)\r其中需要注意的是，python 对列表的索引值是可以是负的（也就是对应的反方向查找）！所以我们需要人为判断为正。至于列表越界，利用 python 自带的机制即可。这是很经典的 DFS 算法，实际上利用 C 和 Python 实现起来难度相近。\n请输入行数:9\r** ** *\r* * ** * *\r*S* ** * *\r* ***\r******* *T*\r* * *\r******* *\r* *\r***********\r最短路径为 31\r另外修改过的代码如下\n# 全局的东西就放到最前边全局去，并且大写 GMIN = None DIRS = [(0, 1), (1, 0), (0, -1), (-1, 0)] # 重命名，map 是 python builtin 的东西，最好不要重名 def find_start(maze): if cell == 'S': # 尽量使用不可变的元组类型做这种 \"把几个值打包放一起的操作\" return (i, j) # 如果需要一个和其他值意义都不一样的值， # 那就让它彻底表现得和正常情况不一样 return None # 重命名 lis -\u003e maze, python 是动态类型语言，对同一个概念维持同一个命名很重要 # 重命名 vlis -\u003e visited, 不要使用奇奇怪怪的缩写 def find_next(maze, visited, pos, step): # 直接使用解构赋值给予 pos 中的两个值一个有意义的名字 row, col = pos # 重命名，min 是 python builtin global GMIN assert GMIN is not None if maze[row][col] == 'T' and step \u003c GMIN: GMIN = step # 具有意义的一段代码可以抽出来写小函数，更加具有可读性 def in_range(row, col): return 0 \u003c= row \u003c len(maze) and 0 \u003c= col \u003c len(maze[new_row]) for next_row, next_col in DIRS: new_row, new_col = row + next_row, col + next_col # 偏好尽早退出而非嵌套 if not in_range(new_row, new_col): # 没事不要用 try except IndexError 的样子来判断是否超范围， # 这很少见且没有直接体现你的意图 continue # visited 里放的类型从 0/1 int 转成 bool, 因为你本质上就是拿它当 bool 在用 # 使用 in 运算符可以替代多次重复写 maze[new_row][new_col] if maze[new_row][new_col] in (' ', 'T') and not visited[new_row][new_col]: visited[new_row][new_col] = True find_next(maze, visited, (new_row, new_col), step + 1) visited[new_row][new_col] = False # 如果一个 python 脚本是期望直接运行的，那么最好像下边这样写 # 包在下边这个 if 内的代码只有在直接 python \u003c文件\u003e 的时候才会执行， # 在它被 import 的时候则不会。可以认为这是约定俗成的 \"main\" 函数 if __name__ == '__main__': # 在输入处直接做数据处理 (转成 int), 而不是留到后边做 row_cnt = int(input(\"请输入行数：\")) GMIN = row_cnt ** 2 # 让第一次绑定尽量贴着变量的构建，它们逻辑上是一块的：\"构建出这个对象\" # 尽可能使用表意的写法，直接描述对象应该是什么，而不是描述要如何构建这个对象 maze = [input() for _ in range(row_cnt)] visited = [[False for _ in row] for row in maze] if (start_pos := find_start(maze)) is None: raise RuntimeError('Start pos not found') start_row, start_col = start_pos visited[start_row][start_col] = True find_next(maze, visited, start_pos, 0) print(\"最短路径为\", GMIN) # 使用合理的空行，按逻辑分块你的程序，以及文件最后一个字符应该是回车\r动态规划——寻找最佳子序列\r输入一串用空格隔开的数字，找出其最大子序列的序列长度。动态规划的想法是，制造一个数组，这个数组的内容是{\\bf 以数组下标对应本数组的数字为子序列最后一个元素的最优解的序列长度}，其递推关系为 $$ \\mathrm{dp}[j] = \\begin{cases} 1 \u0026,\\mathrm{list}[i]\u003c\\mathrm{list}[j] ,0\\leq i \u003cj\\[2ex] \\max{ \\mathrm{dp}[i]} +1\u0026,\\mathrm{list}[i]\u003clist[j] ,0\\leq i \u003cj \\end{cases} $$\ndef find_dp(list_A: list[int]) -\u003e list[int]:#类型标注，类似于 C 的 int *list_A dp = [1 for _ in range(len(list_A))]#创建一个 dp 数组 for j in range(len(list_A)): for i in range(j): if list_A[i] \u003c list_A[j]: dp[j] = max(dp[i] + 1, dp[j])#算法本身，利用 python 写要直接表达意思 return dp if __name__ == '__main__': list_A = list(map(int, input().split())) dp = find_dp(list_A) print(max(dp))","实现我们自己的enumerate#实现我们自己的\u003ccode\u003eenumerate\u003c/code\u003e":"","念整数#念整数":"","斐波那契数列#斐波那契数列":"","最大公约数#最大公约数":"","汉诺塔#汉诺塔":"","矩阵的转置#矩阵的转置":"","类与面向对象编程#类与面向对象编程":"","类型标注#类型标注":"","迭代器与-for-循环#迭代器与 for 循环":"","迷宫问题-bfs-深度搜索算法#迷宫问题 (BFS 深度搜索算法)":"","配置每个项目需要的环境#配置每个项目需要的环境":""},"title":"Python 语言特性杂谈"},"/blog/zero-force-poles/":{"data":{"":"","平面简单桁架中零力杆的判断方法#平面简单桁架中零力杆的判断方法":"前两天做理论力学作业的时候，我看到习题解答上一道题的答案是这样的：\n第一句“直接看出 $CH$ 杆不受力”直接给我整不会了。 然而老师在课堂上并没有详细讲解判断平面桁架中受力为零的杆的方法，所以我赶紧把作业扔在一边查了点资料。\n研究了一会儿之后，我感觉零力杆的判定还是挺有意思的，属于理论力学解题的一个小技巧。 故在此分享一下自己整合网上资料后的内容。\n当然，这不是什么重点知识，我就随便一写，你就随便一看。 文末有一道小例题，如果你能迅速得出答案，那么恭喜你，零力杆判断不可能难住你啦！\n平面简单桁架中零力杆的判断方法\r平面简单桁架中，那些受力为 0 的杆件被称为零力杆，或者“零杆”。 零杆是桁架在特定载荷下的特殊情况，虽然在实际工程中不可去掉，但在理论受力分析时可以被去掉以简化计算。\n以下是 4 中常见的零力杆情况。\n1. L 形节点\r不共线的两杆节点不受外力作用时，两杆皆为零力杆。 证明很简单，对于节点 $C$，其平衡条件是 $\\boldsymbol{F_{CE}} + \\boldsymbol{F_{CD} = \\boldsymbol{0}}$。 然而 $\\boldsymbol{F_{CE}}$ 与 $\\boldsymbol{F_{CD}}$ 并不共线，因此只能 $\\boldsymbol{F_{CE}} = \\boldsymbol{F_{CD}} = \\boldsymbol{0}$。\n若其中一杆与外力共线，则此杆内外力相等，不与外力共线的一杆为零杆。 2. T 形节点\r无外力作用的连接三杆的节点，若其中两杆在一条直线上，则不共线的一杆为零力杆，而共线两杆内力相等且性质相同（同为拉力或同为压力）。 补充：当节点上作用有外力时，可以用一根杆来替代外力。\n例 下图中的节点 5 上作用了一个外力 $F$，则可以用一根向右的杆件代替 $F$，从而将节点 5 看作 T 形节点，快速判断 57 为零力杆。当然了，5 本质上是一个 L 形节点。 3. X 形节点\r无外力作用的连接四杆的节点，若两对杆分别共线，则同一直线上的两杆内力相等且性质相同（同为拉力或同为压力）。 X 形节点严格意义上没有出现零力杆，但是不少资料都提到了它，所以在这里也一并列出。\n4. K 形节点\r四杆相交成对称 K 形的节点，在无直接荷载作用时，两斜杆轴力异号等值。 平面桁架如果整体结构对称，荷载也对称，且对称轴上的 K 形节点不直接受到外力作用，则该节点上的两根斜杆为零力杆。 超级简单的例题\r用本文提到的 4 种节点，数数下图的 2 个桁架中各有几根零力杆？\n答案就藏在参考资料的链接中哦！\n参考资料\r【跟陆工学“三大力学”】巧学“零杆”的判断方法，秒杀 1 分 - 知乎 每日推送 7：静定结构中的桁架零杆判定 - 知乎 一级注册建筑师真题实战 - 建筑结构（5）零杆的判断 - 知乎 怎么都是土木建筑的考试资料啊（"},"title":"平面简单桁架中零力杆的判断"},"/docs/":{"data":{"":"如您有需要补充的资料，请联系me@miko.pw","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" C++ C语言 培养方案 大学物理 大学物理实验 大学计算机 工程数学 思想道德与法治 数字逻辑电路 机器学习 概率与统计 模拟电子线路 测试技术 电路 电路实验 线性代数 近现代史纲要 金工实习（工程实践） 高等数学 "},"title":"_index"},"/docs/%E5%9F%B9%E5%85%BB%E6%96%B9%E6%A1%88/":{"data":{"":"放置于此，便于快速查询各专业各版本培养方案。\n特别注意，每隔几年培养方案都会发生变化，请自行查阅学校官网。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E5%AE%9E%E9%AA%8C/":{"data":{"":"大学物理实验\n在南理工很少听到有人说它的完整名称。该课程分为**大学物理实验（Ⅰ）和大学物理实验（Ⅱ）**两部分，会分两个学期开展。\n由于每个班级的上课安排不同，所以各个班级的上课时间不一定相同。\n该课程给人留下的主要印象就是故障的实验仪器和抄不完的预习报告。","上课地点#上课地点":"这门课程的上课地点均位于基础实验楼。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 11120904-1.5学分-大学物理实验（Ⅰ） 11220904-1.5学分-大学物理实验（Ⅱ） ","实验室器材情况#实验室器材情况":"需要注意的是，实验室的器材较为老旧，在实验过程中出现一些误差是正常现象。当大家撰写实验报告时，对数据等进行合理调优处理即可。\n——Light 2025.4.15"},"title":"_index"},"/docs/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E5%AE%9E%E9%AA%8C/11120904-1.5%E5%AD%A6%E5%88%86-%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E5%AE%9E%E9%AA%8C/":{"data":{"":" 课程编号 课程名称 开课单位 学分 总学时 考核方式 课程属性 11120904 大学物理实验（Ⅰ） 物理学院 1.5 24 考查 必修 对于大多数同学而言，除非在大一就进入课题组或工作室，否则这门课程大概是你第一次走进实验室进行系统的实验操作。\n强烈建议大家在大学阶段充分利用学校的各种资源，积极参加一些动手制作的项目。\n勇敢地迈出这一步，去尝试和探索，这将有助于提升自己的实践能力和创新思维。","代代传#代代传":"学长学姐们流传下来的“代代传”资料，大家可以用来参考。但由于这份资料在学校里比较出名，很多老师一眼就能辨别出来。\n所以在借鉴的时候，一定要合理运用，不能完全照搬，要结合自己的实验情况和思考，进行适当的调整和补充。\n希望您可以慷慨提供自己的实验报告","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","器材情况#器材情况":"需要注意的是，实验室里的很多器材由于使用时间较长等原因，多多少少都存在一些问题。\n如果你在实验过程中发现自己的实验结果和其他同学的结果出现了数量级上的差别，那么大概率是实验设备出现了问题。\n遇到这种情况不要慌张，可以及时向老师反映，寻求帮助和指导。","实验内容#实验内容":"上课前需要手抄书上实验报告内容到实验报告册上，但大部分老师不会认真查看你写了什么东西，一般书写工整即可，无须逐字逐句照搬。\n做实验时需按要求采集相关数据，实验完成后对数据进行处理并书写实验报告","考核#考核":"老师严苛程度 ：不同的授课老师在教学和考核的严苛程度上不尽相同，难以统一标准衡量。同学们需根据老师的具体要求和风格，调整自己的学习态度和方法。 过程性考核变化 ：自 2022 级起，课程增加了过程性考核以及斩杀线。学生需要在课堂上借助学习通完成一个关于误差分析的在线测试，该测试成绩将计入平时成绩。 ——Light 2025.4.15\n批量下载\r文件名\r文件大小\r最后修改日期\r大学物理实验（Ⅰ）实验报告参考_大物实验是个小姐姐(2019.3 xwt)\rpdf\r53.7 MB\r2023/03/09\r53.7 MB\r2023/03/09\r大物实验MOOC课后题整理2.0\rpdf\r384.8 KB\r2023/11/08\r384.8 KB\r2023/11/08\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。"},"title":"_index"},"/docs/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E5%AE%9E%E9%AA%8C/11220904-1.5%E5%AD%A6%E5%88%86-%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E5%AE%9E%E9%AA%8C/":{"data":{"":" 课程编号 课程名称 开课单位 学分 总学时 考核方式 课程属性 11220904 大学物理实验（Ⅱ） 物理学院 1.5 24 考查 必修 在学校里，大家通常将**大学物理实验（Ⅱ）**称为“大物实验二”或者“大物实验下”。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","参考资料#参考资料":"学长学姐们流传下来的“代代传”资料，同学们可以拿来借鉴。不过，因为这份资料广为人知，老师们很容易辨别出来。所以在使用时，只能把它当作参考，不能直接抄袭哦。","四考核方式说明#四、考核方式说明":"本课程的考核方式为考查课。以 2022 级的情况为例，该年级在这门课程上没有安排期末考试。同学们可以根据这个情况，合理规划自己的学习精力和时间，更有针对性地完成课程学习任务。\n—— Light 2025.4.15\n批量下载\r文件名\r文件大小\r最后修改日期\r大学物理实验Ⅱ实验报告参考_2018.10\rpdf\r17.7 MB\r2023/03/09\r17.7 MB\r2023/03/09\r大学物理实验Ⅱ实验报告参考_2024.10\rpdf\r58.9 MB\r2025/04/16\r58.9 MB\r2025/04/16\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","实验注意要点欢迎补充#实验注意要点（欢迎补充）":" 光学实验注意事项：在进行光学实验时，一定不要佩戴防蓝光眼镜。这是因为防蓝光眼镜会阻挡光线，导致你无法看见氢原子的蓝色/青色谱线，从而影响实验的观察和结果记录。 旋光效应实验细节：在涉及旋光效应的实验中，有一瓶糖水的浓度是错误的。大家在做实验时，要对这个情况心中有数，处理数据和分析结果的时候需格外注意。 "},"title":"_index"},"/docs/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/":{"data":{"":"","前言#前言":"对于非物理系的理工科学生而言，大学物理是必修课。学完这门课程，你将能够对机械运动、电学、光学、热力学等领域有更为全面且深入的认识。 不过，需要注意的是，本课程有一定数学基础要求。它需要你理解正余弦函数以及求导、积分等高等数学知识，这是顺利学习大学物理的重要前提。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","复习建议#复习建议":"教材使用\r本科课程采用南理工自编教材。 个人认为，这本教材编写得较为得当，公式有足够多的解释说明，例题也较为完备。\n网课参考\r可选网课：目前网络上的大学物理课程内容较为分散，且缺少能让大家短期内快速掌握重点的速成课。在众多网课资源中，东北大学的相关课程视频具有一定参考价值。 注意事项：东北大学的课程也存在一些问题，其课程时间非常长，并且部分章节存在单纯念 PPT 的情况。所以在观看时，请结合个人实际情况，合理筛选、安排学习进度，挑选对自己有帮助的部分进行学习。 不推荐课程：这里特别提醒，不建议观看猴博士的课程。该课程虽然可能在短期内看似能帮助你应对一些特定题型，但从长远和知识理解角度来看，它对你真正理解题目并无实质帮助。一旦考试题型发生变换，你将很难取得理想分数。 （内容经过 AI 润色） —— Light 2025.4.15","子目录#子目录":" 1312060D-3.5学分-大学物理（Ⅰ） 1322060D-3.5学分-大学物理（Ⅱ） ","课程构成#课程构成":"大学物理分为大学物理（Ⅰ）和大学物理（Ⅱ），一般习惯性称之为“大物上”和“大物下” 。\n每学期都会有与之配套的大学物理实验作为独立课程开设。请查阅仓库内的大学物理实验内容。"},"title":"_index"},"/docs/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/1312060d-3.5%E5%AD%A6%E5%88%86-%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/":{"data":{"":" 课程编号 课程名称 开课单位 学分 总学时 考核方式 课程属性 1312060D 大学物理（I） 物理学院 3.5 56 考试 必修 另外，还有 大学物理 (Ⅱ) 课程。 在南理工，大部分人习惯称它为“大物上”或“大学物理上”。\n说来惭愧，距离我学习大学物理已经过去了好多年，因此很难为大家提供有效的相关资料了，对此十分抱歉。 选课 万逸 和 王广安 的课程都很有特色。 王广安老师是纯手写板书，这十分少见。 —— Light 2025.4.15\n批量下载\r文件名\r文件大小\r最后修改日期\r2022级大学物理模拟试卷答案（上）\rpdf\r381.3 KB\r2023/11/08\r381.3 KB\r2023/11/08\r22级大物上复习提纲\rdocx\r32.3 KB\r2023/11/08\r32.3 KB\r2023/11/08\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/1322060d-3.5%E5%AD%A6%E5%88%86-%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/":{"data":{"":" 课程编号 课程名称 开课单位 学分 总学时 考核方式 课程属性 1322060D 大学物理（Ⅱ） 物理学院 3.5 56 考试 必修 在南理工，这门课程大部分人习惯称它为“大物下”或“大学物理下”。\n另外，学校还设有 大学物理 (Ⅰ) 。两个课程并没有太强的关联性，大学物理总体来说是章节式的，大学物理 (Ⅰ) 没学好也没关系。\n说来惭愧，距离我学习大学物理已经过去了好多年，因此很难为大家提供有效的相关资料了，对此十分抱歉。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","选课推荐#选课推荐":"在大学物理课程的教师选择方面，万逸老师和王广安老师的课程都很有特色。其中，王广安老师的授课方式尤为独特，他采用纯手写板书的形式教学，这种教学方式在如今的课堂中十分少见，值得体验。\n—— Light 2025.4.15\n批量下载\r文件名\r文件大小\r最后修改日期\r大学物理(下)复习提纲(2024)简化\rpdf\r427.2 KB\r2025/04/16\r427.2 KB\r2025/04/16\r大学物理（下）_2024_A卷_题目\rpdf\r2.7 MB\r2024/01/30\r2.7 MB\r2024/01/30\r大学物理（下）_2024_模拟试卷_答案\rpdf\r303.9 KB\r2024/01/30\r303.9 KB\r2024/01/30\r大学物理（下）_2024_模拟试卷_题目\rpdf\r432.9 KB\r2024/01/14\r432.9 KB\r2024/01/14\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。"},"title":"_index"},"/docs/%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA/":{"data":{"":"##大学计算机\n课程编号 课程名称 开课单位 学分 总学时 考核方式 课程属性 06000401 大学计算机 计算机科学与工程学院 2 32 考试 必修 大学阶段必须掌握计算机的使用方法和基本原理。\n不过我认为这门课考核方式及上课形式过于死板僵硬，学生并不能学到很多东西。\n但最起码可以学会如何解压缩文件及使用 Office 进行办公。\n成绩考核除平时成绩外，还由上机考试和实验报告两部分组成\n实验报告Light大学计算机实验报告.rar已经添加在附件。 添加大学计算机知识点汇编_自动化学院学业指导部.pdf\n—— Light 2025.4.15\n添加tx_大学计算机基础_试题题库及答案.pdf 添加大学计算机题库.pdf\n——tx 2025.4.15\n批量下载\r文件名\r文件大小\r最后修改日期\rLight大学计算机实验报告\rrar\r34.0 MB\r2022/11/18\r34.0 MB\r2022/11/18\rtx_大学计算机基础_试题题库及答案\rpdf\r1.4 MB\r2025/04/15\r1.4 MB\r2025/04/15\r大学计算机知识点汇编_自动化学院学业指导部\rpdf\r1.4 MB\r2023/11/08\r1.4 MB\r2023/11/08\r大学计算机计算专题_自动化学院学业指导部.pdf\rpdf\r4.8 MB\r2025/04/16\r4.8 MB\r2025/04/16\r大学计算机课程学习册2023(答案更正)\rpdf\r290.9 KB\r2023/11/08\r290.9 KB\r2023/11/08\r大学计算机题库\rpdf\r3.6 MB\r2025/04/15\r3.6 MB\r2025/04/15\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/":{"data":{"":"工程数学，又称之为复变函数、积分变换与场论。 11024002-3学分-工程数学 是自动化学院使用的课程，不包含场论部分。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 11024002-3学分-工程数学 "},"title":"_index"},"/docs/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/11024002-3%E5%AD%A6%E5%88%86-%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6/":{"data":{"":"自动化学院所学习的工程数学只包括复变函数与积分变换。 这是一门在实变函数的基础上产生和发展的学科，但主要研究复数、复平面上内容。 添加了一份古早的 工程数学（各学分）.pdf 到附件文件夹\n批量下载\r文件名\r文件大小\r最后修改日期\r工程数学（各学分）\rpdf\r1.5 MB\r2024/01/02\r1.5 MB\r2024/01/02\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E6%B2%BB/":{"data":{"":"","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","阿托卡-2025415#贡献试卷\u003ccode\u003e思想道德与法治-2022A-考试卷.pdf\u003c/code\u003e\n——阿托卡 2025.4.15":" 课程编号 课程名称 开课单位 学分 总学时 考核方式 课程属性 19000001 思想道德与法治 马克思主义学院 3 48 考试 必修 贡献试卷思想道德与法治-2022A-考试卷.pdf ——阿托卡 2025.4.15\r大学生必修政治课 思想道德与法治 这个课程想过关还是很容易的，但鉴于他有三学分，建议好好背知识点。 ——Light 2025.4.15\n批量下载\r文件名\r文件大小\r最后修改日期\r思想道德与法治-2022A-考试卷\rpdf\r182.6 KB\r2025/04/15\r182.6 KB\r2025/04/15\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。"},"title":"_index"},"/docs/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/":{"data":{"":"我只收集了自动化学院专业的试卷，课程大纲编号04026304\n期待更多贡献。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 04026304-3.5学分-数字逻辑电路 "},"title":"_index"},"/docs/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/04026304-3.5%E5%AD%A6%E5%88%86-%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/":{"data":{"":"本课程编号04026304，是自动化学院所有专业学生的必修课。 其他学院（如计算机等）可能不适用，请知悉。\n作为自动化学院的学生，数字逻辑电路（下简称 “数电”）几乎是无法避开的课程。无论是后续的数字钟实验，还是自行开发、设计 PCB，都离不开数电。\n需要说明的是，从 2022 级开始，数电课程考试与往年试题存在较大差异，附件文件夹中的 2021、2022 均为往年试题。请谨慎斟酌复习！\n——Light 2025.4.14\n批量下载\r文件名\r文件大小\r最后修改日期\r试卷2021\rpdf\r423.7 KB\r2024/06/23\r423.7 KB\r2024/06/23\r试卷2022\rpdf\r315.6 KB\r2024/06/23\r315.6 KB\r2024/06/23\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06035801-2%E5%AD%A6%E5%88%86-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/":{"data":{"":"##机器学习\n不好星-06035801-2-机器学习.pdf 计算机学院机器学习课程考试允许自行携带一张提前写上内容的 A4 纸张， 此 pdf 可以提供参考 ——不好星 2025.4.15\n批量下载\r文件名\r文件大小\r最后修改日期\r不好星-06035801-2-机器学习\rpdf\r788.2 KB\r2025/04/15\r788.2 KB\r2025/04/15\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A1/":{"data":{"":"概率为 0 的事件不一定不发生，\n概率为 1 的时间不一定发生。\n不太清楚概率统计是否有名称相似但学分不同的课程，这里也设置分目录。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 11022601-概率与统计-3学分 "},"title":"_index"},"/docs/%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A1/11022601-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A1-3%E5%AD%A6%E5%88%86/":{"data":{"":"2024 年上这门课的老登表示：\n本课程考核方式较为固定，复习时可参照往年试题。\n** 速通考试 ** 主要是理解题型和概念，很多同学高中已经学习了概率论的基本知识。如果你有课程笔记，欢迎一起上传。 推荐视频课：\n《概率论与数理统计》4 小时速成课 | 框框老师（突击课，适合大学数学期末考试、期中考试、补考、重修、专升本，考试不挂科） ——Light 2025.4.15\n批量下载\r文件名\r文件大小\r最后修改日期\r2022春季概率与统计a卷\rpdf\r171.2 KB\r2024/06/15\r171.2 KB\r2024/06/15\r2022春季概率与统计a卷答案\rpdf\r251.0 KB\r2024/06/15\r251.0 KB\r2024/06/15\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF/":{"data":{"":"很多学院都开设模拟电子线路这门课程，\n04026804 是自动化学院 3.5 学分的模电课程\n使用时请务必核对课程编号。\n欢迎更多贡献\n——Light","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 04026804-3.5学分-模拟电子线路 "},"title":"_index"},"/docs/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF/04026804-3.5%E5%AD%A6%E5%88%86-%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF/":{"data":{"":"模拟电子线路（下简称模电）\n是自动化学院各专业的必修课\n很多人将模电与数电并称一生之敌。\n自 2022 级开始，模电试卷题型存在较大变化，如考题大量出现 MOS 管等。\n请在使用往年题时分外小心。 ——Light 2025.4.14\n批量下载\r文件名\r文件大小\r最后修改日期\r模拟电子线路-04026804-3.5\rpdf\r1.3 MB\r2024/06/22\r1.3 MB\r2024/06/22\r模拟电子线路试卷\rpdf\r16.0 MB\r2024/06/26\r16.0 MB\r2024/06/26\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/":{"data":{"":"机械学院测试技术课程，含试卷与复习资料","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 01023703-2学分-测试技术 "},"title":"_index"},"/docs/%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/01023703-2%E5%AD%A6%E5%88%86-%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/":{"data":{"":"如果你看到这样文字，说明原目录缺少 README.MD，请完善目录介绍。\n批量下载\r文件名\r文件大小\r最后修改日期\r01023703-2学分-测试技术2019A - 答案\rdoc\r105.0 KB\r2025/04/15\r105.0 KB\r2025/04/15\r01023703-2学分-测试技术2019A\rdoc\r87.5 KB\r2025/04/15\r87.5 KB\r2025/04/15\r01023703-2学分-测试技术2019B - 答案\rdoc\r205.5 KB\r2025/04/15\r205.5 KB\r2025/04/15\r01023703-2学分-测试技术2019B\rdoc\r39.0 KB\r2025/04/15\r39.0 KB\r2025/04/15\r复习题汇总123\rpdf\r864.8 KB\r2025/04/15\r864.8 KB\r2025/04/15\r总复习(2学分)\rppt\r233.0 KB\r2025/04/15\r233.0 KB\r2025/04/15\r测试技术总复习\rpdf\r613.9 KB\r2025/04/15\r613.9 KB\r2025/04/15\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E7%94%B5%E8%B7%AF%E5%AE%9E%E9%AA%8C/":{"data":{"":"电路综合实验，实验内容主要包括验证 KVL \\ KCL，叠加定理等。 收集了自动化学院的04061601\t电路综合实验课程数据，理论上各电类专业均学习该课程。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 04061601-1学分-电路综合实验 "},"title":"_index"},"/docs/%E7%94%B5%E8%B7%AF%E5%AE%9E%E9%AA%8C/04061601-1%E5%AD%A6%E5%88%86-%E7%94%B5%E8%B7%AF%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/":{"data":{"":" 课程编号 课程名称 开课单位 学分 总学时 考核方式 课程性质 04061601 电路综合实验 电子工程与光电技术学院 1 40 考查 必修 本课程是电路的配套课程。 需要下载美国 NI 公司的 Multisim 软件进行仿真。 安装方法稍后上传（咕咕咕\n上传了实验 PPT 及仿真报告。 ——Light 2025.4.16\n批量下载\r文件名\r文件大小\r最后修改日期\r基于Multisim14.3的日光灯电路功率因数提高分析\rpdf\r892.6 KB\r2024/01/31\r892.6 KB\r2024/01/31\r电路综合实验基础实验讲义\rpptx\r40.8 MB\r2023/09/11\r40.8 MB\r2023/09/11\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E7%94%B5%E8%B7%AF/":{"data":{"":"在自动化学院，电路这门课就叫电路，有 3.5 学分，课程编号 04061501\n由于其他学院也有简称为电路的课程，但编号不太一样，这里创建子目录用以区分。\n目前只收集了自动化学院的电路课程。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 04061501-3.5-电路 "},"title":"_index"},"/docs/%E7%94%B5%E8%B7%AF/04061501-3.5-%E7%94%B5%E8%B7%AF/":{"data":{"":" 课程编号 课程名称 开课单位 学分 总学时 考核方式 04061501 电路 电子工程与光电技术学院 3.5 56 考试 在自动化学院，这门课程就叫做电路，具有 3.5 个学分。\n特别注意，课外机构所贩售的《学解》试题解存在较大问题，包括但不限于混淆不同学分及培养方案的试卷、答案存在问题等，建议不要购买。\n批量下载\r文件名\r文件大小\r最后修改日期\r超烂扫描电路试题\rpdf\r28.3 MB\r2024/04/10\r28.3 MB\r2024/04/10\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/":{"data":{"":"收集了自动化学院用的2.5学分线性代数。有其他学分线性代数请创建子目录。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 11031201-2.5学分-线性代数 "},"title":"_index"},"/docs/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/11031201-2.5%E5%AD%A6%E5%88%86-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/":{"data":{"":"老学长的碎碎念 线性代数，这门课往往给人一种学完以后“平时感觉不到用处，真正要用时却无从下手”的印象。(南理工大部分非实践类课程均如此) 不过随着后续专业课程的深入学习，以及在实际应用场景中的实践，我们会逐步领悟到线性代数的精妙之处，对它产生更透彻的理解。 正所谓： 不是先学好了再干，而是干起来再学习，干就是学习。\n不过，自动化学院的我们不必钻研到极致深度，这门课学分仅为 2.5 分。\n** 期末速通资源推荐** 如果期末考试临近，你想快速掌握线性代数的关键知识点，顺利通过考试，不妨参考以下课程：\n《线性代数》4 小时速成课（不挂科）| 框框老师\n3 小时根本讲不完《线性代数》/ 纯板书 /《线代》/《线性代与空间解析几何》/《代数与几何》/ 哈工大 / 考前复习\n** 基础概念入门视频**\n要是你刚接触线性代数，对那些抽象的概念一头雾水，完全不清楚这门学科在研究什么，那么下面这个视频是绝佳的入门选择：\n【熟肉】线性代数的本质 - 01 - 向量究竟是什么？\n——Light 2025.4.15\n批量下载\r文件名\r文件大小\r最后修改日期\r线代试卷(2.5)(19.12.11))\rpdf\r137.8 KB\r2024/01/02\r137.8 KB\r2024/01/02\r线代试卷(2.5)(19.12.11))答案\rpdf\r175.9 KB\r2024/01/02\r175.9 KB\r2024/01/02\r线代试卷(2.5)(19.5.8)\rpdf\r139.4 KB\r2024/01/02\r139.4 KB\r2024/01/02\r线代试卷(2.5)(19.5.8)答案\rpdf\r195.4 KB\r2024/01/02\r195.4 KB\r2024/01/02\r线代试卷(2.5)(20.12.9)\rpdf\r157.3 KB\r2024/01/02\r157.3 KB\r2024/01/02\r线代试卷(2.5)(20.12.9)答案\rpdf\r159.1 KB\r2024/01/02\r159.1 KB\r2024/01/02\r线代试卷(2.5)(20.6.30)\rpdf\r138.9 KB\r2024/01/02\r138.9 KB\r2024/01/02\r线代试卷(2.5)(20.6.30)答案\rpdf\r152.9 KB\r2024/01/02\r152.9 KB\r2024/01/02\r线代试卷(2.5)(21.05.28)\rpdf\r135.1 KB\r2024/01/02\r135.1 KB\r2024/01/02\r线代试卷(2.5)(21.05.28)答案\rpdf\r135.5 KB\r2024/01/02\r135.5 KB\r2024/01/02\r线代试卷(2.5)(21.12.2)\rpdf\r157.3 KB\r2024/01/02\r157.3 KB\r2024/01/02\r线代试卷(2.5)(21.12.2)答案\rpdf\r134.8 KB\r2024/01/02\r134.8 KB\r2024/01/02\r线代试卷(2.5)(22.12.4)\rpdf\r224.5 KB\r2024/01/02\r224.5 KB\r2024/01/02\r线代试卷(2.5)(22.12.4)答案\rpdf\r130.9 KB\r2024/01/02\r130.9 KB\r2024/01/02\r线代试卷(2.5)(22.5.10) 试题答案\rpdf\r135.0 KB\r2024/01/02\r135.0 KB\r2024/01/02\r线代试卷(2.5)(22.5.10))\rpdf\r126.0 KB\r2024/01/02\r126.0 KB\r2024/01/02\r线代试卷(2.5)(23.1.6)\rpdf\r117.3 KB\r2024/01/02\r117.3 KB\r2024/01/02\r线代试卷(2.5)(23.1.6)答案\rpdf\r138.0 KB\r2024/01/02\r138.0 KB\r2024/01/02\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/":{"data":{"":"大学生的历史课。全国学生应该都是一个考纲。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 15042402-3学分-中国近现代史纲要 "},"title":"_index"},"/docs/%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/15042402-3%E5%AD%A6%E5%88%86-%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/":{"data":{"":" 课程编号 课程名称 开课单位 学分 总学时 考核方式 课程属性 15042402 中国近现代史纲要 马克思主义学院 3 48 考试 必修 上传了知识点\nLight 2025.4.16\n批量下载\r文件名\r文件大小\r最后修改日期\r近代史考点\rpdf\r40.8 MB\r2023/06/24\r40.8 MB\r2023/06/24\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E9%87%91%E5%B7%A5%E5%AE%9E%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/":{"data":{"":"考虑到大部分人都称之为金工实习\n故本课程目录取名为金工实习（工程实践）\n不同专业上课内容有所差异，不清楚学分是否一致，但考核内容和上课注意事项基本上是一样的，故创建本文件夹。\n有共同性内容可直接放置在本 README.md 里 请注意说明自己所属专业。\n上课可能需要穿着军训服，请提前准备好。 焊接课程缺少焊烟净化器，建议购买 N95 以上口罩以避免金属尘埃影响。 紫外辐射危险！切勿直视焊接电弧！务必穿戴好防护用具。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 22000002-2学分-工程实践 "},"title":"_index"},"/docs/%E9%87%91%E5%B7%A5%E5%AE%9E%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/22000002-2%E5%AD%A6%E5%88%86-%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/":{"data":{"":" 课程编号 课程名称 开课单位 学分 总学时 考核方式 课程属性 22000002 工程实践 工程训练中心 2 80 考查 必修 工程实践，一般称作金工实习，是大部分理工科学生的必修课。\n上课内容比较丰富，可以极大拓展动手能力。 自动化学院所上金工实习课程编号为 22000002 共两个学分\n部分上课内容可能较为枯燥，如出于 安全考虑 ，数控车、注塑机都不让使用，3D 打印机故障率超 60% ，导致部分课程上课只能干瞪眼。 更新：江阴校区工训中心购买了一大批拓竹 A1 打印机 应该能有很好的效果。\n——Light 2025.4.16\n批量下载\r文件名\r文件大小\r最后修改日期\r金工实习报告_QQ浏览器转格式\rpdf\r15.6 MB\r2025/04/15\r15.6 MB\r2025/04/15\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/":{"data":{"":"\r认真学习高等数学哦 Light 2025.4.16","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 11123301-5学分-高等数学（Ⅰ） 11223301-6学分-高等数学（Ⅱ） "},"title":"_index"},"/docs/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/11123301-5%E5%AD%A6%E5%88%86-%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/":{"data":{"":"\r认真学习高等数学哦 Light 2025.4.16\n批量下载\r文件名\r文件大小\r最后修改日期\r高等数学（上）_2001_A卷\rpdf\r131.5 KB\r2023/03/11\r131.5 KB\r2023/03/11\r高等数学（上）_2006_A卷_题目答案\rpdf\r230.6 KB\r2023/03/18\r230.6 KB\r2023/03/18\r高等数学（上）_2006_A卷_题目答案（样式2）\rpdf\r251.0 KB\r2023/03/11\r251.0 KB\r2023/03/11\r高等数学（上）_2018_期中A卷_题目\rpdf\r256.0 KB\r2023/11/08\r256.0 KB\r2023/11/08\r高等数学（上）_2018_期中B卷_题目\rpdf\r171.1 KB\r2023/11/08\r171.1 KB\r2023/11/08\r高等数学（上）_2020_期中A卷_答案\rpdf\r413.3 KB\r2023/11/08\r413.3 KB\r2023/11/08\r高等数学（上）_2022_A卷_题目答案\rpdf\r132.5 KB\r2023/03/11\r132.5 KB\r2023/03/11\r高等数学（上）_2024_A卷_题目\rpdf\r1.8 MB\r2024/01/30\r1.8 MB\r2024/01/30\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/11223301-6%E5%AD%A6%E5%88%86-%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/":{"data":{"":"认真学习高等数学哦 现在学不好，考研还要再学，\n批量下载\r文件名\r文件大小\r最后修改日期\r2020高等数学测试卷（一）\rpdf\r142.7 KB\r2023/11/08\r142.7 KB\r2023/11/08\r2020高等数学测试卷（一）答案\rpdf\r277.3 KB\r2023/11/08\r277.3 KB\r2023/11/08\r2022级高等数学模拟试卷答案（下）\rpdf\r156.4 KB\r2023/11/08\r156.4 KB\r2023/11/08\r高等数学（下）_2021_A卷_题目\rpdf\r192.9 KB\r2023/11/08\r192.9 KB\r2023/11/08\r高等数学（下）_2021_期中A卷_答案\rpdf\r416.4 KB\r2023/11/08\r416.4 KB\r2023/11/08\r高等数学（下）_2021_期中B卷_答案\rpdf\r222.8 KB\r2023/11/08\r222.8 KB\r2023/11/08\r高等数学（下）_2023_期中A卷_题目\rpdf\r140.2 KB\r2023/11/08\r140.2 KB\r2023/11/08\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/docs/c%E8%AF%AD%E8%A8%80/":{"data":{"":"C 语言是最好的编程语言！！\n06000704\tC 语言程序设计是自动化学院学习的 C 语言课程。貌似没有其他学院在学 C 语言了。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议","子目录#子目录":" 06000704-4学分-C语言程序设计 "},"title":"_index"},"/docs/c%E8%AF%AD%E8%A8%80/06000704-4%E5%AD%A6%E5%88%86-c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/":{"data":{"":" 课程编号 课程名称 开课单位 学分 总学时 考核方式 课程属性 06000704 C 语言程序设计 自动化学院 4 64 考试 必修 学习编程，一定要用电脑去写代码，去运行，去思考。 切忌使用纸笔死记硬背。 ——Light 2025.4.16\n批量下载\r文件名\r文件大小\r最后修改日期\r2014_C语言_期末考试_答案\rpdf\r239.1 KB\r2025/04/16\r239.1 KB\r2025/04/16\r2014_C语言_期末考试_试卷\rpdf\r647.9 KB\r2025/04/16\r647.9 KB\r2025/04/16\r2015_C语言_期末考试_答案\rpdf\r235.0 KB\r2025/04/16\r235.0 KB\r2025/04/16\r2015_C语言_期末考试_试卷\rpdf\r581.0 KB\r2025/04/16\r581.0 KB\r2025/04/16\r2016_C语言_期末考试_答案\rpdf\r255.6 KB\r2025/04/16\r255.6 KB\r2025/04/16\r2016_C语言_期末考试_试卷\rpdf\r681.2 KB\r2025/04/16\r681.2 KB\r2025/04/16\r2017_C语言_期末考试_答案\rpdf\r250.5 KB\r2025/04/16\r250.5 KB\r2025/04/16\r2017_C语言_期末考试_试卷\rpdf\r620.3 KB\r2025/04/16\r620.3 KB\r2025/04/16\r2018_C语言_期末考试_答案\rpdf\r230.4 KB\r2025/04/16\r230.4 KB\r2025/04/16\r2018_C语言_期末考试_试卷\rpdf\r623.8 KB\r2025/04/16\r623.8 KB\r2025/04/16\rC语言中的浮点数存储原则与内存示例\rpdf\r371.4 KB\r2025/04/16\r371.4 KB\r2025/04/16\r哎呀，相关文件已全部呈现完毕啦 (っ °Д °;) っ\r欢迎前往 课程仓库 提交 PR 查看《参与指南》了解详情。","参与#参与":"《NJUST 课程攻略共享计划》是所有同学都可以参与编写的，如果你有好的笔记或者资料，欢迎前往我们的 GitHub 进行参与。任何问题都可以发邮件至 📮hi@njust.wiki 联系我们，我们会在收到的第一时间进行答复。\n© 版权声明：知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议"},"title":"_index"},"/faq/":{"data":{"":"有问题可在本页面下方评论提出。"},"title":"常见问题"},"/links/":{"data":{"":"","个人博客#个人博客":"校内社群\rHITSZ 开源技术协会HITSZ OSA 社团落地页\r转码交流群931621912\r哈工深留学交流群917854892\r项目推荐\rHITSZ-OpenCS哈尔滨工业大学（深圳）计算机专业课程攻略\rHITSZ-OpenDS哈尔滨工业大学（深圳）大数据专业课程攻略\r哈工大深圳网盘计划Drive based on FeiShu\rHITSZ 新生手册面向全体哈工大（深圳）学生的信息共享手册\rOSA Alist 网盘托管在 OSA 的资料备份\r一键导入课程表\r课程回放需要通过校园网访问\r《你缺计课》适合小白的计算机入门课\rOSA 开源软件镜像站校内镜像站\rHSICA 飞跃手册校区出国申请案例的文档\r大工生存手册大工人的一站式生存指南\rSCUTEEE华南理工电力电子类专业知识库\rHITSZ Connect Verge校外访问校园网\rCityU GuideBookA comprehensive platform for CityUHK students\r个人博客\rlonglin 的个人小站Simple is Complex\rLongbin's Blog个人技术博客，记录所学的一切知识\r吴俊达的个人主页Please stay tuned!\rℹ️\r我们会收录的链接包括但不限于：\n校内社群 校内/友校类似项目 个人博客 你可以通过在 本项目仓库提 issues ｜ 发送邮件至 📮hi@hoa.moe ｜ 本页面下评论 的方式与我们交换友链","校内社群#校内社群":"","项目推荐#项目推荐":""},"title":"友链"},"/news/":{"data":{"":"\rRSS 订阅 "},"title":"新闻"},"/news/1st-anniversary/longlin/":{"data":{"":"","timeline---我在-openauto-的那些-commit#TimeLine - 我在 OpenAuto 的那些 commit":"","前言#前言":"","尾记#尾记":"本文亦见于 Longlin 的个人主页。\n前言\r截止 2024.10.25 ，HOA 已达成 GitHub 195 位关注者，接待了 1.8w 位用户，产生了 22w 个 Page-View 事件。\n说实话，我完全没有料到 HOA 能发展到现在这种规模，毕竟组织成员们都是非计算机专业的在校生，而且只能利用课余时间进行开发。可是，就是这么一个「不专业」的团队，仅凭大家的热心与兴趣，也能通过 commit 的不断累积打造出一款在「专业」内颇受欢迎的产品，我想这便是开源的魅力吧。\nTimeLine - 我在 OpenAuto 的那些 commit\r2022年8月\r我提交了人生第一个 PR，当时的我甚至连 GitHub 的操作流程都不熟悉，只是因为在群里看到有个资料共享计划的宣传，点进链接后发现仓库里有些课程缺少相关资料，便把之前从 Zlib 里下载的工图 PDF 上传了。现在看来，那个夏天，便是一切的开端呢（笑）\n2023年3月\r当时学校是第一年在大一开设「自动化认识与实践」考试课，由于没有前人的资料参考，实验指导书更是靠不住，大家或多或少都踩了不少坑，结题时学生和老师间还闹出了一点不愉快事件，因此，很有必要留下一些 文字/资料 给下届学弟学妹参考。正好看到 Maxwell Jay 在仓库更新了一些相关资料，于是便顺手补充了一些之前集中的资料（PR）\n2023年6月 - 2023年9月\r这段时间的 PR 主要是针对刚刚结课的大一课程补充资料与说明，完善改进了下目录结构。这期间我提了我的第一个 issue，促成了 OpenAuto 仓库由个人维护转为组织维护。\n2023年10月\r10 月 12 日，Maxwell Jay 发布了 issue#49，面对仓库日益增大的问题，我们开始商讨如何对仓库进行拆分，大物实验 IA 作为第一个被分离出来的仓库，如今已经获得了57 个 star。\n10 月 28 日，Longbin 学长给所有 OpenAuto 项目的活跃开发者抄送了一封邮件：\n咱们的 OpenAuto 2.0 计划算是正式启动了！\n2023年11月\r计划已经启动，接下来便是技术选型和开发了。\n11 月 6 日，在 Longbin 学长搭建的 Jekyll 网站基础上，Mither 用更现代的 Hugo 框架重新构建了一版前端，同时采用了一直用到现在的 Hextra 主题。我在当天贡献了新项目的第一个 commit：\n至此，我们项目的整体流程已经明晰————抓取各仓库的 markdown 文档后再使用 Hugo 在前端进行页面渲染。\n11 月 7 日 -9 日，我在原 action 基础上进行了修改，实现了自动抓取组织下所有匹配的课程仓库的脚本，同时借助 tag.txt 对课程文档进行分类。（PR）\n主要功能实现后，剩下的便是搬运仓库和一些 CSS 上修修补补的工作了。当时还尝试了一些有意思的动画，不过由于不太合适所以最终还是被 discard。\n整个 11 月我们的 QQ WorkGroup 可谓热火朝天，几乎每天都有人贡献新 feature，网站的迭代速度非常快。\n2023年12月\r12 月 1 日，整个新项目基本成型。同天，正式告别老仓库（PR#54）\n12 月 2 日，OpenAuto 2.0 正式官宣🎉\n发布当天，我们的 fo 数就涨到了 50 人，也有热心同学对我们进行了打赏赞助。\n2023 年剩下的时间，我们主要为网站新增了 博客 与 友链 界面，自此，OpenAuto 的功能在资料下载基础上又向外拓展了不少。我也在此时写了一篇贡献帮助文档（PR），这份贡献指南后面还经过了几次改版，不过都是后话了。\n2024年\r除了一些日常维护工作，我们也在思考如何改进我们的网站————新文档、新博客、VTuber logo、License 展示、AI 新闻周报、RSS 订阅……\n相信 HOA 会越做越好！（我们可能会倒闭，但绝不会变质\n尾记\r不知不觉，新版 HOA 也迎来了一周岁生日，我也陪这个新生开源项目走过了第一年。从草创时期到稳定维护时期，我实实在在体会到了开源的乐趣，很幸运我能在刚接触开源什么都不懂的时候遇见它，更幸运的是，我通过开源遇见了一群志同道合的伙伴，请容许我用最朴素的文字对你们表示衷心的感谢！\n最后的最后： OpenAuto，生日快乐。"},"title":"✏ 写在 HOA 一周年之际"},"/news/1st-anniversary/oliverwu/":{"data":{"":"","从单人到团队#从单人到团队":"","日常维护#日常维护":"","缘起#缘起":"","致谢与展望#致谢与展望":"本文亦见于 Oliver Wu 的个人博客。\n缘起\r我一直对资料共享有着浓厚的兴趣，一直是自救群（一个供学生交流学习相关问题、分享学习资料的 QQ 群）活跃的资料贡献者和管理者。\n2023 年 3 月，机缘巧合之下，我接触了 HITSZ OpenAuto 项目，当时这个项目还是一个单独且硕大的仓库，课程资料按照学期组织。我对自己参与制作的「暑期电路补习」资料颇为满意，怀着让更多同学从这份资料受益的心愿，我便将其上传至「大一下/电路」的文件夹了。当时还不懂 Git 为何物，只知道从网页端笨拙地十个十个文件上传，因此平添了若干 dirty commits。现在想来，当时的自己多么稚嫩。\n从单人到团队\r继上面的贡献之后，我又在电路 IA 课程文档中留下了些许学习建议，此后便没再过多关注。10 月份，我偶然地收到 Longbin 学长的一封邮件，邮件中说，OpenAuto 已从一个大仓库转为组织方式维护，邀请我成为维护团队的一员，我很高兴地接受了邀请。\n随后我们进行了多次讨论。我们感受到，QQ 群文件多易受年级区隔，且文件夹支持不便，用 GitHub 仓库方式维护能够方便管理提交记录，且方便代际资料的组织。不过要将原有项目推向更大的用户群，且吸纳更多的维护者，难点有二：\n一是针对使用者而言的。成功连接 GitHub 对于使用者而言有一定要求，因此为了降低使用门槛，急需直白清晰的前端页面，且要能在国内顺畅地访问到。于是几位前端开发者共同努力，选用 Hugo 作为引擎、Hextra 作为主题，打造了现在按学期组织、学期内以课程类别排序的呈现效果，还购买了现在这个短小可爱的域名。\n二是针对维护者而言的。原仓库规模太大，整体拉取耗时长、占空间；而且之前仓库文件结构较为混乱，不方便维护。因此我们定下了按照课程分别建立子仓库、且规范文件夹与资料命名的目标。于是几位同学齐心协力，花了一个月把各门课程资料分别迁移出来。我主要负责了这份工作。\n前端页面需要依赖各仓库的信息来生成，所以我们在各页面下建立了 tag，通过该文件来识别课程类型与名称，再根据文件夹和文档内容生成页面。当时，为了实现心目中的课程资料目录架构，并不擅长前端编写的我自告奋勇地接手了这项任务，虽然结果还不错，但是过程嘛……（捂脸）\n上面工作的完成，宣告着 OpenAuto 2.0 的正式成型。12 月初，我们在自救群和空间发布了海报，得到了同学们热切的回应。\n日常维护\r在项目正式发布之后，很少再有项目伊始那种大刀阔斧的增删，取而代之的是琐碎的维护和更新。每天，我辗转于各个仓库之间，创建 commit、审核与合并各种各样的 pr。虽然比较繁琐，但我看着资料越来越丰富、文档越来越完善，成就感难以言表。我过去一年的 commit 中，至少有 90% 是在 OpenAuto 中提交的。\n虽说总体框架不再有变动，核心维护团队成员总能以各种各样的新点子予我惊喜。比如，全新的 VTuber Logo 和周边贴纸；越来越丰富且友好的参与指南和 commit message 提示；利用 Hextra 短代码生成的文件下载界面和信息提示框；利用 GPT 生成的 AI 周报总结；随着仓库内容更新而自动触发的课程页面更新…… 在这样一个活跃的团队中工作，我也充满激情。\n核心维护者外的贡献者们也带来了一篇篇优质的博客、一份份用心撰写的学习建议和课程资料，不断为这个项目注入新的活力。\n致谢与展望\r感谢主攻网页前端开发的维护者们（以及网站框架与主题的作者），清晰简约的界面离不开你们的努力；你们还使得贡献者得以专注于资料的更新，维护者得以最大限度发挥在资料管理方面的热情和能力。\n感谢所有和我一起负责资料管理的维护者们，你们高效率的审核与回复是资料及时更新的基础，让我感受到「事事有着落」的安全感。\n感谢 OSA 提供的网盘基础设施支持，感谢校内类似项目维护者提供的宝贵经验。\n感谢所有资料、文档贡献者，你们的支持与贡献让我们感受到，在知识共享、减少弯路的途中，我们并不孤寂。\n还要感谢向我们提出意见和建议以及打赏我们的同学。\n在这一年里，OpenAuto 日渐成熟。然而，仍有不少问题值得我们进一步探索，例如资料的利用态度问题、维护的可持续性问题、网站的呈现方式问题等。也希望大家多提意见和建议、多多贡献资料。\n最后，OpenAuto，生日快乐。"},"title":"🖊 OpenAuto 一周年生日纪"},"/news/daily/":{"data":{"":"","待合并的-pull-requests#待合并的 Pull Requests":"更新内容\r周五 (2.14)\rW·D·Gaster 在 工程训练（电子工艺实习） 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件，修改文档格式 (#2) 待解决的 Issues\rDifficulty cloning this repository\r仓库: MATH1002 创建于: 2025-01-20 15:32:37 作者: MaxwellJay256 标签: help wanted AUTO3011\r仓库: AUTO3011 创建于: 2025-01-19 21:16:38 作者: MaxwellJay256 微积分\r仓库: MATH1015A 创建于: 2025-01-19 12:00:29 作者: WDGaster703 线代\r仓库: MATH1002 创建于: 2025-01-19 11:52:13 作者: WDGaster703 待合并的 Pull Requests\r以 .gitkeep 文件替代无用的 readme.md 文件，补充分班和免听相关\r仓库: LANG100X 创建于: 2025-02-07 16:04:26 作者: WDGaster703 修改 readme 格式，修改部分文件命名并进行归类\r仓库: EE1011A 创建于: 2025-01-19 15:28:31 作者: WDGaster703 ","待解决的-issues#待解决的 Issues":"","更新内容#更新内容":""},"title":"AUTO 更新速递"},"/news/survey/":{"data":{"":"OpenAuto 的第一次问卷调查来啦，希望屏幕前的你可以抽出几分钟时间填写，让我们更了解我们的社区和用户。\n参与方式（选择其中一种即可）：\n点击 问卷链接 填写问卷\n扫描下方二维码填写问卷："},"title":"问卷调查"},"/news/weekly/weekly-2024-05-09/weekly-2024-05-09/":{"data":{"":"","ai-摘要#✨AI 摘要":"","新核心维护者#新核心维护者":"","新贡献者#新贡献者":"","最近更新#最近更新":"✨AI 摘要\r本周提交报告充满了忙碌的痕迹：Kowyo 同学修复了一些格式问题，不过却在调整 yaml 时变得更\"特别\"，ci 出现的问题也频频困扰着他；还有 Maxwell Jay 同学将课程移至已存档状态，笑中带泪；以及 longlin li 同学一直活跃在各 README.md 的更新中，努力为项目添砖加瓦。周三，oldkingOK 同学大胆地迎接中国红色文化精神；周日，IcyDesert 同学深刻探讨了 MOOC 失败的影响，longlin li 同学则频频更新 README，不忘完善项目。整体而言，提交报告中充满了努力、欢乐和一丝丝困惑，展现了项目组的活力和奋斗精神，敬请期待下一周的更多惊喜！\n新贡献者\roldkingOK 在 MOOC 中提交了第一次 PR，我们非常欢迎本部/威海的同学参与到我们的项目当中❤️ YinMo 在 MATH1015A 中起了第一次 commit。 AutoFriedRich 在 AUTO2006 中提交了第一次 PR。 新核心维护者\rYinMo AutoFriedRich IcyDesert 最近更新\rhoa.moe\r本周我们在网页上新设了新闻版块，在此汇总近日来 OpenAuto 上的更新。我们打算将其以周报的形式公布，大家可以进行每周追番了。周报目前采取 GitHub API 汇总每周 Commit，ChatGPT 生成总结，核心维护者手动修改的模式。所以大家一定要用中文写好 commit 呀。 网页最近上新了两个新课程分类：文理通识与 MOOC 及 跨专业选修。 针对很多想要贡献 OpenAuto 但不太了解 Git 的同学，我们重新修订了一份 《参与指南》，并且加入我们所认同的社区公约，我们期待您的参与！ 更新了 关于 页面，你有发现与之前相比不一样的地方吗？ 控制理论中的代数基础\rAutoFriedRich 更新了课程描述，分享学习经验 MOOC\roldkingOK 为仓库新增 中国红色文化精神 相关资料 IcyDesert 为 MOOC 页面补充新文档说明 微积分 A\rYinmo 同学为仓库新增 先修 相关课程描述 机器人学导论\rOliverWu 补充课程描述 机器视觉\rOliverWu 上传了 2024 年考试题回忆版 Kowyo 上传了复习笔记 以下课程由 MaxWell Jay 设置为归档：\n电路实验 IA\n电路实验 IB\n电路 IA\n电路 IB"},"title":"AUTO 周报 2024-05-09 - 2024-05-16"},"/news/weekly/weekly-2024-05-17/weekly-2024-05-17/":{"data":{"":"","ai-摘要#✨AI 摘要":"","新贡献者#新贡献者":"","最近更新#最近更新":"✨AI 摘要\r本周的提交报告包括了多个课程内容的更新和修正，其中包括电路与电子学、机器人学导论、大学化学等多门课程。同时，还有一些仓库进行了自动化构建的调整以及权限问题的修复。整体来看，本周的提交内容涵盖了课程材料的更新和优化，以及仓库操作的维护和改进。\n新贡献者\r345ljh 在 机器人学导论 中第一次 commit 和创建 PR。\n最近更新\rhoa.moe\r文档增加版权信息（#20)。\n新闻板块增加更新速递，显示最近一次课程文档更新情况。\n课程文档\r周四（5.23）\n（21:17）电路与电子学：（IcyDesert）补充更多模电、数电网课推荐，并附上食用方法\n（16:27）电路与电子学：（IcyDesert）修正关于授课教师的描述；补充模电网课\n周三（5.22）\n（13:09）机器人学导论：（345ljh）上传考试 A4 (#4)\n（0:00）大学化学 III：（Maxwell Jay）完善课程文档，删除关于教师的描述\n周一（5.20）\n（22:02）MOOC：（Kowyo）新增《知识产权法律及实务》课的找答案的方法 (#5) 周日（5.19）\n（14:28）大学物理实验：（Maxwell Jay）新增巨磁阻效应与应用的实验绘图程序等内容；更新 README：添加警告 (#24)\n（14:16）创新训练课 B：（Maxwell Jay）更新 README：novemberinnorth 分享了自己的创 B 项目"},"title":"AUTO 周报 2024-05-17 - 2024-05-24"},"/news/weekly/weekly-2024-05-24/weekly-2024-05-24/":{"data":{"":"","ai-摘要#✨AI 摘要":"","新贡献者#新贡献者":"","最近更新#最近更新":"✨AI 摘要\r本周的提交报告如下：\n周四，Sieroy 在创新训练课 B 项目中新增了一个项目分享。 周三，Kowyo 在机器视觉项目中删除了一些代码。 周日，fffish12333 上传了《机器人学导论》（2024 年春）的笔记。 新贡献者\rfffish12333 在 机器人学导论 中第一次 commit 和创建 PR\n最近更新\r周四（5.30)\r（11:49）创新训练课 B：（Sieroy）新增一个项目分享 (#5) 周三（5.29)\r（14:07）机器视觉：（Kowyo）Remove code 周日（5.26)\r（0:31）机器人学导论：（fffish12333）上传一份《机器人学导论》（2024 年春）笔记 "},"title":"AUTO 周报 2024-05-24 - 2024-05-31"},"/news/weekly/weekly-2024-06-07/weekly-2024-06-07/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r本周的提交报告显示在开源汽车组织中的各个项目都有更新。主要包括 README.md 文件的更新、大学物理实验示例项目的初始提交、自动化认知与实践项目的学期更新、机器视觉课程设计解决方案的增加，以及模拟电子技术实验项目文件的整理和机器人学导论项目的作业和实验代码部分的添加。整体看来，本周有较多项目的更新和进展。\n周三（6.12)\r（2:25）自动化认知与实践：（吴俊达）Update semester 周二（6.11)\r（21:44）机器视觉：（吴俊达）增加一个课程设计解决方案 (#4)\n（15:30）机器视觉：（345ljh）上传课设选题 2 (#3)\n周一（6.10)\r（20:13）模拟电子技术实验：（YinMo19）将原有文件归档到文件夹下，新增 LJH 的实验报告 (#2) 周日（6.9)\r（20:11）机器人学导论：（吴俊达）新增作业 3-6 代码部分和实验 1-4 "},"title":"AUTO 周报 2024-06-07 - 2024-06-14"},"/news/weekly/weekly-2024-06-14/weekly-2024-06-14/":{"data":{"":"","#":"周四（6.20)\r（1:17）过程控制系统：（Kowyo）添加课程教材信息 周三（6.19)\r（23:10）数字电子技术实验：（345ljh）添加 2023 学年实验报告 (#2) 周一（6.17)\r（20:29）自动控制实践 B：（Kowyo）更新分数组成 "},"title":"AUTO 周报 2024-06-14 - 2024-06-21"},"/news/weekly/weekly-2024-06-21/weekly-2024-06-21/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r本周共提交了两份代码更新。周二，吴俊达为自动控制实践 B 项目增加了一份复习笔记。周六，Kowyo 更新了自动控制理论 B 项目的课程分数构成情况。\n周二（6.25)\r（18:46）自动控制实践 B：（吴俊达）增加复习笔记一份 周六（6.22)\r（20:21）自动控制理论 B：（Kowyo）更新课程分数构成情况 "},"title":"AUTO 周报 2024-06-21 - 2024-06-28"},"/news/weekly/weekly-2024-06-28/weekly-2024-06-28/":{"data":{"":"","人工摘要#✨人工摘要":"✨人工摘要\r本周是 21 级自动化的考试周最后一周。结束了紧张的考试之后，OpenAuto 又可以进入紧锣密鼓的更新之中了，欢迎未投稿/贡献过的同学联系我们 OpenAuto 的维护者，或者直接参与我们的贡献❤！\n周四（7.4）\r（20:50）机器人学导论：（吴俊达）更新作业、实验报告、课设版本各一 (#7) 周三（7.3）\r（16:49）概率论与数理统计：（AutoFriedRich）更新了一些学习建议 (#2) 周一（7.1）\r（22:16）数字电子技术基础：（oliver-wu）更新试题答案\n（19:36）自动控制理论 B：（oliver-wu）新增一个实验报告版本、一份复习笔记\n周日（6.30）\r（13:57）自动控制理论 A：（吴俊达）更新 2023 试题考点回忆版\n（13:54）数字电子技术基础：（oliver-wu）更新 2023 试题及答案\n周六（6.29）\r（5:22）系统建模与仿真：（oliver-wu）新增实验报告版本\n（4:45）理论力学Ⅱ：（oliver-wu）更新 2023 试题答案\n（2:57）线性系统理论：（oliver-wu）添加作业答案"},"title":"AUTO 周报 2024-06-28 - 2024-07-05：考完了终于考完了"},"/news/weekly/weekly-2024-07-05/weekly-2024-07-05/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r本周的提交报告显示，团队成员在多门课程项目上取得了进展。主要包括整理上传考试题和资料，更新 README 文件，以及添加实验报告。其中涉及的课程有理论力学、模拟电子技术基础、毛泽东思想和中国特色社会主义理论体系概论等。还有一个项目更新了近现代史纲要串讲文件，加入了新的背诵方法。总体来看，团队在不同课程项目上都有积极的工作进展。\n周五（7.12）\r（11:55）理论力学Ⅱ：（MaxwellJay256）整理及上传考试题、编辑 README\n（11:14）模拟电子技术基础：（MaxwellJay256）整理及上传资料、更新 README\n（10:54）毛泽东思想和中国特色社会主义理论体系概论：（Maxwell Jay）Update tag.txt\n（10:49）大学物理实验：（Peng Shangpin）添加 22 级 psp 实验报告 (#25)\n周日（7.7）\r（12:15）中国近现代史纲要：（IcyDesert）更新 2023 级近现代史纲要串讲文件；加入意义类背诵方法论 (#4) 周六（7.6）\r（12:13）毛泽东思想和中国特色社会主义理论体系概论：（MaxwellJay256）编写 README；上传各种资料\n（11:27）数字电子技术基础：（MaxwellJay256）整理以及上传各种资料"},"title":"AUTO 周报 2024-07-05 - 2024-07-12"},"/news/weekly/weekly-2024-07-12/weekly-2024-07-12/":{"data":{"":"","ai-摘要#✨AI 摘要":"","新贡献者#新贡献者":"✨AI 摘要\r本周共有多个课程进行了更新，包括微积分 A、微积分 B、马克思主义基本原理、hoa-moe 等。更新内容主要包括添加新的笔记、更新选课指南、更新使用指南等。同时，还有一些课程进行了合并请求和修正细节等操作。周二的更新主要集中在信号分析与处理、自动控制实践 B、马克思主义基本原理等课程上。周一和周日的更新也比较频繁，更新内容涵盖了概率论与数理统计、casio FX-991CNX 的使用指南等。周六和周五也有部分实验课程更新了笔记或实验报告。整体来看，本周课程更新内容丰富，内容涵盖了多个课程领域，在不同层面都有所改进。\n新贡献者\rdrq 在 hoa-moe 中第一次投稿博客《卡西欧 FX-991CNX 计算器使用指南》，欢迎大家阅读！\n周四（7.18）\r（17:37）微积分 A：（Peng Shangpin）add new note (#5)\n（17:35）微积分 B：（Peng Shangpin）add psp’s note (#4)\n（17:29）马克思主义基本原理：（Peng Shangpin）add psp note (#7)\n（16:27）hoa-moe：（吴俊达）更新选课指南\n周二（7.16）\r（23:00）自动控制实践 B：（AutoFriedRich）增加了 Abigzhe 的自控实践复习整理的笔记\n（22:47）马克思主义基本原理：（AutoFriedRich）2022 马克思原理个人整理笔记 by 零雨其濛\n周一（7.15）\r（14:36）hoa-moe：（drq）更新 casio FX-991CNX 使用指南 (#132)\n（14:34）概率论与数理统计：（Peng Shangpin）更新笔记 (#4)\n周日（7.14）\r（18:04）hoa-moe：（drq）更新 casio FX-991CNX 的使用指南 (#131)\n（17:32）hoa-moe：（drq）更新 casio FX-991CNX 使用指南的一些细节 (#130)\n（0:16）hoa-moe：（drq）how-to-use-casioFX991CNX (#129)\n（0:05）数字电子技术实验：（Maxwell Jay）Update README.md\n（0:00）大学物理实验：（吴俊达）更新学期、补充 README；删除因为大小写原因重复的文件夹 EXP24 (#26)\n周六（7.13）\r（20:40）数字电子技术实验：（Peng Shangpin）add psp’s report (#3)\n（20:39）模拟电子技术实验：（Peng Shangpin）add psp’s report(#3)\n周五（7.12）\r（19:33）概率论与数理统计：（psp_dada）add new note\n（15:13）复变函数与积分变换：（psp_dada）add new note\n（15:03）代数与几何：（psp_dada）add new note\n（14:51）大学物理：（psp_dada）add new notes\n（14:33）毛泽东思想和中国特色社会主义理论体系概论：（psp_dada）add new note\n（14:24）理论力学Ⅱ：（psp_dada）add new note\n（13:55）数字电子技术基础：（psp_dada）add new note\n（13:47）模拟电子技术基础：（psp_dada）fix typo\n（13:41）模拟电子技术基础：（psp_dada）add new notes\n（13:06）自动化认知与实践：（Peng Shangpin）Update README.md"},"title":"AUTO 周报 2024-07-12 - 2024-07-19"},"/news/weekly/weekly-2024-07-19/weekly-2024-07-19/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r每周提交报告总结（7 月 21 日至 7 月 26 日）\r在过去的一周中，多个项目进行了积极的更新与改进。以下是主要的提交记录：\n周五（7.26）：修正了游泳课的泳道长度描述，并更新了 README 文档。 周四（7.25）：合并了多个请求，更新了选课指南，并上线了新课程。 周三（7.24）：修正了关于游泳课的考试信息，并更新了相关脚本。 周二（7.23）：更新了日语 I 课程的标签和 README 文档。 周一（7.22）：更新了模式识别课程的教材和学习建议，并对 README 进行了更新。 周日（7.21）：新增网球课程说明，上线了运动控制系统课程，并更新了多门课程的 README 文档及相关信息。 总体来看，这周的更新集中在课程上线、教材更新及文档修正方面，为师生提供了更好的学习资源和信息。\n周五（7.26）\r（12:14）体育：（longlin li）fix: 游泳课泳道长度描述\n（9:21）.github：（GitHub Actions）ci: update README.md\n周四（7.25）\r（18:22）hoa-moe：（吴俊达）Merge pull request #139 from HITSZ-OpenAuto/ow1\n（18:10）hoa-moe：（oliver-wu）更新选课指南\n（17:57）机器学习概论：（oliver-wu）上线新课程\n（17:55）机器学习概论：（吴俊达）Initial commit\n周三（7.24）\r（18:08）体育：（Kowyo）£hei 仔🐷：修正关于游泳课考试的情况\n（12:48）hoa-moe：（Kowyo）fix: update update_about.py\n（12:37）hoa-moe：（Kowyo）fix: update token name in update_about.py\n（9:22）.github：（GitHub Actions）ci: update README.md\n周二（7.23）\r（11:58）日语 I：（longlin li）Update tag.txt\n（11:56）日语 I：（longlin li）Update tag.txt\n（11:55）日语 I：（longlin li）Update README.md\n（11:35）日语 I：（longlin li）Initial commit\n周一（7.22）\r（19:54）模式识别：（吴俊达）更新教材与参考书以及简要学习建议\n（18:27）模式识别：（Hye）更新教材与参考书以及简要学习建议\n（9:24）.github：（GitHub Actions）ci: update README.md\n周日（7.21）\r（18:25）体育：（longlin li）新增网球课程说明 (#6)\n（17:35）机器视觉：（吴俊达）更新 README (#5)\n（17:18）数字电子技术基础：（吴俊达）更新 2023 试题填空解析 (#7)\n（17:08）运动控制系统：（oliver-wu）上线新课程\n（17:06）hoa-moe：（oliver-wu）更新选课指南中《数学规划》的链接\n（16:15）运动控制系统：（吴俊达）Initial commit\n（16:11）数学规划与数值优化：（oliver-wu）更新课程名\n（15:58）DSP 的原理与应用：（吴俊达）将其划进归档课程\n（15:47）数学规划与数值优化：（oliver-wu）更新学分学时信息\n（15:34）自动控制实践 B：（吴俊达）更新 README，更新实验报告版本，更新 2024 考试题 (#4)\n（15:21）模式识别：（oliver-wu）上线新课程\n（14:45）嵌入式系统：（oliver-wu）更新 README，更新实验报告版本\n（12:03）模式识别：（吴俊达）Initial commit\n（11:35）过程控制系统：（吴俊达）更新一个实验报告版本 (#6)\n周六（7.20）\r（17:18）hoa-moe：（Kowyo）feat: update gpt model in news module to gpt 4o mini (#136)\n（17:15）微积分 B：（IcyDesert）上传 2024 春期末试题和答案，并补充难度情况；更正 README.md 中笔误 (#5)"},"title":"AUTO 周报 2024-07-19 - 2024-07-26"},"/news/weekly/weekly-2024-07-26/weekly-2024-07-26/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r每周提交报告总结\r本周的提交活动如下：\n周一（7.29）：\nlonglin li 对 写作与沟通 项目的 README 进行了多次更新，并进行了初始提交。 Peng Shangpin 在 电路实验 IB 和 电路实验 IA 中添加了报告，在 自动化认知与实践 中增添了新笔记，以及在 马克思主义基本原理 中添加了材料。 周二（7.30）：\nIcyDesert 补充了 写作与沟通 课程介绍。 Peng Shangpin 更新了 体育 的 README。 GitHub Actions 更新了 .github 的 README.md。 周三（7.31）：\nMaxwellJay256 编辑了 写作与沟通 的 README，并新增了批判性思维主题介绍，更新了标签，删除了无用文件夹。 周日（7.28）：\nKowyo 修正了 hoa-moe 项目中的拼写错误。 周六（7.27）：\ngithub-actions[bot] 提交了 hoa-moe 的新每周报告。 总体来看，本周的提交主要集中在对文档的编辑和课程内容的补充，以及对电路实验报告的添加。"},"title":"AUTO 周报 2024-07-26 - 2024-08-02"},"/news/weekly/weekly-2024-08-02/weekly-2024-08-02/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r每周提交报告总结\r本周提交活动如下：\n周二（8.6）\r在 10:12，Maxwell Jay 提交了更新，新增了一种查询 IP 地址的方法，相关内容见 #145。 周六（8.3）\r在 13:00，Kowyo 更新了 README.md 文件。 在 10:17，github-actions 机器人发布了周报，相关内容见 #143。 在 10:12，Kowyo 修复了最新博客文章中添加新行的问题。 本周整体提交较为活跃，主要集中在功能更新和文档维护上。"},"title":"AUTO 周报 2024-08-02 - 2024-08-09"},"/news/weekly/weekly-2024-08-09/weekly-2024-08-09/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r每周提交报告总结\r在本周的提交中，有两项更新：\n周一（8 月 12 日）：Kowyo 在 hoa-moe 中进行了功能更新，主要是保留 AI 摘要，移除了其他文本。\n周二（8 月 13 日）：Kowyo 更新了 hoa-moe 的贡献者列表。"},"title":"AUTO 周报 2024-08-09 - 2024-08-16"},"/news/weekly/weekly-2024-08-30/weekly-2024-08-30/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r周四（9.5）提交报告摘要\r（14:57）在电路 IB项目中，用户 (psp_dada) 添加了笔记 (#7)。 （14:55）在电路 IA项目中，用户 (psp_dada) 添加了笔记并更新了 README 文件 (#3)。 "},"title":"AUTO 周报 2024-08-30 - 2024-09-06"},"/news/weekly/weekly-2024-09-06/weekly-2024-09-06/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r每周提交报告总结\r周五（9.13）\n在大学物理实验项目中，IcyDesert 更新了关于双光栅检测微弱振动的 README.md 文件，并补充了电桥实验的注意事项。 周三（9.11）\nMaxwellJay256 为大学物理实验中各实验文件夹添加了 README.md 文件，仅添加了标题，内容尚未完成。 在概率论与数理统计项目中，MaxwellJay256 上传了 2023 年概率论的回忆试题。 周一（9.9）\n在hoa-moe项目中，github-actions[bot] 提交了新周报的文档更新 (#151)。 本周主要集中于大学物理实验和概率论与数理统计的资料更新和整理。"},"title":"AUTO 周报 2024-09-06 - 2024-09-13"},"/news/weekly/weekly-2024-09-13/weekly-2024-09-13/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r每周提交报告总结\r在过去的一周内，共有几项重要的代码提交：\n周一（9.16）\n更新了hoa-moe项目，包含由 Kowyo 添加的缺失赞助商名单和更新的赞助商名单。同时，github-actions 机器人生成了新的每周报告，供大家参考。 周三（9.18）\n自动控制理论 B项目的吴俊达更新了 2024 年的自动控制理论期末试题。 以上是本周的主要提交内容。"},"title":"AUTO 周报 2024-09-13 - 2024-09-20"},"/news/weekly/weekly-2024-09-20/weekly-2024-09-20/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r每周提交报告总结\r周三（9.25）\nhoa-moe：Maxwell Jay 重新排版了博客《不转码的普通自动化学生能拿多少钱》。 大学物理实验：ChihayaAnon987 更新了小球直径的测量方法。 周二（9.24）\n自动控制实践 A 实验：Hye 修复了 README.md 中的一个无法访问的链接。 控制理论中的代数基础：Hye 修复了 README.md 中的多个无法访问的链接。 大学物理实验：MeYoKona 更新了测量小球直径的方法。 控制理论中的代数基础：吴俊达对电子书进行了清理。 周一（9.23）\nhoa-moe：吴俊达删除了两篇过时文档。 自动控制实践 A 实验：吴俊达更新了课程名称和相关文档。 控制理论中的代数基础：吴俊达更新了 README 和 tag。 自动化认知与实践：吴俊达更新了工程制图基础习题册的答案。 MOOC：oldkingOK 添加了《劳动教育概论》MOOC 章节测试的答案。 周六（9.21）\nhoa-moe：github-actions[bot]提交了新的每周报告。 此次周报涵盖多个项目的更新，包括文档的修正、方法的更新和课程信息的调整，显示出团队在维护与改进资源方面的积极努力。"},"title":"AUTO 周报 2024-09-20 - 2024-09-27"},"/news/weekly/weekly-2024-10-04/weekly-2024-10-04/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r每周提交报告总结\r本周（10 月 6 日至 10 月 11 日）共有多项重要更新和提交：\n周五（10.11）\nhoa-moe 更新了课程 yaml 文件，新增了“GeneralKnowledge”课程。 自动控制理论 B 增加了一份模拟试题和笔记的新版本。 周四（10.10）\n课程评价 更新了 tag.txt 文件。 .github 更新了 README.md 文件，为 GitHub Actions 做了调整。 课程评价 更新了 README.md 文件，初始化了课程信息及内容模板。 周三（10.9）\n课程评价 进行了初始提交。 周日（10.6）\n大学物理实验 不再对某学期的实验进行强调，新增了一些实验的概览和操作细节。 总体来看，本周的提交主要集中在课程更新和文档完善方面，为后续的教学和学习提供了更好的支持。"},"title":"AUTO 周报 2024-10-04 - 2024-10-11"},"/news/weekly/weekly-2024-10-11/weekly-2024-10-11/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r每周提交报告摘要\r在本周的提交中，涉及到自动控制实践 A 项目的两个更新：\n周一（10.14）：Maxwell Jay 对 README 进行了格式排版，并添加了参考书链接，提交编号为#14。\n周四（10.17）：吴俊达修复了 README.md 中的一些拼写错误，提交编号为#15。"},"title":"AUTO 周报 2024-10-11 - 2024-10-18"},"/news/weekly/weekly-2024-10-18/weekly-2024-10-18/":{"data":{"":"","ai-摘要#✨AI 摘要":"✨AI 摘要\r本周提交报告总结\r周五（10 月 25 日）\n完成了多个修复和特性更新，包括匹配模式的更改、废弃用法的修复、徽章样式的改进等。 提升了 hextra 版本，以支持新功能。 周四（10 月 24 日）\n修改了文档更新信息的格式。 周三（10 月 23 日）\n新增了大学物理实验的初始提交及相关开题模板。 周二（10 月 22 日）\n增加了毕业设计的开题报告模板和补充信息。 周一（10 月 21 日）\n执行了对多个项目中触发工作流配置文件的更换，将原有的 hoa.moe 替换为 hoa-moe。 更新了多个项目的文档链接。 本周总体上，团队在修复 bug、优化功能和更新文档等方面做了大量工作，提升了项目的稳定性和可用性。"},"title":"AUTO 周报 2024-10-18 - 2024-10-25"},"/news/weekly/weekly-2024-10-26/":{"data":{"":"","ai-摘要#✨AI 摘要":"\n✨AI 摘要\r每周提交报告总结\r在过去的一周中，共有若干重要提交记录：\n周三 (10.30)：\noliver-wu 在 数值分析 更新了成绩构成信息，并上线了新课程。 GitHub Actions 更新了 .github 的 README.md 文件。 psp_dada 在 自动控制理论 A 重新上传了课程 PPT。 周二 (10.29)：\n吴俊达 在 数值分析 提交了初始版本。 周日 (10.27)：\noliver-wu 在 移动机器人导论 更新了一份实验报告和一份作业。 oliver-wu 在 系统辨识 更新了多份资料。 本周的提交主要集中在数值分析和课程资料的更新上，反映了项目的持续发展和教学内容的完善。"},"title":"AUTO 周报 2024-10-26 - 2024-11-02"},"/news/weekly/weekly-2024-11-01/":{"data":{"":"","ai-摘要#✨AI 摘要":"\n✨AI 摘要\r每周提交报告摘要\r在周二（11 月 5 日），oliver-wu 在 信号分析与处理 项目中提交了更新信息，内容为更新了一份信号笔记。"},"title":"AUTO 周报 2024-11-01 - 2024-11-08"},"/news/weekly/weekly-2024-11-08/":{"data":{"":"","ai-摘要#✨AI 摘要":"\n✨AI 摘要\r每周提交报告总结\r周六 (11.9)\r动量子在 大学物理实验 项目中提交了一项更新：增加了动量子 Typst 实验模板至 README.md (#33)。 "},"title":"AUTO 周报 2024-11-08 - 2024-11-15"},"/news/weekly/weekly-2024-11-15/":{"data":{"":"","ai-摘要#✨AI 摘要":"\n✨AI 摘要\r每周提交报告总结\r在过去一周的提交中，我们主要进行了以下更新：\n周五 (11.22)：345ljh 在数字图像处理项目中提交了课设报告和答辩 PPT。\n周一 (11.18)：GitHub Actions 更新了 .github 文件夹中的 README.md。\n周日 (11.17)：Kowyo 和 Hye 在课程评价项目中进行了一系列更新，包括修改触发工作流和通过留言板征集课程评价。吴俊达对自动控制理论 B 的 README.md 进行了更新，并更新了实验报告，同时下架了一份有误的实验报告。此外，Kowyo 在多个课程中更新了工作流以启用单页构建。\n周六 (11.16)：oliver-wu 在凸优化与最优控制项目中测试了新的触发工作流，同时在自动控制实践 A 实验项目中更新了 Word 版本。\n这一周的提交涵盖了课程报告的更新、工作流的优化及 README 的维护，为接下来的工作做好了准备。"},"title":"AUTO 周报 2024-11-15 - 2024-11-22"},"/news/weekly/weekly-2024-11-23/":{"data":{"":"","ai-摘要#✨AI 摘要":"\n✨AI 摘要\r每周提交报告总结\n更新内容\r周一 (11.25)\r345ljh 在 移动机器人导论 中提交了信息：添加实验代码 (#2) "},"title":"AUTO 周报 2024-11-23 - 2024-11-30"},"/news/weekly/weekly-2024-11-29/":{"data":{"":"","ai-摘要#✨AI 摘要":"","每周提交报告总结#每周提交报告总结":"\n✨AI 摘要\r每周提交报告总结\r本周的更新内容如下：\n周三 (12.4)\rKowyo 在 自动控制实践 A 中提交了关于课后习题的相关资料。 周二 (12.3)\rlonglin li 在 创新训练课 B 中更新了文档，修改了链接样式。 周一 (12.2)\rIcyDesert 在 理论力学Ⅱ 中合并了第七个拉取请求，并补充了 2024 年秋季的期中考试情况，上传了试卷和答案。 "},"title":"AUTO 周报 2024-11-29 - 2024-12-06"},"/news/weekly/weekly-2024-12-06/":{"data":{"":"","ai-摘要#✨AI 摘要":"\n✨AI 摘要\r本周提交报告摘要如下：\n更新内容\r周四 (12.12)：吴俊达在自动控制实践 A中提交了信息，更新了笔记中的一些 bug (#19)。\n周三 (12.11)：吴俊达在数字电子技术基础中提交了趣题解析的更新 (#11)。\n周二 (12.10)：吴俊达在数字电子技术基础中更新了 2024 年数电试题解析，趣题解答及仿真文件，更新了 README (#10)。\n周日 (12.8)：吴俊达在电路 IA中更新了补习材料。\n本周的更新集中在多个电气工程课程的资料和解答上。"},"title":"AUTO 周报 2024-12-06 - 2024-12-13"},"/news/weekly/weekly-2024-12-13/":{"data":{"":"","ai-摘要#✨AI 摘要":"\n✨AI 摘要\r每周提交报告摘要\r在过去的一周内（12 月 15 日到 12 月 20 日），多个用户在多个项目中进行了多项提交。\n主要更新内容如下：\nWDGaster703 在多个课程中补充了基本信息、开课学期和名称，并对成绩构成进行了修改。 psp_dada 上传了作业笔记和试题详解，涵盖了多个课程。 Kowyo 修复了自动控制实践 B 中的错误链接，并更新了课程描述。 zhuqi000 增加了复变函数与积分变换的笔记新版本。 吴俊达 修订了电路 IA 的课件。 总体上，用户们积极更新课程内容，补充相关信息，并上传学习资料，为后续学习提供帮助。"},"title":"AUTO 周报 2024-12-13 - 2024-12-20"},"/news/weekly/weekly-2025-01-12/":{"data":{"":"","更新内容#更新内容":"\n更新内容\r周日 (1.19)\rW·D·Gaster 在 大学英语 中提交了信息：添加韩烨和毕鑫的评价\nW·D·Gaster 在 自动化认知与实践 中提交了信息：重命名部分文件 f\nW·D·Gaster 在 自动化认知与实践 中提交了信息：重命名部分文件\nW·D·Gaster 在 微积分 B 中提交了信息：补充教材\nW·D·Gaster 在 思想道德与法治 中提交了信息：修改授课老师\nW·D·Gaster 在 微积分 B 中提交了信息：修改格式\nOliverWu515 在 移动机器人导论 中提交了信息：新增实验原本任务文件以资对照\nW·D·Gaster 在 中国近现代史纲要 中提交了信息：修改文档名称 (#8)\nW·D·Gaster 在 马克思主义基本原理 中提交了信息：修改未统一的文档命名 (#16)\nOliverWu515 在 移动机器人导论 中提交了信息：将文件扩展名改回 md；修改原先的作业\nOliverWu515 在 自动化领域专家系列讲座 中提交了信息：更改开课学期\nOliverWu515 在 自动化领域专家系列讲座 中提交了信息：新增课程信息与报告模板\n吴俊达 在 自动控制理论 A 中提交了信息：更新一个实验报告版本；重命名文件夹及整理文件 (#7)\n周六 (1.18)\rW·D·Gaster 在 习近平新时代中国特色社会主义思想概论 中提交了信息：修改不统一的文件命名和分类 (#2)\nW·D·Gaster 在 思想道德与法治 中提交了信息：调整文件位置 (#3)\n吴俊达 在 自动控制实践 A 中提交了信息：增加一个实验报告版本 (#25)\n吴俊达 在 自动控制实践 A 实验 中提交了信息：更新 2022 实验报告版本；更新 README (#13)\nOrigami404 在 思想道德与法治 中提交了信息：OpenCS 内容合并 (#2)\nOrigami404 在 概率论与数理统计 中提交了信息：OpenCS 内容合并 (#9)\nOrigami404 在 毛泽东思想和中国特色社会主义理论体系概论 中提交了信息：OpenCS 内容合并 (#6)\nOrigami404 在 微积分 B 中提交了信息：OpenCS 内容合并 (#8)\nOrigami404 在 中国近现代史纲要 中提交了信息：OpenCS 内容合并 (#7)\nOrigami404 在 马克思主义基本原理 中提交了信息：OpenCS 内容合并 (#15)\nOrigami404 在 微积分 A 中提交了信息：OpenCS 内容合并 (#10)\n周五 (1.17)\rOrigami404 在 高级语言程序设计 中提交了信息：OpenCS 内容合并 (#7)\npsp_dada 在 自动控制理论 A 中提交了信息：上传实验相关内容 (#6)\n周二 (1.14)\rpsp_dada 在 自动控制理论 A 中提交了信息：上传 24 作业详解 (#5)\npsp_dada 在 自动控制实践 A 实验 中提交了信息：添加新报告 (#12)\npsp_dada 在 自动控制实践 A 中提交了信息：上传 24 作业 (#23)\npsp_dada 在 模式识别 中提交了信息：上传实验报告 (#6)\npsp_dada 在 大学物理实验 中提交了信息：重新上传个人的实验报告 (#36)"},"title":"AUTO 周报 2025-01-12 - 2025-01-19"},"/news/weekly/weekly-2025-01-17/":{"data":{"":"","更新内容#更新内容":"\n更新内容\r周五 (1.24)\rW·D·Gaster 在 信号分析与处理 中提交了信息：修改落款格式，将课程内容单列使之更清晰 (#16)\nW·D·Gaster 在 高级语言程序设计 中提交了信息：添加 23 级作业和实验代码文件，修改部分文件命名，修改 readme 部分的格式问题 (#8)\n吴俊达 在 机器视觉 中提交了信息：更新文件命名；更新实验报告、作业版本（其中代码已做处理） (#9)\n吴俊达 在 嵌入式系统 中提交了信息：更新一个实验报告版本；根据同学们的反馈更新课程描述 (#3)\nguoyuchen2004 在 复变函数与积分变换 中提交了信息：Update README.md (#14)\nguoyuchen2004 在 概率论与数理统计 中提交了信息：Update README.md (#13)\nIcyDesert 在 自动控制理论 B 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位 (#10)\nIcyDesert 在 机器人学导论 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位 (#12)\n周四 (1.23)\rW·D·Gaster 在 概率论与数理统计 中提交了信息：修改部分文件命名和文件夹归属，添加教材 (#10)\nIcyDesert 在 数字图像处理 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位 (#11)\nlonglin li 在 微积分 A 中提交了信息：Update trigger-workflow.yml (#13)\nIcyDesert 在 过程控制系统 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位 (#12)\nIcyDesert 在 DSP 的原理与应用 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 运动控制系统 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 机器视觉 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 自动控制实践 B 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位 (#9)\nIcyDesert 在 自动化领域专家系列讲座 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 模式识别 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 数学规划与数值优化 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 嵌入式系统 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 机器学习概论 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nW·D·Gaster 在 中国近现代史纲要 中提交了信息：修改文档落款格式，删除不明确的老师说明 (#9)\nW·D·Gaster 在 模拟电子技术基础 中提交了信息：上传误删的哈工大 10-16 试题 (#13)\nW·D·Gaster 在 数字电子技术基础 中提交了信息：修改 readme 文档的部分格式，修改部分文件命名 (#14)\n周三 (1.22)\rW·D·Gaster 在 复变函数与积分变换 中提交了信息：修改部分文件命名，上传高瑜老师的讲义 (#12)\nIcyDesert 在 系统建模与仿真 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位 (#11)\nIcyDesert 在 自动控制实践 A 实验 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 自动控制实践 A 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位 (#26)\nIcyDesert 在 自动控制理论 A 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 工程训练（金工实习） 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 体育 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 理论力学Ⅱ 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 数字电子技术实验 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 信号分析与处理 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位 (#17)\nIcyDesert 在 数字电子技术基础 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位 (#15)\n吴俊达 在 非线性与自适应控制 中提交了信息：更新非线性与自适应控制笔记和试卷 (#2)\n周二 (1.21)\rIcyDesert 在 模拟电子技术基础 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位 (#12)\nIcyDesert 在 模拟电子技术实验 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nW·D·Gaster 在 模拟电子技术基础 中提交了信息：补充谷雨老师的评价，修改 readme 的部分格式，修改部分文件命名\nIcyDesert 在 自动化认知与实践 中提交了信息：加入 .gitkeep 作为文件夹占位 (#16)\nIcyDesert 在 数据结构与算法 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 控制理论中的代数基础 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 毛泽东思想和中国特色社会主义理论体系概论 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nIcyDesert 在 系统与控制 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位\nW·D·Gaster 在 微积分 A 中提交了信息：补充教材 (#11)\n周一 (1.20)\rW·D·Gaster 在 自动化认知与实践 中提交了信息：Merge pull request #15 from WDGaster703/main\nWDGaster 在 自动化认知与实践 中提交了信息：修复 psp 的笔记，删除 readme，修改文档落款格式\n周日 (1.19)\r吴俊达 在 过程控制系统 中提交了信息：整理资料（修改文件名；删除不具有参考价值的资料） (#10)\nlonglin li 在 写作与沟通 中提交了信息：delete: 删除学期信息 (#2)\n吴俊达 在 日语 I 中提交了信息：Update tag.txt\n吴俊达 在 普通天文学 中提交了信息：Update tag.txt\n吴俊达 在 线性系统理论 中提交了信息：更新课程说明；更新 2024 秋考试试题 (#3)\nW·D·Gaster 在 大学英语 中提交了信息：添加韩烨和毕鑫的评价\nW·D·Gaster 在 自动化认知与实践 中提交了信息：重命名部分文件 f\nW·D·Gaster 在 自动化认知与实践 中提交了信息：重命名部分文件\nW·D·Gaster 在 微积分 B 中提交了信息：补充教材\nW·D·Gaster 在 思想道德与法治 中提交了信息：修改授课老师\nW·D·Gaster 在 微积分 B 中提交了信息：修改格式\nOliverWu515 在 移动机器人导论 中提交了信息：新增实验原本任务文件以资对照\nW·D·Gaster 在 中国近现代史纲要 中提交了信息：修改文档名称 (#8)\nW·D·Gaster 在 马克思主义基本原理 中提交了信息：修改未统一的文档命名 (#16)\nOliverWu515 在 移动机器人导论 中提交了信息：将文件扩展名改回 md；修改原先的作业\nOliverWu515 在 自动化领域专家系列讲座 中提交了信息：更改开课学期\nOliverWu515 在 自动化领域专家系列讲座 中提交了信息：新增课程信息与报告模板\n吴俊达 在 自动控制理论 A 中提交了信息：更新一个实验报告版本；重命名文件夹及整理文件 (#7)\n周六 (1.18)\rW·D·Gaster 在 习近平新时代中国特色社会主义思想概论 中提交了信息：修改不统一的文件命名和分类 (#2)\nW·D·Gaster 在 思想道德与法治 中提交了信息：调整文件位置 (#3)\n吴俊达 在 自动控制实践 A 中提交了信息：增加一个实验报告版本 (#25)\n吴俊达 在 自动控制实践 A 实验 中提交了信息：更新 2022 实验报告版本；更新 README (#13)\nOrigami404 在 思想道德与法治 中提交了信息：OpenCS 内容合并 (#2)\nOrigami404 在 概率论与数理统计 中提交了信息：OpenCS 内容合并 (#9)\nOrigami404 在 毛泽东思想和中国特色社会主义理论体系概论 中提交了信息：OpenCS 内容合并 (#6)\nOrigami404 在 微积分 B 中提交了信息：OpenCS 内容合并 (#8)\nOrigami404 在 中国近现代史纲要 中提交了信息：OpenCS 内容合并 (#7)\nOrigami404 在 马克思主义基本原理 中提交了信息：OpenCS 内容合并 (#15)\nOrigami404 在 微积分 A 中提交了信息：OpenCS 内容合并 (#10)\n周五 (1.17)\rOrigami404 在 高级语言程序设计 中提交了信息：OpenCS 内容合并 (#7)\npsp_dada 在 自动控制理论 A 中提交了信息：上传实验相关内容 (#6)"},"title":"AUTO 周报 2025-01-17 - 2025-01-24"},"/news/weekly/weekly-2025-01-24/":{"data":{"":"","更新内容#更新内容":"\n更新内容\r周五 (1.31)\rzhuqi000 在 大学物理实验 中提交了信息：增加了几份大雾实验报告 (#37) 周二 (1.28)\r吴俊达 在 机器学习概论 中提交了信息：更新 2024 秋季情况 (#3)\nMaxwell Jay 在 自动控制理论 A 中提交了信息：更新课程文档、上传 2024 年期末试题及参考答案 (#10)\n周日 (1.26)\rW·D·Gaster 在 创新训练课 B 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件 (#8)\nW·D·Gaster 在 中国近现代史纲要 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件 (#10)\nW·D·Gaster 在 复变函数与积分变换 中提交了信息：删除无用的 readme 文件 (#16)\nW·D·Gaster 在 高等电路与电子分析 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件，添加一份笔记 (#2)\nW·D·Gaster 在 马克思主义基本原理 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件 (#20)\n周六 (1.25)\rW·D·Gaster 在 大学物理 中提交了信息：修改部分文件命名，上传 24 秋本部章节练习题，补充大物 II 部分内容，修改学习建议 (#11)\n吴俊达 在 自动控制理论 B 中提交了信息：更新显示错误的学分数\nHye 在 凸优化与最优控制 中提交了信息：更新课程说明；更新 2024 秋考试试题 (#6)\n吴俊达 在 自动控制理论 B 中提交了信息：更改文件名 (#11)\nMaxwell Jay 在 数字图像处理 中提交了信息：2024 年 DIP 课程文档和资料更新 (#12)\n吴俊达 在 自动化领域专家系列讲座 中提交了信息：更新 README.md\n吴俊达 在 程序设计思维与实践 中提交了信息：Update tag.txt\n周五 (1.24)\r吴俊达 在 程序设计思维与实践 中提交了信息：Update tag.txt\n吴俊达 在 （示例）大学物理实验 中提交了信息：Initial commit\nIcyDesert 在 机械设计基础 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位 (#5)\nW·D·Gaster 在 信号分析与处理 中提交了信息：修改落款格式，将课程内容单列使之更清晰 (#16)\nW·D·Gaster 在 程序设计思维与实践 中提交了信息：添加 23 级作业和实验代码文件，修改部分文件命名，修改 readme 部分的格式问题 (#8)\n吴俊达 在 机器视觉 中提交了信息：更新文件命名；更新实验报告、作业版本（其中代码已做处理） (#9)\n吴俊达 在 嵌入式系统 中提交了信息：更新一个实验报告版本；根据同学们的反馈更新课程描述 (#3)\nguoyuchen2004 在 复变函数与积分变换 中提交了信息：Update README.md (#14)\nguoyuchen2004 在 概率论与数理统计 中提交了信息：Update README.md (#13)\nIcyDesert 在 自动控制理论 B 中提交了信息：删除仓库文件夹中无意义的 README.md，以 .gitkeep 占位 (#10)"},"title":"AUTO 周报 2025-01-24 - 2025-01-31"},"/news/weekly/weekly-2025-01-31/":{"data":{"":"","更新内容#更新内容":"\n更新内容\r周一 (2.3)\r吴俊达 在 数字图像处理 中提交了信息：更新 WJD 作业（采用新方式编译减小空间占用） (#13) 周日 (2.2)\rIcyDesert 在 理论力学Ⅱ 中提交了信息：补充凡友华老师上课情况；补充 24 秋期末考试情况，上传回忆版试卷 (#8) "},"title":"AUTO 周报 2025-01-31 - 2025-02-07"},"/news/weekly/weekly-2025-02-07/":{"data":{"":"","更新内容#更新内容":"\n更新内容\r周五 (2.14)\rW·D·Gaster 在 工程训练（电子工艺实习） 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件，修改文档格式 (#2) 周三 (2.12)\rW·D·Gaster 在 电路 IB 中提交了信息：修改 readme 格式，修改部分文件命名 (#12) 周日 (2.9)\rW·D·Gaster 在 微积分 B 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件 (#9) 周六 (2.8)\rW·D·Gaster 在 C++ 语言程序设计 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件 (#5)\nW·D·Gaster 在 代数与几何 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件；整理文件夹 (#14)\nW·D·Gaster 在 思想道德与法治 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件 (#4)\nW·D·Gaster 在 习近平新时代中国特色社会主义思想概论 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件 (#3)\nW·D·Gaster 在 电路实验 IB 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件 (#7)\nW·D·Gaster 在 微积分 A 中提交了信息：以 .gitkeep 文件替代无用的 readme.md 文件 (#14)"},"title":"AUTO 周报 2025-02-07 - 2025-02-14"},"/sponsor/":{"data":{"":"","感谢名单#感谢名单":"NJUST课程攻略共享计划 是一个非盈利项目。目前由NJUST OpenLab维护，理工维基（NJUST.WIKI）提供资金支持。\n（事实上不管是理工维基还是NJUST OpenLab都只有我一个人）\n得益于Github Actions和Cloudflare的免费服务，本站得以低成本运行。\n但为了同学们可以方便地访问和使用，我们购买了独立的域名。（NJUST.WIKI）\n同时配置了镜像站及Github加速服务，以便于在特定网络环境下加速访问\n以下是我们目前的支出：\n域名：89 元/年\r用于将域名解析到国内 DNS，并且这个短小可爱的域名可以为你输入网址/跟朋友推荐时节省不少时间\r如果您认为 NJUST课程攻略共享计划 提供的信息对您有帮助，请考虑捐助 ¥2 给我们。每一份慷慨捐助都将大幅减轻我们承担的域名的费用负担，同时也是对维护者最大的鼓励。我们鼓励选择“向对方展示我的名字”，你的 ID 和留言将会显示在我们的 Sponsor 页面中。受限于赞赏的留言字数限制，如果你有更多想说的，欢迎致信我们的 📮邮箱。\n捐助进度\rHITSZ 自动化课程攻略共享计划 希望达成的生命周期是 10 年（2033 年 11 月），目前收到的捐助可以让本项目的生命延续到 2028 年 7 月：\n2033 年 11 月\r感谢名单\rHITSZ 自动化课程攻略共享计划 便捷的访问服务离不开以下每一位同学/社会人士的热心捐助（按照时间排序）：\n来自 日期 留言 Somnambulist 2023.12.2 感谢各位用爱发电😭😭😭 旅行者 2023.12.2 支持 HITSZ 自动化课程攻略共享计划项目！ 匿名 2023.12.2 2023.12.3 Welcome 2023.12.3 Jessie 2023.12.4 加油！感谢你们！ 追鱼 2023.12.6 ʚ🧸ɞ 小熊不吃饼干 2023.12.6 辛苦啦 乙醛 2023.12.6 针不戳 匿名 2023.12.7 双手插口袋 2023.12.16 朗晴 2023.12.18 卢瑟帝国 2023.12.22 Eyoung 2023.12.24 Nolan 2023.12.25 匿名 2023.12.27 匿名 2023.12.27 双手插口袋 2023.12.30 Flying Pig 2024.1.1 匿名 2024.1.2 老年人、咖喱 2024.1.3 好好好 tql 南飞的楸叶 2024.2.22 Mw_w 2024.2.21 陈通 2024.2.25 匿名 2024.2.29 凉乐 2024.3.5 互联网精神，赞！ 匿名 2024.3.18 应得的赞赏 匿名 2024.3.18 学长加油🫡 wjy 2024.3.18 吃饭听歌薛凯琪 2024.3.23 感谢😭😭😭😭 Sieroy 2024.3.26 👍 Sieroy 2024.4.3 狠狠加油👍 záng 2024.4.6 谢谢学长学姐和同学们 匿名 2024.4.8 匿名 2024.4.9 辛苦了！非常感谢！ 刘 2024.4.11 good good Xian 2024.4.13 感谢 匿名 2024.4.17 suebskoa 2024.4.17 达哥厉害 Pilot 2024.4.19 上学期考试过了过来还愿 匿名 2024.4.19 Sieroy 2024.5.5 Fly me 2 HITSZ Sieroy 2024.6.1 HITSZ Gakuen Bobo 2024.6.10 Jori 2024.8.12 很有帮助 感恩 @ 2024.8.30 伟大无需多言 缘安 2024.9.13 谢谢！！！！ Leo 2024.10.9 我愿称其为，泥深最优秀的定西 随心 2024.10.11 大一新生（混子）想搞个 openhitsz empty 2024.10.31 受益匪浅 匡 2024.11.1 以及很不错啦！ Stephen 2024.11.1 希望网站办得越来越好 (¯▽¯)👍 匿名 2024.11.16 很感谢你们辛苦做的网站，对我帮助很大 Olo 2024.11.24 感谢 伟大无需多言 záng 2024.12.18 特别好的开源项目，支持 离经盼道 2024.12.18 zdh 坏，hoa 好 匿名 2024.12.18 匿名 2024.12.18 匿名 2024.12.20 起名好麻烦 2025.1.1 伟大的互联网精神 了不起的杰飞里斯 2025.1.4 神中神！感恩 Alan 2025.1.6 来支持了 ","捐助进度#捐助进度":""},"title":"捐助我们"}}